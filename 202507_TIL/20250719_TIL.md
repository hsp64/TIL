# 25년 7월 19일


---

#  IoC(제어의 역전) 원칙에 따라 DI(의존성 주입)를 사용하여 객체(빈)의 생성과 의존 관계를 직접 관리하는 핵심 원리

## 2.1 IoC (제어의 역전) 개념

### IoC의 기본 개념과 역할
- IoC (Inversion of Control)는 객체의 생성 및 관리 제어권이 개발자에게서 프레임워크나 컨테이너로 넘어가는 프로그래밍 원칙이다.
- 전통적인 방식에서는 개발자가 직접 객체를 생성하고 의존성을 설정하지만, IoC에서는 프레임워크(예: 스프링 컨테이너)가 이를 대신한다.
- IoC는 객체 간의 결합도를 낮추고, 코드의 유연성과 유지보수성을 높인다.
- IoC는 주로 의존성 주입(DI, Dependency Injection)을 통해 구현된다.

### IoC 컨테이너의 종류
스프링은 IoC를 구현하기 위해 두 가지 주요 컨테이너 인터페이스를 제공한다.

- **BeanFactory**:
    - 스프링 IoC 컨테이너의 가장 기본적인 형태이다.
    - 빈(Bean)이 실제로 요청될 때 생성하는 게으른 초기화(lazy loading) 방식을 사용한다.
    - 리소스가 제한적인 환경에 적합하다.

- **ApplicationContext**:
    - `BeanFactory`를 상속받아 확장된 기능을 제공한다.
    - 국제화 메시지 처리, 이벤트 발행 등 다양한 부가 기능을 지원한다.
    - 컨테이너 시작 시점에 모든 싱글톤 빈을 미리 생성하는 즉시 초기화(eager loading) 방식을 사용한다.
    - 대부분의 스프링 애플리케이션에서 사용된다.
    - 주요 구현체로는 `ClassPathXmlApplicationContext`, `FileSystemXmlApplicationContext`, `AnnotationConfigApplicationContext` 등이 있다.

### 스프링 IoC 컨테이너의 동작 방식
1.  **빈 정의**: XML, 자바 애너테이션, 자바 설정 클래스를 통해 컨테이너가 관리할 객체(빈)를 정의한다.
2.  **빈 생성**: 컨테이너는 빈 정의를 바탕으로 객체를 생성한다.
3.  **의존성 주입**: 생성된 빈이 필요로 하는 다른 빈(의존성)을 컨테이너가 주입한다.
4.  **빈 초기화**: 의존성 주입이 완료된 후, 빈의 초기화 메서드가 호출된다.
5.  **빈 사용**: 애플리케이션에서 컨테이너를 통해 필요한 빈을 가져와 사용한다.
6.  **빈 소멸**: 컨테이너가 종료될 때 관리하던 빈을 소멸시킨다.

## 2.2 의존성 주입 (DI) 개념

### DI의 중요성과 개념
- 의존성 주입(Dependency Injection)은 한 객체가 다른 객체를 사용하는 의존 관계에서, 필요한 객체를 외부(컨테이너)에서 주입해주는 설계 패턴이다.
- DI는 객체 간의 결합도를 낮추고, 테스트 용이성을 높이며, 코드의 유연성과 재사용성을 향상시킨다.

### DI의 종류
- **생성자 주입 (Constructor Injection)**:
    - 생성자를 통해 의존성을 주입받는 방식이다.
    - 객체 생성 시점에 모든 의존성이 주입되므로 객체의 불변성을 보장하고, 의존성 누락을 방지할 수 있다.
    - **스프링에서 가장 권장되는 방식이다.**

- **세터 주입 (Setter Injection)**:
    - 세터(setter) 메서드를 통해 의존성을 주입받는 방식이다.
    - 객체 생성 이후에 의존성을 주입할 수 있어 선택적인 의존성 설정에 용이하다.

- **필드 주입 (Field Injection)**:
    - 필드에 `@Autowired` 같은 애너테이션을 붙여 직접 의존성을 주입하는 방식이다.
    - 코드가 간결해지지만, 외부에서 제어가 어렵고 테스트가 불편하며 순환 참조 같은 문제가 발생할 수 있어 사용이 권장되지 않는다.

### 생성자 주입을 선호하는 이유
1.  **불변성 보장**: 생성 시점에만 의존성을 주입하므로 객체의 상태가 변하지 않음을 보장할 수 있다.
2.  **필수 의존성 강제**: 생성자 매개변수로 의존성을 받으므로, 필수적인 의존성이 누락되는 것을 컴파일 시점에 막을 수 있다.
3.  **순환 의존성 문제 예방**: 순환 참조 문제가 발생할 경우 애플리케이션 시작 시점에 오류를 발견할 수 있다.
4.  **테스트 용이성**: 의존성을 외부에서 쉽게 주입할 수 있어 단위 테스트 시 모의 객체(Mock) 활용이 편리하다.
5.  **코드 가독성**: 객체가 어떤 의존성을 필요로 하는지 생성자를 통해 명확하게 파악할 수 있다.

## 2.3 스프링 빈(Bean) 관리

### 스프링 빈의 정의와 생명주기
- **스프링 빈**: 스프링 IoC 컨테이너가 생성하고 관리하는 객체이다.
- **빈 생명주기**: 컨테이너에 의해 `정의 -> 생성 -> 의존성 주입 -> 초기화 -> 사용 -> 소멸`의 과정을 거친다.
    - 초기화 콜백: `@PostConstruct`
    - 소멸 전 콜백: `@PreDestroy`

### 빈 생성과 관리 방법
- **XML 설정**: `<bean>` 태그를 사용하여 빈을 정의하는 전통적인 방식이다.
- **자바 설정 (Java Configuration)**: `@Configuration`과 `@Bean` 애너테이션을 사용하여 자바 클래스로 설정을 관리하는 방식이다. 타입 안전성을 보장한다.
- **애너테이션 기반 설정**: `@ComponentScan`을 통해 특정 패키지 내의 클래스를 스캔하고, 스테레오타입 애너테이션이 붙은 클래스를 빈으로 자동 등록하는 방식이다.

### @Component와 스테레오타입 애너테이션
스프링은 빈의 역할을 명확하게 구분하기 위해 특화된 애너테이션을 제공한다. 이들은 모두 내부에 `@Component`를 포함하고 있어 빈으로 등록된다.

- **`@Component`**: 가장 일반적인 빈을 정의할 때 사용한다.
- **`@Service`**: 비즈니스 로직을 처리하는 서비스 계층의 클래스에 사용한다.
- **`@Repository`**: 데이터 접근 계층(DAO)의 클래스에 사용하며, 데이터 관련 예외를 스프링 예외로 변환해주는 기능이 포함되어 있다.
- **`@Controller`**: 웹 애플리케이션의 프레젠테이션 계층에서 사용자 요청을 처리하는 컨트롤러 클래스에 사용한다.
