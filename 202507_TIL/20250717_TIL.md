# 25년 7월 17일

# 스프링 핵심 원리와 객체 지향 설계

오늘은 자바 개발의 핵심 프레임워크인 스프링의 기본 철학과 좋은 코드를 만들기 위한 객체 지향 설계 원칙(SOLID)에 대해 학습했다. 스프링이 왜 그렇게 설계되었는지, 그리고 그 기반이 되는 원칙들이 무엇인지 이해하는 시간이었다.

### 1. 스프링 프레임워크의 존재 이유

- **EJB의 문제 해결**: 과거의 자바 엔터프라이즈 개발(EJB)은 너무 복잡하고, 무겁고, 특정 기술에 종속적인 문제(침투적 기술)가 있었다.
- **POJO의 부활**: 스프링은 이런 문제들을 해결하기 위해, 특정 기술에 의존하지 않는 평범한 자바 객체(**POJO**, Plain Old Java Object)를 사용해 비즈니스 로직을 구현하도록 설계되었다. 이로 인해 코드가 단순해지고 테스트가 쉬워졌다.
- **핵심 철학**: 결국 스프링은 **좋은 객체 지향 설계**를 개발자가 쉽게 적용할 수 있도록 돕는 것이 핵심 목표다.

### 2. 객체 지향 설계 5원칙 (SOLID) - 좋은 코드의 청사진

SOLID는 유연하고, 유지보수가 쉬우며, 확장에 용이한 소프트웨어를 만들기 위한 5가지 설계 원칙이다.

- **S (단일 책임 원칙, SRP)**: **하나의 클래스는 하나의 책임만 가져야 한다.**
  - `직원` 클래스가 `급여 계산`과 `보고서 생성`을 모두 하는 것은 SRP 위반이다.
  - `급여 계산기`, `보고서 생성기` 클래스로 분리해야 한다.
  - **Why?**: 하나의 책임만 가지면 코드를 이해하기 쉽고, 변경이 필요할 때 해당 기능에만 영향을 미쳐 안정성이 높아진다.

- **O (개방-폐쇄 원칙, OCP)**: **확장에는 열려있고, 수정에는 닫혀있어야 한다.**
  - 새로운 기능을 추가할 때 기존 코드를 수정하면 안 된다.
  - **How?**: 인터페이스(추상화)를 사용한다. `AreaCalculator`가 `Shape` 인터페이스에만 의존하면, 새로운 도형(`Triangle`)이 추가되어도 `AreaCalculator` 코드는 수정할 필요가 없다.
  - **Why?**: 기존 코드의 안정성을 해치지 않으면서 시스템을 유연하게 확장할 수 있다.

- **L (리스코프 치환 원칙, LSP)**: **자식 클래스는 언제나 부모 클래스를 대체할 수 있어야 한다.**
  - 부모 타입으로 객체를 사용해도, 자식의 구체적인 구현을 몰라도 기능이 문제없이 동작해야 한다.
  - 예시: `Square`를 `Rectangle`의 자식으로 만들었을 때, `setWidth()`와 `setHeight()`의 동작 방식이 부모와 달라지면 LSP를 위반할 수 있다.
  - **Why?**: 다형성의 신뢰를 보장하고, OCP를 지키는 기반이 된다.

- **I (인터페이스 분리 원칙, ISP)**: **클라이언트는 자신이 사용하지 않는 기능에 의존해서는 안 된다.**
  - 하나의 '뚱뚱한' 인터페이스보다, 여러 개의 '날씬한' 인터페이스가 낫다.
  - 예시: `Worker` 인터페이스에 `work()`와 `eat()`가 모두 있다면, 밥을 먹지 않는 `Robot` 클래스는 불필요한 `eat()` 메서드를 구현해야 한다. `Workable`과 `Eatable` 인터페이스로 분리하는 것이 좋다.
  - **Why?**: 시스템의 결합도를 낮추고, 불필요한 의존성을 제거한다.

- **D (의존성 역전 원칙, DIP)**: **구체적인 구현이 아닌, 추상화(인터페이스)에 의존해야 한다.**
  - 고수준 모듈(e.g., `Computer`)이 저수준 모듈(e.g., `SamsungKeyboard`)에 직접 의존하면 안 된다.
  - 둘 다 `InputDevice`라는 인터페이스에 의존해야 한다.
  - **Why?**: 부품(구현체)을 쉽게 갈아 끼울 수 있어 시스템이 매우 유연해지고 확장성이 극대화된다.

### 3. 스프링의 핵심 메커니즘: IoC/DI

**SOLID 원칙, 특히 DIP를 쉽게 구현하도록 도와주는 도구가 바로 스프링의 IoC/DI다.**

- **IoC (Inversion of Control, 제어의 역전)**: 객체의 생성, 관리, 소멸 등 모든 **제어권**이 개발자가 아닌 **프레임워크(스프링 컨테이너)**에게 넘어간 것.
- **DI (Dependency Injection, 의존성 주입)**: IoC를 구현하는 방법. 필요한 객체(의존성)를 클래스 내부에서 `new`로 직접 생성하는 게 아니라, 외부(스프링 컨테이너)에서 만들어서 넣어주는 것.
- **IoC 컨테이너 (`ApplicationContext`)**: `@Bean`, `@Component` 등으로 정의된 객체들을 관리하고, 필요한 곳에 DI를 해주는 스프링의 핵심 엔진.

#### DI의 3가지 방법과 선택

1.  **생성자 주입 (가장 권장)**: 생성자를 통해 의존성을 주입.
    - **장점**:
        - **불변성**: `final` 키워드를 쓸 수 있어 런타임에 의존성이 변경되는 것을 막는다.
        - **필수 의존성 명시**: 객체 생성 시점에 반드시 필요한 의존성을 누락하지 않도록 강제할 수 있다.
        - **순환 참조 방지**: 순환 참조 발생 시 애플리케이션 실행 시점에서 오류를 발견할 수 있다.
2.  **세터 주입**: `setXxx()` 메서드를 통해 주입. 선택적인 의존성을 주입할 때 사용.
3.  **필드 주입**: `@Autowired`를 필드에 직접 붙이는 방식. 코드가 간결하지만 테스트가 어렵고 단점이 많아 지양해야 한다.

### 4. 스프링 빈(Bean) 관리

- **빈(Bean)이란?**: 스프링 IoC 컨테이너가 **생성하고 관리하는 객체**.
- **빈으로 등록하는 방법**:
  - **컴포넌트 스캔**: `@Component` 애노테이션을 클래스에 붙이면 스프링이 자동으로 찾아 빈으로 등록한다.
  - **역할에 따른 애노테이션**: 가독성과 목적을 명확히 하기 위해 계층별로 다른 애노테이션을 사용한다.
    - `@Controller`: 프레젠테이션 계층 (웹 요청 처리)
    - `@Service`: 서비스(비즈니스 로직) 계층
    - `@Repository`: 데이터 접근 계층 (DB 연동, 예외 변환)
    - `@Configuration`: 설정 정보를 담는 클래스
- **빈 생명주기**: 스프링 컨테이너가 `생성 → 의존성 주입 → 초기화 → 사용 → 소멸`의 전 과정을 관리해준다. 개발자는 비즈니스 로직에만 집중할 수 있다.
