# 25년 7월 27일


---


# JPA 핵심 개념, 동작 원리, 성능 최적화, 실무 설계

## 1. JPA 기본 개념과 등장 배경

*   **JPA (Java Persistence API)**
    *   자바 애플리케이션에서 관계형 데이터베이스를 사용하는 방식을 정의한 **자바 표준 명세(Interface)**이다.
    *   JPA는 API일 뿐이며, 실제 구현은 하이버네이트(Hibernate), EclipseLink 등의 구현체가 담당한다. (실무에서는 대부분 하이버네이트 사용)

*   **ORM (Object-Relational Mapping)**
    *   JPA의 핵심 사상으로, 객체와 관계형 데이터베이스의 테이블을 자동으로 매핑하는 기술이다.
    *   **패러다임 불일치 해결**: 객체 지향의 상속, 다형성, 연관관계 등과 관계형 데이터베이스의 테이블 구조 사이의 간극을 메워준다.
    *   개발자는 SQL 중심이 아닌, 객체 중심의 프로그래밍에 집중할 수 있다.

*   **JPA 사용의 이점**
    *   **생산성**: `save()`, `findById()` 등 기본적인 CRUD SQL을 직접 작성할 필요가 없어 반복적인 코드가 줄어든다.
    *   **유지보수**: 필드 변경 시 모든 SQL을 수정할 필요 없이 매핑 정보만 수정하면 되므로 유지보수가 용이하다.
    *   **데이터베이스 비종속성**: JPA는 각 데이터베이스에 맞는 SQL(방언, Dialect)을 생성해주므로, DB를 변경하더라도 코드 수정이 거의 필요 없다.

## 2. JPA 핵심 동작 원리: 영속성 컨텍스트

*   **영속성 컨텍스트(Persistence Context)**
    *   "엔티티를 영구 저장하는 환경"으로, 엔티티 매니저를 통해 접근하는 논리적인 영역이다.
    *   엔티티 매니저 생성 시 하나 만들어지며, 트랜잭션 범위 안에서 동작한다.

*   **엔티티 생명주기(Entity Lifecycle)**
    *   **비영속(New/Transient)**: `new Member()` 와 같이 순수하게 객체만 생성한 상태. 영속성 컨텍스트와 무관하다.
    *   **영속(Managed)**: `entityManager.persist(member)`를 통해 엔티티가 영속성 컨텍스트에 의해 관리되는 상태.
    *   **준영속(Detached)**: `entityManager.detach(member)` 또는 `entityManager.close()` 등으로 영속성 컨텍스트가 더 이상 관리하지 않는 상태.
    *   **삭제(Removed)**: `entityManager.remove(member)`를 통해 데이터베이스에서 삭제하기로 한 상태.

*   **영속성 컨텍스트의 주요 기능**
    *   **1차 캐시**: 영속성 컨텍스트 내부에 `Map` 형태의 캐시가 존재. `@Id`를 Key, 엔티티 인스턴스를 Value로 저장한다. 한 트랜잭션 내에서 `findById()`를 반복 호출해도 첫 조회 이후에는 DB가 아닌 1차 캐시에서 조회한다.
    *   **동일성(Identity) 보장**: 1차 캐시 덕분에 같은 트랜잭션 내에서 조회한 ID가 같은 엔티티는 동일한 인스턴스임이 보장된다 (`a == b`).
    *   **쓰기 지연(Transactional Write-behind)**: `persist()` 호출 시 INSERT SQL을 바로 DB에 보내지 않고, 내부의 SQL 저장소에 모아둔다. 트랜잭션이 커밋될 때 모아둔 SQL을 한 번에 DB로 전송(Flush)한다.
    *   **변경 감지(Dirty Checking)**: 영속 상태의 엔티티는 최초 상태를 스냅샷으로 저장해둔다. 트랜잭션 커밋 시점에 스냅샷과 현재 엔티티를 비교하여 변경된 부분이 있으면 UPDATE SQL을 자동으로 생성하여 쓰기 지연 SQL 저장소로 보낸다.

## 3. 엔티티 매핑

*   **기본 매핑**: `@Entity`, `@Table`, `@Id`, `@GeneratedValue(strategy=...)`, `@Column(nullable=, length=, unique=)`
*   **연관관계 매핑**:
    *   방향: 단방향, 양방향
    *   다중성: `@ManyToOne`(N:1), `@OneToMany`(1:N), `@OneToOne`(1:1), `@ManyToMany`(N:M, 실무에서는 거의 사용 안 함)
    *   **연관관계의 주인(Owner)**: 외래 키(FK)를 관리하는 쪽이 주인이다. 보통 N쪽, 즉 `@ManyToOne` 어노테이션이 붙은 쪽이 주인이 된다. 주인이 아닌 쪽은 `mappedBy` 속성을 사용하여 주인을 명시해야 한다.
    *   **FetchType.LAZY (지연 로딩)**: 모든 연관관계는 N+1 문제 방지를 위해 반드시 지연 로딩으로 설정해야 한다. 연관된 엔티티를 실제 사용하는 시점에 조회 쿼리가 나간다.
    *   **FetchType.EAGER (즉시 로딩)**: 엔티티 조회 시 연관된 엔티티도 함께 조회한다. 예상치 못한 쿼리를 유발할 수 있어 사용을 지양해야 한다.
    *   **영속성 전이(Cascade)**: 특정 엔티티를 영속화할 때 연관된 엔티티도 함께 영속화하는 기능. (예: `CascadeType.ALL`)

## 4. 성능 최적화와 N+1 문제

*   **N+1 문제**: 1번의 쿼리로 N개의 결과를 얻은 후, N개의 결과 각각에 대해 연관된 데이터를 얻기 위해 N번의 추가 쿼리가 발생하는 현상.
*   **해결 방안**:
    *   **페치 조인(Fetch Join)**: JPQL에서 `JOIN FETCH` 키워드를 사용하여, 조회 시 연관된 엔티티의 데이터까지 함께 가져오는 방법. 가장 일반적인 해결책.
        *   `SELECT t FROM Team t JOIN FETCH t.members`
        *   컬렉션 페치 조인 시 데이터 뻥튀기(카테시안 곱)가 발생할 수 있어 `DISTINCT`를 함께 사용하기도 한다.
    *   **@EntityGraph**: Spring Data JPA에서 제공. `@Query` 없이도 함께 조회할 엔티티 그래프를 정의할 수 있다.
    *   **배치 사이즈(Batch Size)**: 지연 로딩으로 N+1이 발생하더라도, 연관된 엔티티 조회 시 `WHERE IN (...)` 절을 사용하여 지정된 사이즈만큼 묶어서 조회해준다. N번의 쿼리를 N/size 번의 쿼리로 줄여준다.

## 5. 실무 개발과 Spring Data JPA

*   **Spring Data JPA**: JPA를 더 쉽게 사용하기 위한 추상화 계층.
    *   **JpaRepository 인터페이스**: 상속받는 것만으로 `save`, `findById`, `findAll`, `delete` 등 공통 CRUD 메서드를 제공한다.
    *   **쿼리 메서드(Query Methods)**: `findByUsernameAndAgeGreaterThan(...)` 처럼 정해진 규칙에 따라 메서드 이름을 지으면 자동으로 JPQL을 생성해준다.
    *   **@Query 어노테이션**: Repository 메서드에 직접 JPQL을 작성하여 복잡한 쿼리를 처리할 수 있다.
*   **QueryDSL**: JPQL을 문자열이 아닌 자바 코드로 작성하게 하여, 컴파일 시점에 문법 오류를 잡을 수 있는 타입 안전(Type-Safe) 쿼리 빌더 라이브러리. 동적 쿼리 작성 시 매우 강력하다.
*   **DTO (Data Transfer Object)**: 엔티티를 API 응답으로 직접 노출하는 것은 위험하다. 항상 필요한 데이터만 담은 별도의 DTO 클래스로 변환하여 반환해야 한다. 이는 API 스펙을 보호하고, 엔티티의 내부 로직 노출을 막으며, 순환 참조 문제를 방지한다.

## 6. 고급 주제 및 설계

*   **동시성 제어**:
    *   **낙관적 락(Optimistic Lock)**: `@Version` 어노테이션을 사용하여 데이터 수정 시 버전 값을 비교한다. 충돌이 적을 때 유리.
    *   **비관적 락(Pessimistic Lock)**: `SELECT ... FOR UPDATE` 와 같이 데이터베이스의 배타적 락을 사용한다. 충돌이 빈번하거나 데이터 정합성이 매우 중요할 때 사용.
*   **OSIV(Open Session In View)**:
    *   **개념**: 영속성 컨텍스트를 뷰 렌더링 시점까지 열어두는 전략.
    *   **문제점**: 트랜잭션이 아닌 범위에서 지연 로딩이 동작하는 편리함이 있지만, DB 커넥션을 너무 오래 점유하여 실시간 트래픽 환경에서 장애의 원인이 될 수 있다.
    *   **권장 사항**: OSIV를 끄고, 트랜잭션 내에서 모든 데이터 조회 및 DTO 변환을 완료하는 것이 좋다.
*   **도메인 주도 설계(DDD) 관점**:
    *   **애그리거트(Aggregate)**: 비즈니스적으로 함께 관리되는 엔티티 묶음.
    *   **애그리거트 루트(Aggregate Root)**: 애그리거트의 대표 엔티티.
    *   **설계 원칙**: Repository는 애그리거트 루트에 대해서만 제공하고, 트랜잭션은 애그리거트 루트를 통해서만 시작되어야 데이터 일관성을 유지하기 용이하다.
