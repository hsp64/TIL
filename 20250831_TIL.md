# 25년 8월 31일


---



## React Router 

React Router는 React 애플리케이션에서 클라이언트 사이드 라우팅을 구현하기 위한 선언적 라우팅 라이브러리입니다. 전통적인 서버 사이드 라우팅과 달리, 페이지 전체를 새로고침하지 않고 URL의 변화에 따라 적절한 컴포넌트를 렌더링합니다.

### 설치
```bash
npm install react-router-dom
```

## 핵심 컴포넌트와 훅

### BrowserRouter
애플리케이션의 최상위에서 라우팅 컨텍스트를 제공하는 컴포넌트입니다. HTML5 History API를 사용하여 깨끗한 URL을 생성합니다.

```jsx
import { BrowserRouter } from 'react-router-dom';
import { createRoot } from 'react-dom/client';

const root = createRoot(document.getElementById('root'));
root.render(
  <BrowserRouter>
    <App />
  </BrowserRouter>
);
```

### HashRouter
BrowserRouter의 대안으로, URL에 해시(#)를 사용합니다. 서버 설정이 어려운 환경에서 사용됩니다.

```jsx
import { HashRouter } from 'react-router-dom';
// URL이 http://example.com/#/about 형태가 됩니다
```

### Routes와 Route
Routes는 Route 컴포넌트들을 그룹화하며, URL과 매치되는 첫 번째 Route만 렌더링합니다.

```jsx
import { Routes, Route } from 'react-router-dom';

function App() {
  return (
    <Routes>
      <Route path="/" element={<HomePage />} />
      <Route path="/about" element={<AboutPage />} />
      <Route path="/products" element={<ProductsPage />} />
      <Route path="/products/:id" element={<ProductDetailPage />} />
      <Route path="*" element={<NotFoundPage />} />
    </Routes>
  );
}
```

#### Route의 주요 props
- `path`: URL 경로 패턴
- `element`: 렌더링할 React 컴포넌트
- `index`: 부모 경로와 정확히 일치할 때 렌더링되는 기본 자식 라우트
- `caseSensitive`: 대소문자 구분 여부

### Link와 NavLink
페이지 간 네비게이션을 위한 컴포넌트들입니다.

```jsx
import { Link, NavLink } from 'react-router-dom';

// 기본 링크
function Navigation() {
  return (
    <nav>
      <Link to="/">홈</Link>
      <Link to="/about">소개</Link>
      <Link to="/products">제품</Link>
    </nav>
  );
}

// 활성 상태를 표시하는 링크
function ActiveNavigation() {
  return (
    <nav>
      <NavLink 
        to="/" 
        className={({ isActive }) => isActive ? 'active-link' : 'link'}
      >
        홈
      </NavLink>
      <NavLink 
        to="/about"
        style={({ isActive }) => ({
          color: isActive ? 'red' : 'blue'
        })}
      >
        소개
      </NavLink>
    </nav>
  );
}
```

## 프로그래밍 방식 네비게이션

### useNavigate
이벤트 핸들러나 특정 조건에서 프로그래밍 방식으로 페이지를 이동시킬 때 사용합니다.

```jsx
import { useNavigate } from 'react-router-dom';

function LoginForm() {
  const navigate = useNavigate();
  
  const handleSubmit = async (formData) => {
    try {
      await login(formData);
      navigate('/dashboard', { replace: true });
    } catch (error) {
      console.error('로그인 실패:', error);
    }
  };
  
  const goBack = () => {
    navigate(-1); // 이전 페이지로
  };
  
  const goForward = () => {
    navigate(1); // 다음 페이지로
  };
  
  return (
    <div>
      <form onSubmit={handleSubmit}>
        {/* 폼 내용 */}
      </form>
      <button onClick={goBack}>뒤로</button>
      <button onClick={goForward}>앞으로</button>
    </div>
  );
}
```

#### navigate 옵션
- `replace`: 현재 히스토리 항목을 대체 (뒤로 가기 불가)
- `state`: 다음 페이지로 전달할 상태 데이터

```jsx
navigate('/profile', { 
  replace: true, 
  state: { from: 'login' } 
});
```

## 동적 라우팅

### URL 파라미터 (useParams)
URL 경로의 동적 부분을 추출하여 사용합니다.

```jsx
import { useParams } from 'react-router-dom';

// 라우트 정의: /products/:categoryId/:productId
function ProductDetail() {
  const { categoryId, productId } = useParams();
  
  useEffect(() => {
    // API 호출 등
    fetchProduct(categoryId, productId);
  }, [categoryId, productId]);
  
  return (
    <div>
      <h1>카테고리: {categoryId}</h1>
      <h2>제품 ID: {productId}</h2>
    </div>
  );
}
```

### 쿼리 파라미터 (useSearchParams)
URL의 쿼리 스트링을 읽고 조작할 수 있습니다.

```jsx
import { useSearchParams } from 'react-router-dom';

function SearchResults() {
  const [searchParams, setSearchParams] = useSearchParams();
  
  const query = searchParams.get('q');
  const page = searchParams.get('page') || '1';
  const sort = searchParams.get('sort') || 'name';
  
  const updateSearch = (newQuery) => {
    setSearchParams({
      q: newQuery,
      page: '1', // 새 검색 시 첫 페이지로
      sort: sort
    });
  };
  
  const updatePage = (newPage) => {
    setSearchParams(prev => {
      prev.set('page', newPage);
      return prev;
    });
  };
  
  return (
    <div>
      <p>검색어: {query}</p>
      <p>페이지: {page}</p>
      <p>정렬: {sort}</p>
      
      <input 
        value={query || ''} 
        onChange={(e) => updateSearch(e.target.value)}
        placeholder="검색어 입력"
      />
    </div>
  );
}
```

## 중첩 라우팅 (Nested Routes)

중첩 라우팅을 통해 복잡한 레이아웃과 다단계 네비게이션을 구현할 수 있습니다.

```jsx
import { Routes, Route, Outlet, Link } from 'react-router-dom';

// 최상위 라우팅
function App() {
  return (
    <Routes>
      <Route path="/" element={<HomePage />} />
      <Route path="/products" element={<ProductsLayout />}>
        <Route index element={<ProductsList />} />
        <Route path="new" element={<NewProductForm />} />
        <Route path=":id" element={<ProductDetail />} />
        <Route path=":id/edit" element={<EditProductForm />} />
      </Route>
      <Route path="/users" element={<UsersLayout />}>
        <Route index element={<UsersList />} />
        <Route path=":id" element={<UserProfile />} />
        <Route path=":id/settings" element={<UserSettings />} />
      </Route>
    </Routes>
  );
}

// 제품 레이아웃 컴포넌트
function ProductsLayout() {
  return (
    <div className="products-layout">
      <header>
        <h1>제품 관리</h1>
        <nav>
          <Link to="/products">전체 목록</Link>
          <Link to="/products/new">새 제품 추가</Link>
        </nav>
      </header>
      
      <main>
        <Outlet /> {/* 자식 라우트가 렌더링되는 위치 */}
      </main>
    </div>
  );
}

// 사용자 레이아웃 컴포넌트
function UsersLayout() {
  const { id } = useParams();
  
  return (
    <div className="users-layout">
      <aside>
        <nav>
          <Link to="/users">사용자 목록</Link>
          {id && (
            <>
              <Link to={`/users/${id}`}>프로필</Link>
              <Link to={`/users/${id}/settings`}>설정</Link>
            </>
          )}
        </nav>
      </aside>
      
      <main>
        <Outlet />
      </main>
    </div>
  );
}
```

### index 라우트
부모 경로와 정확히 일치할 때 렌더링되는 기본 자식 라우트입니다.

```jsx
<Route path="/products" element={<ProductsLayout />}>
  <Route index element={<ProductsList />} /> {/* /products 경로 */}
  <Route path="new" element={<NewProduct />} /> {/* /products/new 경로 */}
</Route>
```

## 고급 라우팅 패턴

### 라우트 보호 (Protected Routes)
인증이 필요한 페이지를 보호하는 패턴입니다.

```jsx
import { Navigate, useLocation } from 'react-router-dom';

function ProtectedRoute({ children }) {
  const isAuthenticated = useAuth(); // 사용자 정의 훅
  const location = useLocation();
  
  if (!isAuthenticated) {
    // 로그인 후 원래 페이지로 돌아가기 위해 현재 위치 저장
    return <Navigate to="/login" state={{ from: location }} replace />;
  }
  
  return children;
}

// 사용법
<Route 
  path="/dashboard" 
  element={
    <ProtectedRoute>
      <Dashboard />
    </ProtectedRoute>
  } 
/>

// 로그인 후 리다이렉트
function LoginPage() {
  const navigate = useNavigate();
  const location = useLocation();
  
  const from = location.state?.from?.pathname || '/';
  
  const handleLogin = async (credentials) => {
    await login(credentials);
    navigate(from, { replace: true });
  };
  
  return (
    // 로그인 폼
  );
}
```

### 역할 기반 접근 제어
사용자의 역할에 따라 접근을 제한하는 패턴입니다.

```jsx
function RoleProtectedRoute({ children, allowedRoles }) {
  const user = useUser();
  
  if (!user) {
    return <Navigate to="/login" replace />;
  }
  
  if (allowedRoles && !allowedRoles.includes(user.role)) {
    return <Navigate to="/unauthorized" replace />;
  }
  
  return children;
}

// 사용법
<Route 
  path="/admin" 
  element={
    <RoleProtectedRoute allowedRoles={['admin']}>
      <AdminPanel />
    </RoleProtectedRoute>
  } 
/>
```

### 조건부 라우팅
특정 조건에 따라 다른 컴포넌트를 렌더링합니다.

```jsx
function ConditionalRoute() {
  const user = useUser();
  
  if (user?.isFirstTime) {
    return <Navigate to="/onboarding" replace />;
  }
  
  return <Dashboard />;
}
```

## 라우팅 관련 훅들

### useLocation
현재 위치 정보를 반환합니다.

```jsx
import { useLocation } from 'react-router-dom';

function Analytics() {
  const location = useLocation();
  
  useEffect(() => {
    // 페이지 뷰 트래킹
    trackPageView(location.pathname);
  }, [location]);
  
  return (
    <div>
      <p>현재 경로: {location.pathname}</p>
      <p>쿼리 스트링: {location.search}</p>
      <p>해시: {location.hash}</p>
      <p>전달된 상태: {JSON.stringify(location.state)}</p>
    </div>
  );
}
```

### useMatch
특정 경로 패턴과의 매치 정보를 반환합니다.

```jsx
import { useMatch } from 'react-router-dom';

function ProductNavigation() {
  const match = useMatch('/products/:id');
  
  return (
    <nav>
      <Link to="/products">목록</Link>
      {match && (
        <Link to={`/products/${match.params.id}/edit`}>
          편집
        </Link>
      )}
    </nav>
  );
}
```

### useRoutes
프로그래밍 방식으로 라우트를 정의할 수 있습니다.

```jsx
import { useRoutes } from 'react-router-dom';

function App() {
  const routes = useRoutes([
    { path: '/', element: <Home /> },
    { path: '/about', element: <About /> },
    {
      path: '/products',
      element: <ProductsLayout />,
      children: [
        { index: true, element: <ProductsList /> },
        { path: ':id', element: <ProductDetail /> }
      ]
    }
  ]);
  
  return routes;
}
```

## 에러 처리 및 로딩 상태

### ErrorBoundary와 함께 사용
```jsx
import { ErrorBoundary } from 'react-error-boundary';

function App() {
  return (
    <BrowserRouter>
      <ErrorBoundary fallback={<ErrorPage />}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="*" element={<NotFound />} />
        </Routes>
      </ErrorBoundary>
    </BrowserRouter>
  );
}
```

### 지연 로딩 (Lazy Loading)
```jsx
import { lazy, Suspense } from 'react';

const LazyComponent = lazy(() => import('./LazyComponent'));

function App() {
  return (
    <Routes>
      <Route 
        path="/lazy" 
        element={
          <Suspense fallback={<div>로딩 중...</div>}>
            <LazyComponent />
          </Suspense>
        } 
      />
    </Routes>
  );
}
```

## 실제 프로젝트 구조 예시

```
src/
├── components/
│   ├── Layout/
│   │   ├── Header.jsx
│   │   ├── Sidebar.jsx
│   │   └── Layout.jsx
│   └── ProtectedRoute.jsx
├── pages/
│   ├── Home/
│   │   └── HomePage.jsx
│   ├── Products/
│   │   ├── ProductsLayout.jsx
│   │   ├── ProductsList.jsx
│   │   ├── ProductDetail.jsx
│   │   └── ProductForm.jsx
│   └── NotFound.jsx
├── hooks/
│   ├── useAuth.js
│   └── useApi.js
└── App.jsx
```

## 성능 최적화

### Route 기반 코드 분할
```jsx
import { lazy, Suspense } from 'react';

const Home = lazy(() => import('./pages/Home'));
const Products = lazy(() => import('./pages/Products'));
const About = lazy(() => import('./pages/About'));

function App() {
  return (
    <BrowserRouter>
      <Suspense fallback={<div>페이지 로딩 중...</div>}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/products/*" element={<Products />} />
          <Route path="/about" element={<About />} />
        </Routes>
      </Suspense>
    </BrowserRouter>
  );
}
```

### 메모이제이션 활용
```jsx
import { memo } from 'react';

const Navigation = memo(function Navigation() {
  return (
    <nav>
      <NavLink to="/">홈</NavLink>
      <NavLink to="/products">제품</NavLink>
      <NavLink to="/about">소개</NavLink>
    </nav>
  );
});
```

## 테스팅

### React Router 컴포넌트 테스트
```jsx
import { render, screen } from '@testing-library/react';
import { BrowserRouter } from 'react-router-dom';
import { MemoryRouter } from 'react-router-dom';

// 실제 라우터 환경에서 테스트
function renderWithRouter(component) {
  return render(
    <BrowserRouter>
      {component}
    </BrowserRouter>
  );
}

// 특정 경로에서 테스트
function renderWithMemoryRouter(component, initialEntries = ['/']) {
  return render(
    <MemoryRouter initialEntries={initialEntries}>
      {component}
    </MemoryRouter>
  );
}

test('특정 경로에서 올바른 컴포넌트가 렌더링되는지 확인', () => {
  renderWithMemoryRouter(<App />, ['/products']);
  expect(screen.getByText('제품 목록')).toBeInTheDocument();
});
```

## 일반적인 실수와 해결방법

### 1. BrowserRouter를 여러 번 사용
잘못된 예:
```jsx
function App() {
  return (
    <BrowserRouter>
      <Header />
      <BrowserRouter> {/* 중복! */}
        <Routes>...</Routes>
      </BrowserRouter>
    </BrowserRouter>
  );
}
```

올바른 예:
```jsx
function App() {
  return (
    <BrowserRouter>
      <Header />
      <Routes>...</Routes>
    </BrowserRouter>
  );
}
```

### 2. Routes 없이 Route 사용
잘못된 예:
```jsx
<Route path="/" element={<Home />} /> {/* Routes로 감싸지 않음 */}
```

올바른 예:
```jsx
<Routes>
  <Route path="/" element={<Home />} />
</Routes>
```

### 3. 상대 경로와 절대 경로 혼용
일관된 경로 사용:
```jsx
// 절대 경로 사용 권장
<Route path="/products/:id" element={<ProductDetail />} />
<Link to="/products/123">제품 보기</Link>
```

## 마이그레이션 가이드 (v5 → v6)

주요 변경사항:
- Switch → Routes
- component/render prop → element prop
- useHistory → useNavigate
- useRouteMatch → useMatch

v5:
```jsx
<Switch>
  <Route path="/home" component={Home} />
  <Route path="/about" render={() => <About />} />
</Switch>
```

v6:
```jsx
<Routes>
  <Route path="/home" element={<Home />} />
  <Route path="/about" element={<About />} />
</Routes>
```

