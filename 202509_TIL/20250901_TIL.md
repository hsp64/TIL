# 25년 9월 1일


---

# React 데이터 핸들링

## 1. React 데이터 흐름의 핵심 개념

### 단방향 데이터 흐름 (Unidirectional Data Flow)

React에서 가장 중요한 원칙 중 하나는 데이터가 한 방향으로만 흐른다는 것입니다. 이는 애플리케이션의 예측 가능성과 디버깅을 용이하게 만듭니다.

**특징:**
- 데이터는 부모에서 자식으로만 전달됩니다 (props를 통해)
- 자식 컴포넌트는 부모의 state를 직접 수정할 수 없습니다
- 자식이 부모와 소통하려면 콜백 함수를 사용해야 합니다

**장점:**
- 버그 추적이 쉬움
- 데이터 흐름을 예측하기 쉬움
- 컴포넌트 간의 의존성이 명확함

```javascript
// 올바른 패턴
function Parent() {
  const [count, setCount] = useState(0);
  
  return (
    <Child 
      count={count} 
      onIncrement={() => setCount(count + 1)} 
    />
  );
}

function Child({ count, onIncrement }) {
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={onIncrement}>증가</button>
    </div>
  );
}
```

## 2. useState Hook 심화

### 상태 업데이트의 비동기성

useState의 setter 함수는 비동기적으로 작동합니다. 이는 상태 업데이트가 즉시 반영되지 않음을 의미합니다.

```javascript
function Counter() {
  const [count, setCount] = useState(0);
  
  const handleClick = () => {
    setCount(count + 1);
    console.log(count); // 여전히 이전 값을 출력
  };
  
  return <button onClick={handleClick}>Click</button>;
}
```

### 함수형 업데이트

이전 상태값을 기반으로 업데이트할 때는 함수형 업데이트를 사용하는 것이 안전합니다.

```javascript
function Counter() {
  const [count, setCount] = useState(0);
  
  const handleMultipleUpdates = () => {
    // 잘못된 방법 - 모든 업데이트가 같은 값을 기준으로 함
    setCount(count + 1);
    setCount(count + 1);
    setCount(count + 1); // 결과: +1만 증가
    
    // 올바른 방법
    setCount(prev => prev + 1);
    setCount(prev => prev + 1);
    setCount(prev => prev + 1); // 결과: +3 증가
  };
}
```

### 객체와 배열 상태 관리

React에서는 상태의 불변성을 지켜야 합니다. 기존 객체나 배열을 직접 수정하면 React가 변경사항을 감지하지 못합니다.

```javascript
function UserProfile() {
  const [user, setUser] = useState({
    name: '홍길동',
    age: 30,
    hobbies: ['독서', '영화감상']
  });
  
  // 올바른 객체 업데이트
  const updateName = (newName) => {
    setUser(prevUser => ({
      ...prevUser,
      name: newName
    }));
  };
  
  // 올바른 중첩 객체 업데이트
  const addHobby = (newHobby) => {
    setUser(prevUser => ({
      ...prevUser,
      hobbies: [...prevUser.hobbies, newHobby]
    }));
  };
  
  // 배열에서 항목 제거
  const removeHobby = (hobbyToRemove) => {
    setUser(prevUser => ({
      ...prevUser,
      hobbies: prevUser.hobbies.filter(hobby => hobby !== hobbyToRemove)
    }));
  };
}
```

### lazy 초기 상태

초기 상태를 계산하는데 비용이 많이 드는 경우, lazy 초기화를 사용할 수 있습니다.

```javascript
function ExpensiveComponent() {
  // 매 렌더링마다 실행됨 (비효율적)
  const [state, setState] = useState(expensiveCalculation());
  
  // 첫 렌더링에서만 실행됨 (효율적)
  const [state, setState] = useState(() => expensiveCalculation());
}
```

## 3. useEffect Hook 완전 정복

### 의존성 배열의 중요성

useEffect의 두 번째 인수인 의존성 배열은 언제 effect가 재실행될지를 결정합니다.

```javascript
function UserComponent({ userId }) {
  const [user, setUser] = useState(null);
  
  // 의존성 배열 없음 - 매 렌더링마다 실행
  useEffect(() => {
    fetchUser(userId).then(setUser);
  });
  
  // 빈 배열 - 마운트 시에만 실행
  useEffect(() => {
    fetchUser(userId).then(setUser);
  }, []);
  
  // userId 의존 - userId가 변경될 때마다 실행
  useEffect(() => {
    fetchUser(userId).then(setUser);
  }, [userId]);
}
```

### Cleanup 함수

컴포넌트가 언마운트되거나 의존성이 변경되기 전에 정리 작업을 수행할 수 있습니다.

```javascript
function Timer() {
  const [seconds, setSeconds] = useState(0);
  
  useEffect(() => {
    const interval = setInterval(() => {
      setSeconds(prev => prev + 1);
    }, 1000);
    
    // cleanup 함수
    return () => {
      clearInterval(interval);
    };
  }, []); // 빈 배열이므로 마운트 시에만 실행
  
  return <div>{seconds}초</div>;
}
```

### 조건부 Effect

특정 조건에서만 effect를 실행하고 싶을 때는 effect 내부에서 조건을 확인합니다.

```javascript
function ConditionalEffect({ shouldFetch, userId }) {
  const [data, setData] = useState(null);
  
  useEffect(() => {
    if (!shouldFetch) return;
    
    fetchData(userId).then(setData);
  }, [shouldFetch, userId]);
}
```

### Custom Hook으로 Effect 추상화

반복되는 effect 로직을 custom hook으로 추상화할 수 있습니다.

```javascript
function useWindowWidth() {
  const [width, setWidth] = useState(window.innerWidth);
  
  useEffect(() => {
    const handleResize = () => setWidth(window.innerWidth);
    
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);
  
  return width;
}

// 사용
function ResponsiveComponent() {
  const width = useWindowWidth();
  
  return <div>화면 너비: {width}px</div>;
}
```

## 4. Props 전달과 컴포넌트 통신

### Props의 다양한 전달 방법

```javascript
// 기본 props 전달
<Child name="홍길동" age={30} />

// 객체 전체 전달
const user = { name: '홍길동', age: 30 };
<Child user={user} />

// Spread 연산자 사용
<Child {...user} />

// children prop
<Parent>
  <Child />
</Parent>

function Parent({ children }) {
  return <div className="container">{children}</div>;
}
```

### PropTypes를 통한 타입 검증

```javascript
import PropTypes from 'prop-types';

function UserCard({ name, age, email, isActive }) {
  return (
    <div>
      <h2>{name}</h2>
      <p>나이: {age}</p>
      <p>이메일: {email}</p>
      {isActive && <span>활성 사용자</span>}
    </div>
  );
}

UserCard.propTypes = {
  name: PropTypes.string.isRequired,
  age: PropTypes.number.isRequired,
  email: PropTypes.string,
  isActive: PropTypes.bool
};

UserCard.defaultProps = {
  email: '이메일 없음',
  isActive: false
};
```

### 컴포넌트 합성 패턴

props drilling을 피하고 유연한 컴포넌트를 만드는 방법입니다.

```javascript
// 일반적인 패턴 (props drilling 발생)
function App() {
  const user = { name: '홍길동', role: 'admin' };
  return <Header user={user} />;
}

function Header({ user }) {
  return <UserMenu user={user} />;
}

function UserMenu({ user }) {
  return <div>{user.name} ({user.role})</div>;
}

// 합성 패턴 사용
function App() {
  const user = { name: '홍길동', role: 'admin' };
  return (
    <Header>
      <UserMenu user={user} />
    </Header>
  );
}

function Header({ children }) {
  return (
    <header>
      <Logo />
      <nav>{children}</nav>
    </header>
  );
}
```

## 5. Context API 상세 가이드

### Context 생성과 Provider 설정

```javascript
import { createContext, useContext, useState, useEffect } from 'react';

// 1. Context 생성
const ThemeContext = createContext();
const UserContext = createContext();

// 2. Provider 컴포넌트 생성
function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');
  
  const toggleTheme = () => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light');
  };
  
  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

// 3. 복합 Provider 패턴
function AppProviders({ children }) {
  return (
    <ThemeProvider>
      <UserProvider>
        {children}
      </UserProvider>
    </ThemeProvider>
  );
}
```

### Custom Hook을 통한 Context 사용

```javascript
// Context 사용을 위한 custom hook
function useTheme() {
  const context = useContext(ThemeContext);
  
  if (context === undefined) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  
  return context;
}

// 사용 예시
function ThemedButton() {
  const { theme, toggleTheme } = useTheme();
  
  return (
    <button 
      onClick={toggleTheme}
      style={{
        backgroundColor: theme === 'light' ? '#fff' : '#333',
        color: theme === 'light' ? '#333' : '#fff'
      }}
    >
      테마 변경 ({theme})
    </button>
  );
}
```

### Context 최적화

Context 값이 변경될 때 모든 구독자가 리렌더링되는 문제를 해결하는 방법입니다.

```javascript
// 문제가 있는 패턴
function BadProvider({ children }) {
  const [user, setUser] = useState(null);
  const [theme, setTheme] = useState('light');
  
  // 매번 새 객체가 생성되어 모든 구독자가 리렌더링됨
  const value = {
    user,
    setUser,
    theme,
    setTheme
  };
  
  return (
    <Context.Provider value={value}>
      {children}
    </Context.Provider>
  );
}

// 개선된 패턴
function GoodProvider({ children }) {
  const [user, setUser] = useState(null);
  const [theme, setTheme] = useState('light');
  
  // useMemo로 값 메모이제이션
  const value = useMemo(() => ({
    user,
    setUser,
    theme,
    setTheme
  }), [user, theme]);
  
  return (
    <Context.Provider value={value}>
      {children}
    </Context.Provider>
  );
}

// 또는 Context 분리
const UserContext = createContext();
const ThemeContext = createContext();

function SeparatedProviders({ children }) {
  const [user, setUser] = useState(null);
  const [theme, setTheme] = useState('light');
  
  return (
    <UserContext.Provider value={{ user, setUser }}>
      <ThemeContext.Provider value={{ theme, setTheme }}>
        {children}
      </ThemeContext.Provider>
    </UserContext.Provider>
  );
}
```

## 6. useReducer를 통한 복잡한 상태 관리

### Reducer 함수 작성 가이드라인

```javascript
// 1. Action 타입 상수 정의
const ACTIONS = {
  ADD_TODO: 'ADD_TODO',
  TOGGLE_TODO: 'TOGGLE_TODO',
  DELETE_TODO: 'DELETE_TODO',
  SET_FILTER: 'SET_FILTER',
  SET_LOADING: 'SET_LOADING',
  SET_ERROR: 'SET_ERROR'
};

// 2. 초기 상태 정의
const initialState = {
  todos: [],
  filter: 'all', // 'all', 'active', 'completed'
  loading: false,
  error: null
};

// 3. Reducer 함수 작성
function todoReducer(state, action) {
  switch (action.type) {
    case ACTIONS.ADD_TODO:
      return {
        ...state,
        todos: [...state.todos, {
          id: action.payload.id || Date.now(),
          text: action.payload.text,
          completed: false,
          createdAt: new Date().toISOString()
        }]
      };
      
    case ACTIONS.TOGGLE_TODO:
      return {
        ...state,
        todos: state.todos.map(todo =>
          todo.id === action.payload.id
            ? { ...todo, completed: !todo.completed }
            : todo
        )
      };
      
    case ACTIONS.DELETE_TODO:
      return {
        ...state,
        todos: state.todos.filter(todo => todo.id !== action.payload.id)
      };
      
    case ACTIONS.SET_FILTER:
      return {
        ...state,
        filter: action.payload.filter
      };
      
    case ACTIONS.SET_LOADING:
      return {
        ...state,
        loading: action.payload.loading
      };
      
    case ACTIONS.SET_ERROR:
      return {
        ...state,
        error: action.payload.error,
        loading: false
      };
      
    default:
      throw new Error(`Unknown action type: ${action.type}`);
  }
}
```

### useReducer 사용 패턴

```javascript
function TodoApp() {
  const [state, dispatch] = useReducer(todoReducer, initialState);
  
  // Action creators
  const addTodo = (text) => {
    if (!text.trim()) return;
    
    dispatch({
      type: ACTIONS.ADD_TODO,
      payload: { text: text.trim() }
    });
  };
  
  const toggleTodo = (id) => {
    dispatch({
      type: ACTIONS.TOGGLE_TODO,
      payload: { id }
    });
  };
  
  const deleteTodo = (id) => {
    dispatch({
      type: ACTIONS.DELETE_TODO,
      payload: { id }
    });
  };
  
  const setFilter = (filter) => {
    dispatch({
      type: ACTIONS.SET_FILTER,
      payload: { filter }
    });
  };
  
  // 필터링된 할 일 목록
  const filteredTodos = useMemo(() => {
    switch (state.filter) {
      case 'active':
        return state.todos.filter(todo => !todo.completed);
      case 'completed':
        return state.todos.filter(todo => todo.completed);
      default:
        return state.todos;
    }
  }, [state.todos, state.filter]);
  
  return (
    <div>
      <TodoForm onSubmit={addTodo} />
      <TodoFilters 
        currentFilter={state.filter} 
        onFilterChange={setFilter} 
      />
      <TodoList 
        todos={filteredTodos}
        onToggle={toggleTodo}
        onDelete={deleteTodo}
      />
      {state.loading && <div>로딩 중...</div>}
      {state.error && <div>에러: {state.error}</div>}
    </div>
  );
}
```

### useReducer vs useState 선택 가이드

**useReducer를 사용해야 하는 경우:**
- 복잡한 상태 로직이 있는 경우
- 다음 상태가 이전 상태에 의존적인 경우
- 많은 하위 컴포넌트가 상태를 업데이트해야 하는 경우
- 상태 전환을 예측 가능하게 만들고 싶은 경우

**useState를 사용해야 하는 경우:**
- 간단한 상태 (원시값, 단순 객체)
- 독립적인 상태 업데이트
- 컴포넌트 레벨의 로컬 상태

## 7. 데이터 Fetching 고급 패턴

### 에러 바운더리와 함께 사용

```javascript
// Error Boundary 컴포넌트
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }
  
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  
  componentDidCatch(error, errorInfo) {
    console.log('Error caught by boundary:', error, errorInfo);
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <div>
          <h2>오류가 발생했습니다</h2>
          <details>
            {this.state.error && this.state.error.toString()}
          </details>
        </div>
      );
    }
    
    return this.props.children;
  }
}

// 사용
function App() {
  return (
    <ErrorBoundary>
      <DataComponent />
    </ErrorBoundary>
  );
}
```

### 고급 데이터 fetching hook

```javascript
function useAsyncData(asyncFunction, dependencies = []) {
  const [state, setState] = useState({
    data: null,
    loading: true,
    error: null
  });
  
  useEffect(() => {
    let cancelled = false;
    
    const fetchData = async () => {
      try {
        setState(prev => ({ ...prev, loading: true, error: null }));
        
        const result = await asyncFunction();
        
        if (!cancelled) {
          setState({
            data: result,
            loading: false,
            error: null
          });
        }
      } catch (error) {
        if (!cancelled) {
          setState({
            data: null,
            loading: false,
            error: error.message
          });
        }
      }
    };
    
    fetchData();
    
    return () => {
      cancelled = true;
    };
  }, dependencies);
  
  const retry = () => {
    setState(prev => ({ ...prev, loading: true, error: null }));
  };
  
  return { ...state, retry };
}

// 사용 예시
function UserProfile({ userId }) {
  const { 
    data: user, 
    loading, 
    error, 
    retry 
  } = useAsyncData(() => fetchUser(userId), [userId]);
  
  if (loading) return <div>로딩 중...</div>;
  if (error) return (
    <div>
      <p>에러: {error}</p>
      <button onClick={retry}>다시 시도</button>
    </div>
  );
  
  return <div>{user.name}</div>;
}
```

### 캐싱과 함께 사용

```javascript
const cache = new Map();

function useCachedData(key, asyncFunction, dependencies = []) {
  const [state, setState] = useState({
    data: cache.get(key) || null,
    loading: !cache.has(key),
    error: null
  });
  
  useEffect(() => {
    if (cache.has(key)) {
      setState({
        data: cache.get(key),
        loading: false,
        error: null
      });
      return;
    }
    
    let cancelled = false;
    
    const fetchData = async () => {
      try {
        setState(prev => ({ ...prev, loading: true }));
        
        const result = await asyncFunction();
        
        if (!cancelled) {
          cache.set(key, result);
          setState({
            data: result,
            loading: false,
            error: null
          });
        }
      } catch (error) {
        if (!cancelled) {
          setState({
            data: null,
            loading: false,
            error: error.message
          });
        }
      }
    };
    
    fetchData();
    
    return () => {
      cancelled = true;
    };
  }, [key, ...dependencies]);
  
  return state;
}
```

## 8. 폼 처리 심화

### 복잡한 폼 검증

```javascript
function useForm(initialValues, validationRules) {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  const [touched, setTouched] = useState({});
  
  const validate = (fieldName, value) => {
    const rule = validationRules[fieldName];
    if (!rule) return null;
    
    if (rule.required && !value) {
      return `${fieldName}은(는) 필수 항목입니다.`;
    }
    
    if (rule.minLength && value.length < rule.minLength) {
      return `${fieldName}은(는) 최소 ${rule.minLength}자 이상이어야 합니다.`;
    }
    
    if (rule.pattern && !rule.pattern.test(value)) {
      return rule.message || `${fieldName} 형식이 올바르지 않습니다.`;
    }
    
    if (rule.custom && !rule.custom(value)) {
      return rule.message || `${fieldName}이(가) 유효하지 않습니다.`;
    }
    
    return null;
  };
  
  const handleChange = (name, value) => {
    setValues(prev => ({ ...prev, [name]: value }));
    
    // 실시간 검증
    const error = validate(name, value);
    setErrors(prev => ({ ...prev, [name]: error }));
  };
  
  const handleBlur = (name) => {
    setTouched(prev => ({ ...prev, [name]: true }));
  };
  
  const handleSubmit = (onSubmit) => (e) => {
    e.preventDefault();
    
    // 모든 필드 검증
    const newErrors = {};
    let hasErrors = false;
    
    Object.keys(validationRules).forEach(fieldName => {
      const error = validate(fieldName, values[fieldName]);
      if (error) {
        newErrors[fieldName] = error;
        hasErrors = true;
      }
    });
    
    setErrors(newErrors);
    setTouched(Object.keys(validationRules).reduce((acc, key) => {
      acc[key] = true;
      return acc;
    }, {}));
    
    if (!hasErrors) {
      onSubmit(values);
    }
  };
  
  const reset = () => {
    setValues(initialValues);
    setErrors({});
    setTouched({});
  };
  
  return {
    values,
    errors,
    touched,
    handleChange,
    handleBlur,
    handleSubmit,
    reset
  };
}

// 사용 예시
function RegistrationForm() {
  const { 
    values, 
    errors, 
    touched, 
    handleChange, 
    handleBlur, 
    handleSubmit 
  } = useForm(
    {
      username: '',
      email: '',
      password: '',
      confirmPassword: ''
    },
    {
      username: {
        required: true,
        minLength: 3
      },
      email: {
        required: true,
        pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
        message: '유효한 이메일 주소를 입력해주세요.'
      },
      password: {
        required: true,
        minLength: 8
      },
      confirmPassword: {
        required: true,
        custom: (value) => value === values.password,
        message: '비밀번호가 일치하지 않습니다.'
      }
    }
  );
  
  const onSubmit = (formData) => {
    console.log('폼 제출:', formData);
    // API 호출 등
  };
  
  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <div>
        <input
          type="text"
          placeholder="사용자명"
          value={values.username}
          onChange={(e) => handleChange('username', e.target.value)}
          onBlur={() => handleBlur('username')}
        />
        {touched.username && errors.username && (
          <span className="error">{errors.username}</span>
        )}
      </div>
      
      <div>
        <input
          type="email"
          placeholder="이메일"
          value={values.email}
          onChange={(e) => handleChange('email', e.target.value)}
          onBlur={() => handleBlur('email')}
        />
        {touched.email && errors.email && (
          <span className="error">{errors.email}</span>
        )}
      </div>
      
      <div>
        <input
          type="password"
          placeholder="비밀번호"
          value={values.password}
          onChange={(e) => handleChange('password', e.target.value)}
          onBlur={() => handleBlur('password')}
        />
        {touched.password && errors.password && (
          <span className="error">{errors.password}</span>
        )}
      </div>
      
      <div>
        <input
          type="password"
          placeholder="비밀번호 확인"
          value={values.confirmPassword}
          onChange={(e) => handleChange('confirmPassword', e.target.value)}
          onBlur={() => handleBlur('confirmPassword')}
        />
        {touched.confirmPassword && errors.confirmPassword && (
          <span className="error">{errors.confirmPassword}</span>
        )}
      </div>
      
      <button type="submit">가입하기</button>
    </form>
  );
}
```

## 주요 원칙과 베스트 프랙티스

### 1. 불변성 유지
- 상태를 직접 변경하지 말고 항상 새로운 객체/배열을 생성
- Immer 라이브러리를 사용하면 불변성을 더 쉽게 관리할 수 있음

### 2. 관심사의 분리
- 비즈니스 로직과 UI 로직을 분리
- Custom Hook을 활용하여 재사용 가능한 로직 생성

### 3. 성능 최적화
- 불필요한 리렌더링을 방지하기 위해 React.memo, useMemo, useCallback 적절히 사용
- Context 값이 자주 변경되지 않도록 주의

### 4. 에러 처리
- 데이터 fetching 시 항상 에러 케이스 고려
- Error Boundary를 활용하여 예상치 못한 에러 처리

### 5. 타입 안정성
- PropTypes나 TypeScript를 사용하여 타입 검증
- 런타임 에러를 최소화

이러한 기본기를 탄탄히 다진 후에 Redux, Zustand, React Query 같은 고급 상태 관리 라이브러리를 학습하면 더욱 효과적입니다.
