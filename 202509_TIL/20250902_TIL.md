# 25년 9월 2일


---


# Spring Boot + React 무한 스크롤 

## 1. application.yml 설정 파일 구현 원리

### 데이터베이스 설정이 작동하는 방식
```yaml
spring:
  datasource:
    url: jdbc:h2:mem:testdb
    driver-class-name: org.h2.Driver
```

Spring Boot의 자동 설정 메커니즘이 이 설정을 읽어서 DataSource 빈을 자동으로 생성합니다. `jdbc:h2:mem:`은 H2 데이터베이스를 메모리에 생성하라는 명령어이고, `testdb`는 데이터베이스 이름입니다. 애플리케이션이 시작될 때 메모리에 데이터베이스가 생성되고, 종료되면 모든 데이터가 사라집니다.

### JPA 설정의 내부 동작
```yaml
jpa:
  hibernate:
    ddl-auto: create-drop
  show-sql: true
```

`ddl-auto: create-drop`은 Hibernate에게 애플리케이션 시작 시 엔티티 클래스를 기반으로 테이블을 생성하고, 종료 시 테이블을 삭제하라고 지시합니다. `show-sql: true`는 Hibernate가 실행하는 모든 SQL 쿼리를 콘솔에 출력하도록 설정하여 개발 중 디버깅을 도와줍니다.

### 서버 설정의 실제 효과
```yaml
server:
  servlet:
    context-path: /api
```

이 설정은 Spring Boot의 내장 톰캣 서버가 모든 요청 경로 앞에 `/api` 접두사를 추가하도록 합니다. 따라서 컨트롤러에서 `@RequestMapping("/posts")`로 정의한 경로는 실제로 `http://localhost:8080/api/posts`가 됩니다.

## 2. Entity 클래스 구현 세부사항

### JPA 어노테이션의 실제 동작
```java
@Entity
@Table(name = "posts")
public class Post {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
}
```

`@Entity` 어노테이션이 붙은 클래스는 JPA가 스캔하여 엔티티로 등록합니다. `@Table(name = "posts")`는 실제 데이터베이스에 생성될 테이블 이름을 지정합니다. `@GeneratedValue(strategy = GenerationType.IDENTITY)`는 데이터베이스의 AUTO_INCREMENT 기능을 사용하여 id 값을 자동으로 생성하도록 설정합니다.

### 컬럼 매핑과 제약조건
```java
@Column(nullable = false, length = 200)
private String title;

@Column(nullable = false, columnDefinition = "TEXT")
private String content;
```

`@Column` 어노테이션은 필드와 데이터베이스 컬럼 간의 매핑을 정의합니다. `nullable = false`는 NOT NULL 제약조건을 생성하고, `length = 200`은 VARCHAR(200)으로 컬럼을 생성합니다. `columnDefinition = "TEXT"`는 긴 텍스트를 저장하기 위해 TEXT 타입으로 컬럼을 생성합니다.

### 시간 필드 자동 관리
```java
@CreationTimestamp
private LocalDateTime createdAt;

@UpdateTimestamp
private LocalDateTime updatedAt;
```

`@CreationTimestamp`는 엔티티가 처음 저장될 때 현재 시간을 자동으로 설정합니다. `@UpdateTimestamp`는 엔티티가 수정될 때마다 현재 시간으로 갱신됩니다. 이는 Hibernate의 기능으로, 개발자가 수동으로 시간을 설정할 필요가 없습니다.

### 컬렉션 매핑의 동작 원리
```java
@ElementCollection(fetch = FetchType.LAZY)
@CollectionTable(name = "post_tags")
@Column(name = "tag")
private Set<String> tags = new HashSet<>();
```

`@ElementCollection`은 기본 타입이나 임베디드 타입의 컬렉션을 매핑할 때 사용합니다. `@CollectionTable`은 별도의 테이블 `post_tags`를 생성하고, 이 테이블에는 `post_id`(외래키)와 `tag`(값) 컬럼이 생성됩니다. `FetchType.LAZY`는 태그 데이터를 실제로 사용할 때까지 로드를 지연시켜 성능을 향상시킵니다.

## 3. Repository 인터페이스 구현 원리

### JpaRepository 상속의 이점
```java
public interface PostRepository extends JpaRepository<Post, Long> {
```

`JpaRepository<Post, Long>`에서 `Post`는 엔티티 타입, `Long`은 기본키 타입입니다. 이 인터페이스를 상속하면 Spring Data JPA가 런타임에 프록시 객체를 생성하여 기본적인 CRUD 메소드들을 자동으로 구현해줍니다. `findAll()`, `save()`, `delete()` 등의 메소드를 직접 구현할 필요가 없습니다.

### 커스텀 쿼리 메소드의 동작
```java
@Query("""
    SELECT p FROM Post p 
    WHERE (:search IS NULL OR :search = '' OR 
           LOWER(p.title) LIKE LOWER(CONCAT('%', :search, '%')))
    """)
Page<Post> findBySearchKeyword(@Param("search") String search, Pageable pageable);
```

`@Query` 어노테이션은 JPQL(Java Persistence Query Language)로 작성된 쿼리를 실행합니다. `:search`는 메소드 파라미터와 바인딩되는 명명된 파라미터입니다. `LOWER()` 함수는 대소문자를 구분하지 않는 검색을 위해 사용되고, `CONCAT('%', :search, '%')`는 부분 문자열 검색을 위한 LIKE 패턴을 생성합니다.

### Pageable 파라미터의 자동 처리
메소드 파라미터에 `Pageable`이 있으면 Spring Data JPA가 자동으로 페이지네이션 관련 SQL을 생성합니다. 예를 들어 MySQL에서는 `LIMIT`과 `OFFSET` 절이 자동으로 추가되고, 전체 개수를 구하는 COUNT 쿼리도 별도로 실행됩니다.

## 4. Service 클래스 구현 세부사항

### 트랜잭션 관리 전략
```java
@Service
@Transactional(readOnly = true)
public class PostService {
    
    @Transactional
    public PostDto createPost(CreatePostRequest request) {
```

클래스 레벨의 `@Transactional(readOnly = true)`는 모든 메소드가 기본적으로 읽기 전용 트랜잭션을 사용하도록 설정합니다. 읽기 전용 트랜잭션은 더티 체킹(변경 감지)을 수행하지 않아 성능상 이점이 있습니다. 쓰기 작업이 필요한 메소드에만 별도로 `@Transactional`을 붙여 쓰기 가능한 트랜잭션을 사용합니다.

### 페이지 크기 검증 로직
```java
private int validatePageSize(Integer size) {
    if (size == null || size < 1) {
        return defaultPageSize;
    }
    return Math.min(size, maxPageSize);
}
```

사용자가 잘못된 페이지 크기를 요청할 경우를 대비한 방어 코드입니다. null이나 음수가 들어오면 기본값을 사용하고, 너무 큰 값이 들어오면 최대값으로 제한합니다. 이는 서버 리소스를 보호하고 일관된 응답을 보장합니다.

### DTO 변환의 필요성과 구현
```java
private PostDto convertToDto(Post post) {
    return PostDto.builder()
        .id(post.getId())
        .title(post.getTitle())
        // 필요한 필드만 선택적으로 복사
        .build();
}
```

Entity를 직접 반환하지 않고 DTO로 변환하는 이유는 여러 가지입니다. 첫째, 순환 참조를 방지합니다. 둘째, API 스펙과 내부 데이터 모델을 분리하여 변경에 유연하게 대응할 수 있습니다. 셋째, 민감한 정보를 노출하지 않을 수 있습니다.

## 5. Controller 클래스 구현 원리

### HTTP 요청 매핑의 동작
```java
@RestController
@RequestMapping("/posts")
public class PostController {
    
    @GetMapping
    public ResponseEntity<PageResponse<PostDto>> getPosts(@Valid PostSearchRequest request) {
```

`@RestController`는 `@Controller`와 `@ResponseBody`를 합친 것으로, 메소드의 반환값이 자동으로 JSON으로 직렬화됩니다. `@RequestMapping("/posts")`는 클래스 레벨에서 공통 경로를 정의하고, `@GetMapping`은 HTTP GET 요청을 해당 메소드와 매핑합니다.

### 요청 파라미터 자동 바인딩
```java
public ResponseEntity<PageResponse<PostDto>> getPosts(@Valid PostSearchRequest request) {
```

Spring MVC는 HTTP 요청 파라미터를 자동으로 객체의 필드에 바인딩합니다. 예를 들어 `?page=2&size=10&search=spring` 요청이 오면, `PostSearchRequest` 객체의 해당 필드에 자동으로 값이 설정됩니다. `@Valid` 어노테이션은 객체의 검증 어노테이션들을 자동으로 실행합니다.

### ResponseEntity 사용 이유
```java
return ResponseEntity.ok()
    .headers(headers)
    .body(response);
```

`ResponseEntity`를 사용하면 HTTP 상태 코드, 헤더, 본문을 모두 제어할 수 있습니다. 무한 스크롤에서는 메타 정보를 헤더에 포함시켜 프론트엔드가 추가 정보를 활용할 수 있도록 합니다.

## 6. React 프론트엔드 구현 세부사항

### useInfiniteScroll 훅의 설계 원리
```javascript
const useInfiniteScroll = (baseUrl, options = {}) => {
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(false);
  const [hasMore, setHasMore] = useState(true);
  const [page, setPage] = useState(1);
```

커스텀 훅을 만든 이유는 무한 스크롤 로직을 재사용 가능하도록 추상화하기 위함입니다. 상태 관리, API 호출, 스크롤 감지 로직을 하나의 훅으로 캡슐화하여 여러 컴포넌트에서 사용할 수 있습니다.

### Intersection Observer API 활용
```javascript
const lastElementRef = useCallback(node => {
  if (loading) return;
  
  if (observer.current) observer.current.disconnect();
  
  observer.current = new IntersectionObserver(entries => {
    if (entries[0].isIntersecting && hasMore && !loading) {
      setPage(prevPage => prevPage + 1);
    }
  }, {
    threshold: 0.1,
    rootMargin: '100px',
  });
  
  if (node) observer.current.observe(node);
}, [loading, hasMore]);
```

Intersection Observer는 특정 요소가 뷰포트에 들어오거나 나갈 때를 감지하는 웹 API입니다. `threshold: 0.1`은 요소의 10%가 보일 때 콜백을 실행하라는 의미이고, `rootMargin: '100px'`는 실제 뷰포트보다 100px 더 넓은 영역에서 감지하여 미리 로딩하도록 합니다.

이전 observer를 `disconnect()`로 해제하는 이유는 메모리 누수를 방지하기 위함입니다. 새로운 마지막 요소가 렌더링될 때마다 이전 요소의 관찰을 중단하고 새 요소를 관찰합니다.

### 중복 데이터 방지 로직
```javascript
setData(prevData => {
  const existingIds = new Set(prevData.map(item => item.id));
  const uniqueNewData = newData.filter(item => !existingIds.has(item.id));
  return [...prevData, ...uniqueNewData];
});
```

네트워크 지연이나 사용자의 빠른 스크롤로 인해 같은 데이터가 중복으로 로드될 수 있습니다. 기존 데이터의 ID를 Set으로 만들어 O(1) 시간복잡도로 중복을 체크하고, 새로운 데이터만 기존 배열에 추가합니다.

### 요청 취소 메커니즘
```javascript
const abortController = useRef();

const fetchData = useCallback(async (pageNum, isNewSearch = false) => {
  if (abortController.current) {
    abortController.current.abort();
  }
  
  abortController.current = new AbortController();
  
  const response = await axios.get(baseUrl, {
    signal: abortController.current.signal,
    timeout: 10000,
  });
});
```

AbortController를 사용하여 이전 요청을 취소합니다. 사용자가 빠르게 검색어를 변경하거나 스크롤할 때 불필요한 네트워크 요청을 방지하고, 순서가 뒤바뀐 응답으로 인한 데이터 불일치를 방지합니다.

## 7. 데이터 흐름과 상태 관리

### 검색 조건 변경 시 리셋 로직
```javascript
useEffect(() => {
  setData([]);
  setPage(1);
  setHasMore(true);
  fetchData(1, true);
}, [search, sortBy, sortDirection, tag, author, fetchData]);
```

검색 조건이 변경되면 기존 데이터를 모두 초기화하고 첫 번째 페이지부터 다시 로드합니다. `isNewSearch = true` 플래그를 통해 기존 데이터에 추가하는 것이 아니라 완전히 교체하도록 합니다.

### 페이지 증가 시 데이터 추가 로직
```javascript
useEffect(() => {
  if (page > 1) {
    fetchData(page);
  }
}, [page, fetchData]);
```

페이지가 1보다 클 때만 추가 데이터를 로드합니다. 첫 번째 페이지는 검색 조건 변경 useEffect에서 처리되므로 중복 호출을 방지합니다.

## 8. 에러 처리와 사용자 경험

### API 에러 처리 전략
```java
@GetMapping
public ResponseEntity<PageResponse<PostDto>> getPosts(@Valid PostSearchRequest request) {
    try {
        PageResponse<PostDto> response = postService.getPosts(request);
        return ResponseEntity.ok().body(response);
    } catch (Exception e) {
        log.error("포스트 조회 중 오류 발생", e);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
    }
}
```

예외가 발생하면 로그를 남기고 적절한 HTTP 상태 코드를 반환합니다. 500 Internal Server Error는 클라이언트에게 서버에서 문제가 발생했음을 알리지만, 구체적인 에러 내용은 보안상 노출하지 않습니다.

### 프론트엔드 에러 상태 관리
```javascript
} catch (err) {
  if (err.name !== 'CanceledError') {
    setError(err.response?.data?.message || err.message || '데이터를 불러오는데 실패했습니다.');
  }
}
```

취소된 요청(`CanceledError`)은 정상적인 동작이므로 에러로 처리하지 않습니다. 실제 에러는 서버 응답의 에러 메시지를 우선 사용하고, 없으면 기본 메시지를 표시합니다.

## 9. 성능 최적화 구현

### 지연 로딩과 프리페칭
```javascript
const lastElementRef = useCallback(node => {
  // ...
  observer.current = new IntersectionObserver(entries => {
    if (entries[0].isIntersecting && hasMore && !loading) {
      setPage(prevPage => prevPage + 1);
    }
  }, {
    rootMargin: '100px', // 100px 전에 미리 로드
  });
}, [loading, hasMore]);
```

`rootMargin: '100px'`는 사용자가 페이지 끝에 도달하기 100px 전에 미리 다음 페이지를 로드하도록 합니다. 이는 사용자가 스크롤하는 동안 로딩 시간을 느끼지 않도록 하는 성능 최적화 기법입니다.

### 메모리 누수 방지
```javascript
useEffect(() => {
  return () => {
    if (abortController.current) {
      abortController.current.abort();
    }
    if (observer.current) {
      observer.current.disconnect();
    }
  };
}, []);
```

컴포넌트가 언마운트될 때 진행 중인 HTTP 요청을 취소하고 Intersection Observer를 정리합니다. 이는 메모리 누수와 예상치 못한 상태 업데이트를 방지합니다.

## 10. 전체 시스템의 동작 흐름

### 초기 로딩 과정
1. React 컴포넌트가 마운트되면 `useInfiniteScroll` 훅이 실행됩니다
2. 첫 번째 `useEffect`가 `fetchData(1, true)`를 호출합니다
3. axios가 `/api/posts?page=1&size=20` GET 요청을 보냅니다
4. Spring Boot Controller가 요청을 받아 Service로 전달합니다
5. Service가 Repository의 메소드를 호출합니다
6. Repository가 JPA를 통해 데이터베이스에 쿼리를 실행합니다
7. 결과가 역순으로 전달되어 React 상태에 저장됩니다

### 무한 스크롤 트리거 과정
1. 사용자가 스크롤하여 마지막 요소가 뷰포트에 들어옵니다
2. Intersection Observer 콜백이 실행됩니다
3. `setPage(prevPage => prevPage + 1)`로 페이지 번호가 증가합니다
4. 페이지 증가 useEffect가 감지하여 `fetchData(newPage)`를 호출합니다
5. 새로운 데이터가 기존 배열에 추가됩니다
6. 새로운 마지막 요소에 observer가 다시 연결됩니다

### 검색 시 동작 과정
1. 사용자가 검색어를 입력합니다
2. 검색 조건 변경 useEffect가 실행됩니다
3. 기존 데이터가 초기화되고 페이지가 1로 리셋됩니다
4. `fetchData(1, true)`로 새로운 검색 결과를 로드합니다
5. 검색어가 포함된 쿼리 파라미터가 백엔드로 전송됩니다
6. 백엔드에서 LIKE 검색을 수행하여 필터링된 결과를 반환합니다

이러한 구현을 통해 사용자는 끊김 없는 스크롤 경험을 하면서도 서버 리소스는 효율적으로 사용되는 시스템이 완성됩니다.
