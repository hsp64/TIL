# 25년 9월 9일


---

# React Context 심화

## 주제
React Context API 심화 학습

## 개념 정리

### Context란 무엇인가
React Context는 컴포넌트 트리에서 데이터를 전역적으로 공유할 수 있게 해주는 기능입니다. props drilling 문제를 해결하기 위해 도입된 개념으로, 중간 컴포넌트들을 거치지 않고도 깊숙한 곳에 있는 컴포넌트에 직접 데이터를 전달할 수 있습니다.

### Props Drilling 문제
기존에는 상위 컴포넌트에서 하위 컴포넌트로 데이터를 전달하려면 중간에 있는 모든 컴포넌트를 거쳐야 했습니다. 예를 들어, App > Header > Navigation > UserProfile 구조에서 사용자 정보를 UserProfile에 전달하려면 Header와 Navigation 컴포넌트도 해당 props를 받아서 전달해야 했습니다. 이는 코드의 복잡성을 증가시키고 유지보수를 어렵게 만들었습니다.

### Context의 핵심 구성 요소

#### createContext
Context 객체를 생성하는 함수입니다. 기본값을 인자로 받을 수 있으며, 이 기본값은 적절한 Provider를 찾지 못했을 때 사용됩니다.

```javascript
const ThemeContext = createContext('light');
const UserContext = createContext(null);
```

#### Provider
Context의 값을 제공하는 컴포넌트입니다. value prop을 통해 하위 컴포넌트들에게 전달할 데이터를 설정합니다. Provider 하위에 있는 모든 컴포넌트는 이 값에 접근할 수 있습니다.

```javascript
<ThemeContext.Provider value="dark">
  <App />
</ThemeContext.Provider>
```

#### Consumer와 useContext Hook
Context의 값을 소비하는 방법입니다. Consumer는 render props 패턴을 사용하는 컴포넌트이고, useContext는 함수형 컴포넌트에서 더 간편하게 Context 값을 가져올 수 있는 Hook입니다.

## 실제 구현 방법

### 기본적인 Context 생성과 사용
먼저 Context를 생성하고 Provider로 값을 제공한 후, 하위 컴포넌트에서 useContext Hook을 사용하여 값을 가져옵니다.

```javascript
// context/ThemeContext.js
import { createContext, useContext, useState } from 'react';

const ThemeContext = createContext();

export const ThemeProvider = ({ children }) => {
  const [theme, setTheme] = useState('light');
  
  const toggleTheme = () => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light');
  };
  
  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};

export const useTheme = () => {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  return context;
};
```

### 복잡한 상태 관리를 위한 useReducer와의 조합
단순한 상태가 아닌 복잡한 상태 로직을 관리할 때는 useReducer와 함께 사용하면 효과적입니다.

```javascript
// context/AppContext.js
import { createContext, useContext, useReducer } from 'react';

const AppContext = createContext();

const initialState = {
  user: null,
  isLoading: false,
  error: null,
  notifications: []
};

const appReducer = (state, action) => {
  switch (action.type) {
    case 'SET_LOADING':
      return { ...state, isLoading: action.payload };
    case 'SET_USER':
      return { ...state, user: action.payload, isLoading: false };
    case 'SET_ERROR':
      return { ...state, error: action.payload, isLoading: false };
    case 'ADD_NOTIFICATION':
      return { 
        ...state, 
        notifications: [...state.notifications, action.payload] 
      };
    default:
      return state;
  }
};

export const AppProvider = ({ children }) => {
  const [state, dispatch] = useReducer(appReducer, initialState);
  
  return (
    <AppContext.Provider value={{ state, dispatch }}>
      {children}
    </AppContext.Provider>
  );
};
```

## 고급 패턴과 최적화

### Context 분리 패턴
모든 상태를 하나의 Context에 넣으면 불필요한 리렌더링이 발생할 수 있습니다. 관련된 상태끼리 그룹화하여 여러 Context로 분리하는 것이 좋습니다.

```javascript
// 사용자 정보만 담당하는 Context
const UserContext = createContext();

// UI 상태만 담당하는 Context  
const UIContext = createContext();

// 테마만 담당하는 Context
const ThemeContext = createContext();
```

### 성능 최적화를 위한 메모이제이션
Context 값이 자주 변경되면 모든 소비자 컴포넌트가 리렌더링됩니다. useMemo를 사용하여 Context 값을 메모이제이션하면 불필요한 리렌더링을 방지할 수 있습니다.

```javascript
const AppProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [theme, setTheme] = useState('light');
  
  const contextValue = useMemo(() => ({
    user,
    setUser,
    theme,
    setTheme
  }), [user, theme]);
  
  return (
    <AppContext.Provider value={contextValue}>
      {children}
    </AppContext.Provider>
  );
};
```

### Custom Hook을 통한 추상화
Context를 직접 사용하는 대신 Custom Hook을 만들어 사용하면 더 안전하고 편리합니다. 또한 Context가 올바르게 사용되고 있는지 검증할 수 있습니다.

```javascript
export const useAuth = () => {
  const context = useContext(AuthContext);
  
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  
  return context;
};
```

## 실제 사용 사례

### 전역 테마 관리
애플리케이션의 다크모드/라이트모드를 전역적으로 관리할 때 Context를 활용합니다. 사용자가 테마를 변경하면 모든 컴포넌트에 즉시 반영됩니다.

### 사용자 인증 상태 관리
로그인된 사용자 정보를 전역적으로 관리하여 어느 컴포넌트에서든 현재 로그인 상태를 확인할 수 있습니다. 로그인, 로그아웃 기능도 Context를 통해 제공할 수 있습니다.

### 다국어 지원
현재 선택된 언어와 번역 함수를 Context로 제공하여 애플리케이션 전체에서 일관된 다국어 지원을 구현할 수 있습니다.

### 장바구니 상태 관리
전자상거래 애플리케이션에서 장바구니에 담긴 상품들을 전역적으로 관리할 때 Context를 사용합니다. 상품 추가, 제거, 수량 변경 등의 기능을 어느 페이지에서든 수행할 수 있습니다.

## Context 사용시 주의사항

### 과도한 사용 지양
Context는 강력한 도구이지만 모든 상황에 적합하지는 않습니다. 단순히 2-3단계 깊이의 props 전달이라면 props drilling이 더 명시적이고 이해하기 쉬울 수 있습니다. Context는 정말로 여러 컴포넌트에서 공유해야 하는 전역적인 데이터에만 사용해야 합니다.

### 리렌더링 성능 고려
Context 값이 변경되면 해당 Context를 구독하는 모든 컴포넌트가 리렌더링됩니다. 이는 성능에 영향을 줄 수 있으므로 Context 구조를 신중히 설계해야 합니다. 자주 변경되는 값과 그렇지 않은 값을 분리하는 것이 좋습니다.

### 테스트 복잡성
Context를 사용하는 컴포넌트를 테스트할 때는 적절한 Provider로 감싸주어야 합니다. 이는 테스트 코드를 더 복잡하게 만들 수 있으므로 테스트 전용 Provider를 만들어 사용하는 것이 도움됩니다.

## 대안 고려사항

### 상태 관리 라이브러리와의 비교
Redux, Zustand, Jotai 같은 전용 상태 관리 라이브러리들도 전역 상태 관리를 제공합니다. 애플리케이션의 복잡도와 요구사항에 따라 적절한 도구를 선택해야 합니다. Context는 React에 내장된 기능이라는 장점이 있지만, 복잡한 상태 로직이나 미들웨어가 필요한 경우에는 전용 라이브러리가 더 적합할 수 있습니다.

### 컴포넌트 합성 패턴
때로는 Context 대신 컴포넌트 합성 패턴을 사용하는 것이 더 나은 해결책일 수 있습니다. children prop이나 render props를 활용하여 컴포넌트 간의 결합도를 낮추면서도 데이터를 효과적으로 전달할 수 있습니다.

## 오늘의 핵심 포인트

React Context는 전역 상태 관리를 위한 강력한 도구이지만 적절한 상황에서 올바르게 사용해야 합니다. 단순한 props drilling 해결부터 복잡한 애플리케이션 상태 관리까지 다양한 용도로 활용할 수 있으며, 성능과 유지보수성을 고려한 설계가 중요합니다. Custom Hook과 메모이제이션을 통해 더 효율적이고 안전한 Context 사용이 가능합니다.
