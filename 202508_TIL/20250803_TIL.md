# 25년 8월 3일


---


# sql기본: select, where, function, group by,having, order by, join


# TIL.md: SQL 핵심 문법 깊이 이해하기

## 1. SELECT: 데이터베이스에 보내는 질문의 시작

### `SELECT`란 무엇인가?

`SELECT`는 SQL(Structured Query Language)의 가장 기본적이면서도 핵심적인 명령어입니다. 데이터베이스 테이블에서 어떤 데이터를 가져올지 지정하는 역할을 합니다. 우리가 데이터베이스에게 "이런 데이터를 보여줘"라고 요청하는 것과 같습니다.

### 왜 `SELECT`를 사용하는가?

데이터베이스에는 수많은 데이터가 저장되어 있습니다. 이 중에서 우리가 필요로 하는 정보만을 정확히 추출하기 위해 `SELECT`를 사용합니다. 예를 들어, 전체 고객 목록이 아닌 '서울에 사는 고객'의 이름과 연락처만 보고 싶을 때 `SELECT`를 통해 원하는 데이터 열(column)을 지정할 수 있습니다.

### 어떻게 사용하는가?

`SELECT` 절 다음에는 가져오고 싶은 열의 이름을 쉼표(`,`)로 구분하여 나열합니다.

#### 모든 열 선택 (`*`)

테이블의 모든 열 데이터를 가져오고 싶을 때는 애스터리스크(`*`)를 사용합니다.

```sql
-- employees 테이블의 모든 정보를 선택
SELECT * FROM employees;
```

#### 특정 열 선택

원하는 열만 지정하여 선택할 수 있습니다. 이는 불필요한 데이터 전송을 줄여 성능 향상에 도움이 됩니다.

```sql
-- employees 테이블에서 직원의 이름(first_name)과 이메일(email)만 선택
SELECT first_name, email FROM employees;
```

#### 별칭(Alias) 사용 (`AS`)

열의 이름을 그대로 사용하기보다, 더 알아보기 쉬운 이름으로 임시 변경하고 싶을 때 `AS`를 사용합니다. (AS는 생략 가능)

```sql
-- first_name을 '이름', salary를 '급여'라는 별칭으로 선택
SELECT first_name AS 이름, salary AS 급여 FROM employees;
SELECT first_name 이름, salary 급여 FROM employees; -- AS 생략 가능
```

## 2. WHERE: 원하는 데이터만 골라내기

### `WHERE`란 무엇인가?

`WHERE` 절은 `SELECT` 문으로 가져올 데이터에 **조건**을 부여하여, 특정 조건을 만족하는 행(row)들만 필터링하는 역할을 합니다.

### 왜 `WHERE`를 사용하는가?

전체 데이터가 아닌, 특정 기준을 충족하는 데이터만을 분석하고 싶을 때 반드시 필요합니다. 예를 들어, '급여가 5000 이상인 직원', '입사일이 2020년 이후인 직원', '마케팅 부서에 속한 직원' 등 구체적인 조건을 적용해 데이터의 범위를 좁힐 수 있습니다.

### 어떻게 사용하는가?

`FROM` 절 다음에 `WHERE`를 쓰고, 그 뒤에 필터링할 조건을 명시합니다.

#### 비교 연산자

`=`, `>`, `<`, `>=`, `<=`, `!=` (또는 `<>`) 등의 연산자를 사용해 값을 비교합니다.

```sql
-- department_id가 90인 부서에 속한 직원들을 선택
SELECT * FROM employees WHERE department_id = 90;

-- salary가 10000 이상인 직원들의 이름과 급여를 선택
SELECT first_name, salary FROM employees WHERE salary >= 10000;
```

#### 논리 연산자 (`AND`, `OR`, `NOT`)

두 개 이상의 조건을 결합할 때 사용합니다.

```sql
-- department_id가 60이면서(AND) job_id가 'IT_PROG'인 직원을 선택
SELECT * FROM employees WHERE department_id = 60 AND job_id = 'IT_PROG';

-- department_id가 60이거나(OR) 90인 직원을 선택
SELECT * FROM employees WHERE department_id = 60 OR department_id = 90;
```

#### 특정 범위 및 목록 (`BETWEEN`, `IN`)

-   `BETWEEN a AND b`: `a`와 `b` 사이의 값 (양쪽 경계 포함)
-   `IN (a, b, c, ...)`: 목록에 포함된 값

```sql
-- salary가 5000과 7000 사이인 직원을 선택
SELECT first_name, salary FROM employees WHERE salary BETWEEN 5000 AND 7000;

-- job_id가 'IT_PROG', 'SA_REP', 'MK_MAN' 중 하나인 직원을 선택
SELECT first_name, job_id FROM employees WHERE job_id IN ('IT_PROG', 'SA_REP', 'MK_MAN');
```

#### 패턴 검색 (`LIKE`)

문자열 데이터에서 특정 패턴을 검색할 때 사용합니다.
-   `%`: 0개 이상의 모든 문자열
-   `_`: 정확히 1개의 문자

```sql
-- 이름(first_name)이 'S'로 시작하는 직원을 선택
SELECT first_name FROM employees WHERE first_name LIKE 'S%';

-- 이름에 'am'이 포함된 직원을 선택
SELECT first_name FROM employees WHERE first_name LIKE '%am%';
```

## 3. 집계 함수 (Aggregate Functions): 데이터 요약하기

### 집계 함수란 무엇인가?

집계 함수는 여러 행의 데이터를 하나의 요약된 값으로 계산해주는 함수입니다. `SELECT` 절이나 `HAVING` 절에서 주로 사용됩니다.

### 왜 집계 함수를 사용하는가?

개별 데이터 하나하나가 아닌, 데이터 그룹의 **통계적 특성**을 파악하기 위해 사용됩니다. '총 직원 수', '부서별 평균 급여', '최고 연봉' 등과 같은 정보를 계산하는 데 필수적입니다.

### 어떻게 사용하는가?

| 함수      | 설명                         | 예시                                 |
| :-------- | :--------------------------- | :----------------------------------- |
| `COUNT()` | 행의 개수를 센다.              | `COUNT(*)`: 전체 행 수                |
|           |                              | `COUNT(column)`: 해당 열이 NULL이 아닌 행 수 |
| `SUM()`   | 숫자 데이터의 합계를 구한다.     | `SUM(salary)`: 급여 총합             |
| `AVG()`   | 숫자 데이터의 평균을 구한다.     | `AVG(salary)`: 평균 급여             |
| `MAX()`   | 데이터 중 최댓값을 찾는다.     | `MAX(salary)`: 최고 급여             |
| `MIN()`   | 데이터 중 최솟값을 찾는다.     | `MIN(hire_date)`: 가장 빠른 입사일   |

```sql
-- 전체 직원 수, 급여 총합, 평균 급여를 계산
SELECT COUNT(*) AS total_employees, SUM(salary) AS total_salary, AVG(salary) AS avg_salary
FROM employees;
```

## 4. GROUP BY: 데이터를 그룹으로 묶기

### `GROUP BY`란 무엇인가?

`GROUP BY` 절은 특정 열의 값이 같은 행들을 하나의 그룹으로 묶어주는 역할을 합니다. 이렇게 묶인 그룹에 대해 집계 함수를 적용하여 그룹별 통계를 낼 수 있습니다.

### 왜 `GROUP BY`를 사용하는가?

전체 데이터에 대한 통계가 아닌, **특정 기준에 따른 소그룹별 통계**를 보고 싶을 때 사용합니다. 예를 들어, '각 부서별 직원 수', '직무별 평균 급여' 등 특정 카테고리별로 데이터를 요약 분석하는 데 최적화되어 있습니다.

### 어떻게 사용하는가?

`GROUP BY` 절 뒤에 그룹화할 기준이 되는 열의 이름을 명시합니다. `SELECT` 절에는 `GROUP BY`에서 사용한 열과 집계 함수만 올 수 있습니다.

```sql
-- 각 부서(department_id)별 직원 수를 계산
SELECT department_id, COUNT(*) AS num_of_employees
FROM employees
GROUP BY department_id;

-- 각 직무(job_id)별 평균 급여를 계산
SELECT job_id, AVG(salary) AS avg_salary
FROM employees
GROUP BY job_id;
```

## 5. HAVING: 그룹에 대한 조건 설정

### `HAVING`이란 무엇인가?

`HAVING` 절은 `GROUP BY`를 통해 생성된 그룹에 대한 조건을 지정하는 역할을 합니다. 즉, **그룹화된 결과**를 필터링할 때 사용합니다.

### 왜 `HAVING`을 사용하는가? (`WHERE`와의 차이점)

-   `WHERE`는 **개별 행**을 그룹화하기 전에 필터링합니다.
-   `HAVING`은 그룹화가 완료된 후, **집계 함수 결과**를 바탕으로 그룹 자체를 필터링합니다.

예를 들어 '평균 급여가 8000 이상인 부서'를 찾고 싶다면, 먼저 부서별로 평균 급여를 계산한 뒤(그룹화 및 집계), 그 결과값이 8000 이상인 그룹만 남겨야 합니다. 이럴 때 `HAVING`이 사용됩니다.

### 어떻게 사용하는가?

`GROUP BY` 절 다음에 `HAVING`을 쓰고, 그룹에 대한 조건을 명시합니다. 조건에는 반드시 집계 함수가 포함됩니다.

```sql
-- 부서별 평균 급여를 계산하되, 평균 급여가 8000 이상인 부서만 선택
SELECT department_id, AVG(salary)
FROM employees
GROUP BY department_id
HAVING AVG(salary) >= 8000;

-- 직원이 10명 이상인 부서의 ID와 직원 수를 선택
SELECT department_id, COUNT(*)
FROM employees
GROUP BY department_id
HAVING COUNT(*) >= 10;
```

## 6. ORDER BY: 결과 정렬하기

### `ORDER BY`란 무엇인가?

`ORDER BY` 절은 `SELECT` 문의 최종 결과를 특정 열의 값을 기준으로 정렬하는 역할을 합니다.

### 왜 `ORDER BY`를 사용하는가?

데이터를 특정 순서(예: 이름 가나다순, 급여 높은 순, 최신 날짜순)로 나열하여 가독성을 높이고 분석을 용이하게 하기 위해 사용합니다.

### 어떻게 사용하는가?

`ORDER BY` 절은 SQL 문의 가장 마지막에 위치하며, 정렬 기준이 될 열 이름을 명시합니다.
-   `ASC` (Ascending): 오름차순 (기본값, 생략 가능)
-   `DESC` (Descending): 내림차순

```sql
-- 직원들을 급여(salary)가 높은 순서(내림차순)로 정렬하여 선택
SELECT first_name, salary
FROM employees
ORDER BY salary DESC;

-- 부서 ID(오름차순)로 먼저 정렬하고, 같은 부서 내에서는 급여(내림차순) 순으로 정렬
SELECT department_id, first_name, salary
FROM employees
ORDER BY department_id ASC, salary DESC;```

## 7. JOIN: 여러 테이블 연결하기

### `JOIN`이란 무엇인가?

`JOIN`은 두 개 이상의 테이블을 **공통된 열(foreign key-primary key 관계)**을 기준으로 연결하여 하나의 결과 집합처럼 다룰 수 있게 해주는 기능입니다. 데이터가 정규화를 통해 여러 테이블에 나뉘어 저장되어 있을 때, 이를 합쳐서 의미 있는 정보를 만들기 위해 필수적입니다.

### 왜 `JOIN`을 사용하는가?

데이터의 중복을 피하고 일관성을 유지하기 위해 데이터는 여러 테이블로 나뉘어 관리됩니다(정규화). 예를 들어 `employees` 테이블에는 직원의 개인 정보가, `departments` 테이블에는 부서 정보가 있습니다. '각 직원이 속한 부서의 이름'을 알고 싶다면, 두 테이블을 연결해야만 합니다. `JOIN`은 이 연결을 수행하는 다리 역할을 합니다.

### 어떻게 사용하는가? (주요 JOIN 종류)

#### 1. INNER JOIN (내부 조인)

가장 흔하게 사용되는 조인 방식입니다. 두 테이블에 **모두** 공통된 값이 존재하는 행들만 연결하여 반환합니다.

```sql
-- 직원(employees)과 부서(departments) 테이블을 연결하여
-- 각 직원의 이름과 그 직원이 속한 부서의 이름을 선택
SELECT e.first_name, d.department_name
FROM employees e
INNER JOIN departments d ON e.department_id = d.department_id;
-- ON 절에는 두 테이블을 연결할 공통 열을 지정합니다.
-- 테이블 이름에 별칭(e, d)을 부여하면 쿼리를 간결하게 작성할 수 있습니다.
```

#### 2. LEFT OUTER JOIN (왼쪽 외부 조인)

`INNER JOIN`의 결과에 더해, **왼쪽 테이블(FROM 절에 먼저 오는 테이블)의 모든 행**을 포함하여 반환합니다. 오른쪽 테이블에 매칭되는 값이 없으면 해당 열은 `NULL`로 표시됩니다.

**사용 이유**: 부서에 배정되지 않은 직원을 포함하여 모든 직원의 목록을 보고 싶을 때 사용합니다.

```sql
-- 모든 직원의 이름과, 소속이 있다면 그 부서 이름을 선택 (소속 없으면 NULL)
SELECT e.first_name, d.department_name
FROM employees e
LEFT JOIN departments d ON e.department_id = d.department_id;
```

#### 3. RIGHT OUTER JOIN (오른쪽 외부 조인)

`LEFT JOIN`과 반대로, **오른쪽 테이블(JOIN 절에 오는 테이블)의 모든 행**을 포함하여 반환합니다. 왼쪽 테이블에 매칭되는 값이 없으면 해당 열은 `NULL`로 표시됩니다.

**사용 이유**: 직원이 한 명도 없는 부서를 포함하여 모든 부서의 목록을 보고 싶을 때 사용합니다.

```sql
-- 모든 부서의 이름과, 해당 부서에 속한 직원의 이름을 선택 (직원이 없으면 NULL)
SELECT e.first_name, d.department_name
FROM employees e
RIGHT JOIN departments d ON e.department_id = d.department_id;
```

#### 4. FULL OUTER JOIN (완전 외부 조인)

양쪽 테이블의 모든 행을 포함하여 반환합니다. 한쪽에만 데이터가 있는 경우, 다른 쪽의 열은 `NULL`로 채워집니다. `LEFT JOIN`과 `RIGHT JOIN`의 결과를 합친 것과 같습니다.

**사용 이유**: 부서에 배정되지 않은 직원과, 직원이 없는 부서를 모두 포함한 전체 목록을 보고 싶을 때 사용합니다.

```sql
-- 부서 없는 직원, 직원 없는 부서 모두 포함하여 목록 선택
SELECT e.first_name, d.department_name
FROM employees e
FULL OUTER JOIN departments d ON e.department_id = d.department_id;
```

---

### SQL 쿼리 실행 순서 (논리적 순서)

우리가 코드를 작성하는 순서와 데이터베이스가 쿼리를 처리하는 논리적 순서는 다릅니다. 이를 이해하면 더 복잡한 쿼리를 작성할 때 도움이 됩니다.

1.  **`FROM` / `JOIN`**: 어떤 테이블에서 데이터를 가져올지 결정하고 연결합니다.
2.  **`WHERE`**: 개별 행을 필터링합니다.
3.  **`GROUP BY`**: 행들을 그룹으로 묶습니다.
4.  **`HAVING`**: 그룹을 필터링합니다.
5.  **`SELECT`**: 최종적으로 어떤 열을 출력할지 결정합니다. (이때 별칭이 적용됩니다)
6.  **`ORDER BY`**: 결과를 정렬합니다.
7.  **`LIMIT` / `TOP`**: 출력할 행의 수를 제한합니다. (해당하는 경우)
