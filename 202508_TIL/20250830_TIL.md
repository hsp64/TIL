# 25년 8월 30일

---


# Spring Framework 

## 1. 의존성 주입과 IoC 컨테이너

### 왜 DI가 필요한가

**DI 없는 전통적인 코드의 문제점:**
```java
// 강한 결합, 테스트 어려움, 환경별 설정 불가
public class OrderService {
    private PaymentService paymentService = new PaymentService(); // 문제
    private EmailService emailService = new EmailService();
    
    public void createOrder(Order order) {
        paymentService.processPayment(order.getPayment());
        emailService.sendOrderConfirmation(order);
    }
}
```

**DI 적용 후:**
```java
@Service
public class OrderService {
    private final PaymentService paymentService;
    private final EmailService emailService;
    
    // 생성자 주입 - 가장 권장하는 방식
    public OrderService(PaymentService paymentService, EmailService emailService) {
        this.paymentService = paymentService;
        this.emailService = emailService;
    }
}

// 환경별 다른 구현체 사용 가능
@Service
@Profile("dev")
public class MockPaymentService implements PaymentService {
    // 개발환경용 가짜 결제 서비스
}

@Service
@Profile("prod")
public class RealPaymentService implements PaymentService {
    // 운영환경용 실제 결제 서비스
}
```

### IoC 컨테이너의 실제 동작 과정

**1단계: 컴포넌트 스캔**
1. `@ComponentScan`이 지정된 패키지를 재귀적으로 스캔
2. `@Component`, `@Service`, `@Repository`, `@Controller` 찾기
3. ASM 라이브러리로 바이트코드 분석하여 메타데이터 추출
4. BeanDefinition 객체 생성

**2단계: 빈 생성과 의존성 주입**
```java
// 스프링 내부 동작 과정 (단순화)
public Object createBean(String beanName, BeanDefinition bd) {
    // 1. 인스턴스 생성
    Object instance = instantiate(bd.getBeanClass());
    
    // 2. 의존성 주입
    autowireByType(instance);
    
    // 3. 초기화 콜백
    invokeInitMethods(instance);
    
    return instance;
}
```

### 순환 참조 해결 메커니즘

**3단계 캐시 시스템:**
```java
Map<String, Object> singletonObjects = new HashMap<>();          // 완성된 빈
Map<String, Object> earlySingletonObjects = new HashMap<>();     // 조기 노출 빈
Map<String, ObjectFactory<?>> singletonFactories = new HashMap<>(); // 빈 팩토리
```

**해결 과정:**
1. A 객체 생성 시작 → singletonFactories에 등록
2. A의 필드 주입 시 B 필요 → B 생성 시작
3. B의 필드 주입 시 A 필요 → singletonFactories에서 A의 미완성 객체 반환
4. B 완성 후 singletonObjects에 저장
5. A 완성 후 singletonObjects에 저장

**주의: 생성자 주입에서는 순환 참조 불가**
```java
@Service
public class A {
    private final B b;
    public A(B b) { this.b = b; } // BeanCurrentlyInCreationException 발생
}
```

### 빈 생명주기 완전 분석

**전체 생명주기 과정:**
```java
@Component
public class LifecycleBean implements BeanNameAware, BeanFactoryAware, 
        ApplicationContextAware, InitializingBean, DisposableBean {
    
    // 1. 생성자 호출
    public LifecycleBean() {
        System.out.println("1. Constructor called");
    }
    
    // 2. 프로퍼티 설정 (필드 주입)
    @Autowired
    private SomeService someService;
    
    // 3. BeanNameAware
    @Override
    public void setBeanName(String name) {
        System.out.println("3. setBeanName: " + name);
    }
    
    // 4. BeanFactoryAware
    @Override
    public void setBeanFactory(BeanFactory beanFactory) {
        System.out.println("4. setBeanFactory");
    }
    
    // 5. ApplicationContextAware
    @Override
    public void setApplicationContext(ApplicationContext context) {
        System.out.println("5. setApplicationContext");
    }
    
    // 6. @PostConstruct
    @PostConstruct
    public void postConstruct() {
        System.out.println("6. @PostConstruct");
    }
    
    // 7. InitializingBean.afterPropertiesSet
    @Override
    public void afterPropertiesSet() {
        System.out.println("7. afterPropertiesSet");
    }
    
    // 소멸 시점
    @PreDestroy
    public void preDestroy() {
        System.out.println("@PreDestroy");
    }
    
    @Override
    public void destroy() {
        System.out.println("DisposableBean.destroy");
    }
}
```

---

## 2. AOP - 관점 지향 프로그래밍

### AOP가 해결하는 실제 문제

**AOP 없이 로깅과 트랜잭션을 직접 구현:**
```java
public class OrderService {
    private Logger logger = LoggerFactory.getLogger(OrderService.class);
    private PlatformTransactionManager txManager;
    
    public void createOrder(Order order) {
        // 로깅 코드 (중복 1)
        logger.info("메소드 시작: createOrder, 파라미터: {}", order);
        long startTime = System.currentTimeMillis();
        
        // 트랜잭션 코드 (중복 2)
        TransactionDefinition def = new DefaultTransactionDefinition();
        TransactionStatus status = txManager.getTransaction(def);
        
        try {
            // 실제 비즈니스 로직 (핵심!)
            validateOrder(order);
            orderRepository.save(order);
            paymentService.processPayment(order);
            
            // 트랜잭션 커밋
            txManager.commit(status);
        } catch (Exception e) {
            // 트랜잭션 롤백
            txManager.rollback(status);
            logger.error("주문 생성 실패", e);
            throw e;
        } finally {
            // 성능 측정 (중복 3)
            long endTime = System.currentTimeMillis();
            logger.info("메소드 종료: createOrder, 실행시간: {}ms", endTime - startTime);
        }
    }
    
    // 모든 메소드에 똑같은 패턴 반복...
}
```

**AOP로 깔끔하게 분리:**
```java
@Service
public class OrderService {
    
    @Transactional
    @LogExecutionTime
    public void createOrder(Order order) {
        // 순수한 비즈니스 로직만!
        validateOrder(order);
        orderRepository.save(order);
        paymentService.processPayment(order);
    }
}

@Aspect
@Component
public class LoggingAspect {
    
    @Around("@annotation(LogExecutionTime)")
    public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {
        long startTime = System.currentTimeMillis();
        
        Object result = joinPoint.proceed();
        
        long executionTime = System.currentTimeMillis() - startTime;
        logger.info("{} executed in {} ms", joinPoint.getSignature(), executionTime);
        
        return result;
    }
}
```

### 프록시 생성 메커니즘

**JDK Dynamic Proxy vs CGLIB:**
```java
// 인터페이스가 있는 경우 - JDK Dynamic Proxy 사용
public interface OrderService {
    void createOrder(Order order);
}

@Service
public class OrderServiceImpl implements OrderService {
    @Override
    @Transactional
    public void createOrder(Order order) {
        // 구현
    }
}

// 인터페이스가 없는 경우 - CGLIB 사용
@Service
public class OrderService { // 인터페이스 없음
    @Transactional
    public void createOrder(Order order) {
        // 구현
    }
}
```

**프록시 동작 원리:**
```java
// JDK Dynamic Proxy 생성 과정 (내부적으로)
public class JdkDynamicProxy implements InvocationHandler {
    private final Object target;
    private final List<Advisor> advisors;
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        List<Object> interceptors = getInterceptors(method);
        
        if (interceptors.isEmpty()) {
            return method.invoke(target, args);
        } else {
            return new ReflectiveMethodInvocation(target, method, args, interceptors).proceed();
        }
    }
}
```

### Self-Invocation 문제 완벽 해결

**문제 상황:**
```java
@Service
public class OrderService {
    
    @Transactional
    public void createOrder(Order order) {
        orderRepository.save(order);
        this.sendNotification(order); // 프록시를 거치지 않음!
    }
    
    @Async
    public void sendNotification(Order order) {
        // @Async가 동작하지 않음
        emailService.sendEmail(order);
    }
}
```

**해결책들:**

**1. @Lazy self-injection (가장 실용적):**
```java
@Service
public class OrderService {
    
    @Lazy
    @Autowired
    private OrderService self; // 자기 자신을 주입 (프록시)
    
    @Transactional
    public void createOrder(Order order) {
        orderRepository.save(order);
        self.sendNotification(order); // 프록시를 통한 호출
    }
    
    @Async
    public void sendNotification(Order order) {
        emailService.sendEmail(order);
    }
}
```

**2. @Lookup 메소드 사용:**
```java
@Service
public abstract class OrderService {
    
    @Transactional
    public void createOrder(Order order) {
        orderRepository.save(order);
        getSelf().sendNotification(order);
    }
    
    @Lookup
    public abstract OrderService getSelf(); // 스프링이 구현체 제공
    
    @Async
    public void sendNotification(Order order) {
        emailService.sendEmail(order);
    }
}
```

### 트랜잭션 AOP의 내부 동작

**@Transactional이 하는 일:**
```java
// 스프링이 실제로 생성하는 프록시 코드 (개념적)
public class OrderService$$TransactionalProxy extends OrderService {
    
    private PlatformTransactionManager transactionManager;
    
    @Override
    public void createOrder(Order order) {
        TransactionDefinition def = new DefaultTransactionDefinition();
        TransactionStatus status = transactionManager.getTransaction(def);
        
        try {
            super.createOrder(order); // 실제 메소드 실행
            transactionManager.commit(status);
        } catch (RuntimeException | Error e) {
            transactionManager.rollback(status); // RuntimeException만 롤백
            throw e;
        } catch (Exception e) {
            transactionManager.commit(status); // Checked Exception은 커밋
            throw e;
        }
    }
}
```

**트랜잭션 전파 속성:**
- **REQUIRED**: 기존 트랜잭션 참여, 없으면 새로 생성
- **REQUIRES_NEW**: 기존 트랜잭션 일시중단, 새 트랜잭션 생성
- **NESTED**: 세이브포인트 생성 (지원하는 DB에 한함)

---

## 3. Spring Boot 자동 설정

### 자동 설정이 없다면

**스프링 부트 없이 웹 애플리케이션 설정:**
```java
@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {
    
    @Bean
    public DataSource dataSource() {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl("jdbc:mysql://localhost:3306/mydb");
        config.setUsername("user");
        config.setPassword("password");
        // 수십 줄의 설정...
        return new HikariDataSource(config);
    }
    
    @Bean
    public LocalContainerEntityManagerFactoryBean entityManagerFactory() {
        // 복잡한 JPA 설정...
    }
    
    @Bean
    public PlatformTransactionManager transactionManager() {
        // 트랜잭션 매니저 설정...
    }
    
    // 수십 개의 추가 설정들...
}
```

**스프링 부트를 사용하면:**
```java
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

```yaml
# application.yml - 설정은 이것만!
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/mydb
    username: user
    password: password
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
```

### @EnableAutoConfiguration의 실제 동작

**자동 설정 과정:**
1. `AutoConfigurationImportSelector`가 `spring.factories` 파일 읽기
2. 각 자동 설정 클래스의 `@Conditional` 조건 평가
3. 조건을 만족하는 설정 클래스만 로딩
4. `@Order` 애노테이션에 따라 설정 순서 결정

**조건부 빈 생성 예시:**
```java
@Configuration
@ConditionalOnClass(DataSource.class) // DataSource 클래스가 클래스패스에 있을 때만
@ConditionalOnMissingBean(DataSource.class) // DataSource 빈이 없을 때만
@EnableConfigurationProperties(DataSourceProperties.class)
public class DataSourceAutoConfiguration {
    
    @Bean
    @ConfigurationProperties("spring.datasource.hikari")
    DataSource dataSource(DataSourceProperties properties) {
        return properties.initializeDataSourceBuilder()
            .type(HikariDataSource.class)
            .build();
    }
}
```

### 자동 설정 디버깅

**디버그 모드 활성화:**
```yaml
debug: true
# 또는
logging:
  level:
    org.springframework.boot.autoconfigure: DEBUG
```

**출력 결과:**
```
Positive matches: (적용된 자동 설정들)
DataSourceAutoConfiguration matched:
   - @ConditionalOnClass found required class 'javax.sql.DataSource'

Negative matches: (적용되지 않은 자동 설정들)
RedisAutoConfiguration:
   Did not match:
      - @ConditionalOnClass did not find required class 'redis.clients.jedis.Jedis'
```

---

## 4. JPA/Hibernate 통합

### 영속성 컨텍스트가 없다면

**JDBC로 개발할 때의 문제:**
```java
public class OrderService {
    
    public void updateOrder(Long orderId) {
        // 1. 주문 조회
        String sql1 = "SELECT * FROM orders WHERE id = ?";
        Order order = jdbcTemplate.queryForObject(sql1, Order.class, orderId);
        
        // 2. 상태 변경 후 반드시 UPDATE 쿼리 실행
        order.setStatus("CONFIRMED");
        String sql2 = "UPDATE orders SET status = ? WHERE id = ?";
        jdbcTemplate.update(sql2, order.getStatus(), orderId);
        
        // 3. N+1 문제 발생
        String sql3 = "SELECT * FROM order_items WHERE order_id = ?";
        List<OrderItem> items = jdbcTemplate.query(sql3, OrderItem.class, orderId);
        
        for (OrderItem item : items) {
            String sql4 = "SELECT * FROM products WHERE id = ?"; // N번 실행
            Product product = jdbcTemplate.queryForObject(sql4, Product.class, item.getProductId());
        }
    }
}
```

### 영속성 컨텍스트의 4가지 핵심 기능

**1. 1차 캐시 - 같은 엔티티 중복 조회 방지:**
```java
@Test
public void 일차캐시_테스트() {
    Order order1 = orderRepository.findById(1L).get(); // SELECT 쿼리 실행
    Order order2 = orderRepository.findById(1L).get(); // SELECT 쿼리 실행 안됨!
    
    assertThat(order1 == order2).isTrue(); // 같은 객체 인스턴스
}
```

**2. 쓰기 지연 - SQL 쿼리 배치 처리:**
```java
@Transactional
public void 대량_주문_생성() {
    for (int i = 0; i < 1000; i++) {
        Order order = new Order();
        orderRepository.save(order); // 아직 INSERT 쿼리 실행 안됨!
    }
    // 트랜잭션 커밋 시점에 1000개 INSERT 쿼리가 한번에 실행됨
}
```

**3. 변경 감지 - 자동 UPDATE:**
```java
@Transactional
public void 주문_상태_변경(Long orderId) {
    Order order = orderRepository.findById(orderId).get();
    
    order.setStatus(OrderStatus.SHIPPED); // 엔티티 수정
    // save() 호출하지 않아도 자동으로 UPDATE!
}
```

**4. 지연 로딩 - 필요할 때만 데이터 조회:**
```java
@Entity
public class Order {
    @OneToMany(mappedBy = "order", fetch = FetchType.LAZY)
    private List<OrderItem> orderItems = new ArrayList<>();
    
    @ManyToOne(fetch = FetchType.LAZY)
    private Customer customer;
}

@Transactional
public void 지연로딩_예제() {
    Order order = orderRepository.findById(1L).get(); // Order만 조회
    
    List<OrderItem> items = order.getOrderItems(); // 실제 사용 시점에 쿼리 실행
    String customerName = order.getCustomer().getName(); // 별도 쿼리 실행
}
```

### N+1 문제 해결책들

**문제 상황:**
```java
public List<OrderDto> getAllOrdersWithCustomer() {
    List<Order> orders = orderRepository.findAll(); // 1번의 쿼리
    
    List<OrderDto> result = new ArrayList<>();
    for (Order order : orders) { // 100개 주문이 있다면
        String customerName = order.getCustomer().getName(); // 100번의 SELECT 쿼리
        result.add(new OrderDto(order.getId(), customerName));
    }
    return result; // 총 101번의 쿼리 실행!
}
```

**해결책 1: Fetch Join:**
```java
@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {
    
    @Query("SELECT o FROM Order o JOIN FETCH o.customer")
    List<Order> findAllWithCustomer(); // 단 1번의 쿼리로 모든 데이터 조회
}
```

**해결책 2: @EntityGraph:**
```java
@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {
    
    @EntityGraph(attributePaths = {"customer", "orderItems"})
    List<Order> findAllByStatus(OrderStatus status);
}
```

**해결책 3: @BatchSize:**
```java
@Entity
public class Order {
    
    @ManyToOne(fetch = FetchType.LAZY)
    @BatchSize(size = 50) // 50개씩 한번에 조회
    private Customer customer;
}
```

### LazyInitializationException 해결

**문제 상황:**
```java
@Service
public class OrderService {
    
    @Transactional
    public Order getOrder(Long orderId) {
        return orderRepository.findById(orderId).get();
    }
    
    // 별도 메소드 - @Transactional 없음!
    public void printOrderDetails(Long orderId) {
        Order order = getOrder(orderId); // 트랜잭션 종료됨
        
        // LazyInitializationException 발생!
        List<OrderItem> items = order.getOrderItems();
    }
}
```

**해결책들:**

**1. 트랜잭션 범위 확장:**
```java
@Transactional
public void printOrderDetails(Long orderId) {
    Order order = orderRepository.findById(orderId).get();
    List<OrderItem> items = order.getOrderItems(); // 정상 동작
}
```

**2. Fetch Join으로 즉시 로딩:**
```java
@Query("SELECT o FROM Order o JOIN FETCH o.orderItems WHERE o.id = :id")
Optional<Order> findWithItemsById(@Param("id") Long id);
```

**3. DTO 변환:**
```java
@Transactional
public OrderDetailDto getOrderDetails(Long orderId) {
    Order order = orderRepository.findById(orderId).get();
    
    return OrderDetailDto.builder()
        .orderId(order.getId())
        .customerName(order.getCustomer().getName())
        .items(order.getOrderItems().stream()
            .map(item -> new OrderItemDto(item.getProduct().getName(), item.getQuantity()))
            .collect(toList()))
        .build();
}
```

---

## 5. Spring Security

### Spring Security 없는 세상

**수동 보안 구현:**
```java
@RestController
public class OrderController {
    
    @PostMapping("/orders")
    public ResponseEntity<?> createOrder(@RequestBody OrderRequest request, 
                                       HttpServletRequest httpRequest) {
        
        // 1. 인증 확인 - 매 컨트롤러마다 반복
        String token = httpRequest.getHeader("Authorization");
        if (token == null || !token.startsWith("Bearer ")) {
            return ResponseEntity.status(401).body("인증 토큰이 없습니다");
        }
        
        // 2. JWT 토큰 검증 - 복잡한 로직
        String jwtToken = token.substring(7);
        Claims claims = Jwts.parser()
            .setSigningKey(secretKey)
            .parseClaimsJws(jwtToken)
            .getBody();
        
        // 3. 권한 확인 - 또 반복되는 로직
        List<String> roles = (List<String>) claims.get("roles");
        if (!roles.contains("ROLE_USER")) {
            return ResponseEntity.status(403).body("권한이 없습니다");
        }
        
        // 드디어 실제 비즈니스 로직
        Order order = orderService.createOrder(request);
        return ResponseEntity.ok(order);
    }
}
```

### Spring Security로 해결

**선언적 보안:**
```java
@RestController
@RequestMapping("/orders")
public class OrderController {
    
    @PostMapping
    @PreAuthorize("hasRole('USER')")
    public ResponseEntity<Order> createOrder(@RequestBody @Valid OrderRequest request,
                                           Authentication authentication) {
        
        String userId = authentication.getName();
        Order order = orderService.createOrder(userId, request);
        return ResponseEntity.ok(order);
    }
    
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('USER') and @orderService.isOwner(#id, authentication.name)")
    public ResponseEntity<Order> getOrder(@PathVariable Long id) {
        Order order = orderService.findById(id);
        return ResponseEntity.ok(order);
    }
}
```

### SecurityFilterChain의 실제 동작

**요청이 거치는 필터들:**
```
HTTP 요청: POST /orders
Header: Authorization: Bearer eyJhbGciOiJIUzI1NiJ9...

1. SecurityContextPersistenceFilter - SecurityContext 로딩
2. BearerTokenAuthenticationFilter - JWT 토큰 추출 및 검증
3. FilterSecurityInterceptor - @PreAuthorize 확인
4. 컨트롤러 메소드 실행
```

### JWT 기반 인증 구현

**JWT 토큰 생성:**
```java
@Service
public class JwtTokenService {
    
    private final String SECRET_KEY = "mySecretKey";
    private final long EXPIRATION_TIME = 86400000; // 24시간
    
    public String generateToken(UserDetails userDetails) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("roles", userDetails.getAuthorities().stream()
            .map(GrantedAuthority::getAuthority)
            .collect(toList()));
        
        return Jwts.builder()
            .setClaims(claims)
            .setSubject(userDetails.getUsername())
            .setIssuedAt(new Date())
            .setExpiration(new Date(System.currentTimeMillis() + EXPIRATION_TIME))
            .signWith(SignatureAlgorithm.HS512, SECRET_KEY)
            .compact();
    }
}
```

**커스텀 JWT 필터:**
```java
@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, 
                                  HttpServletResponse response, 
                                  FilterChain filterChain) throws ServletException, IOException {
        
        final String authHeader = request.getHeader("Authorization");
        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            filterChain.doFilter(request, response);
            return;
        }
        
        final String jwt = authHeader.substring(7);
        final String userEmail = jwtTokenService.extractUsername(jwt);
        
        if (userEmail != null && SecurityContextHolder.getContext().getAuthentication() == null) {
            UserDetails userDetails = userDetailsService.loadUserByUsername(userEmail);
            
            if (jwtTokenService.isTokenValid(jwt, userDetails)) {
                UsernamePasswordAuthenticationToken authToken = 
                    new UsernamePasswordAuthenticationToken(
                        userDetails, null, userDetails.getAuthorities()
                    );
                
                SecurityContextHolder.getContext().setAuthentication(authToken);
            }
        }
        
        filterChain.doFilter(request, response);
    }
}
```

### Method Security

**메소드 레벨 권한 제어:**
```java
@Service
public class BankAccountService {
    
    @PreAuthorize("hasRole('ADMIN') or (hasRole('USER') and #accountId == authentication.principal.accountId)")
    public AccountInfo getAccountInfo(Long accountId) {
        return accountRepository.findById(accountId);
    }
    
    @PreAuthorize("@accountSecurity.isOwner(#accountId, authentication.name)")
    public void withdraw(Long accountId, BigDecimal amount) {
        // 인출 로직
    }
    
    @PostFilter("filterObject.ownerId == authentication.name")
    public List<Transaction> getTransactionHistory() {
        return transactionRepository.findAll();
    }
}

@Component("accountSecurity")
public class AccountSecurityService {
    
    public boolean isOwner(Long accountId, String username) {
        Account account = accountRepository.findById(accountId);
        return account != null && account.getOwnerId().equals(username);
    }
}
```

---

## 6. Bean 생명주기와 스코프

### 빈 스코프별 실제 동작

**Singleton vs Prototype:**
```java
@Component
public class SingletonService {
    private int counter = 0;
    public int increment() { return ++counter; }
}

@Component
@Scope("prototype")
public class PrototypeService {
    private int counter = 0;
    public int increment() { return ++counter; }
}

// 테스트 결과
// SingletonService: 같은 인스턴스, 상태 공유 (1, 2, 3...)
// PrototypeService: 다른 인스턴스, 독립적 상태 (1, 1, 1...)
```

### Prototype 빈의 치명적 함정

**문제 상황:**
```java
@Component // Singleton 스코프
public class SingletonBean {
    
    @Autowired
    private PrototypeBean prototypeBean; // 의존성 주입은 빈 생성 시점에 한 번만!
    
    public LocalDateTime getPrototypeCreatedAt() {
        // 매번 같은 PrototypeBean 인스턴스 반환 (Prototype의 의미 없음)
        return prototypeBean.getCreatedAt();
    }
}
```

**해결책들:**

**1. Provider 사용:**
```java
@Component
public class SingletonBean {
    
    @Autowired
    private Provider<PrototypeBean> prototypeProvider;
    
    public LocalDateTime getPrototypeCreatedAt() {
        PrototypeBean prototype = prototypeProvider.get(); // 매번 새로운 인스턴스
        return prototype.getCreatedAt();
    }
}
```

**2. @Lookup 메소드:**
```java
@Component
public abstract class SingletonBean {
    
    public LocalDateTime getPrototypeCreatedAt() {
        PrototypeBean prototype = getPrototypeBean();
        return prototype.getCreatedAt();
    }
    
    @Lookup
    public abstract PrototypeBean getPrototypeBean(); // 스프링이 구현체 제공
}
```

### Request/Session 스코프

**Request 스코프:**
```java
@Component
@Scope(value = WebApplicationContext.SCOPE_REQUEST, proxyMode = ScopedProxyMode.TARGET_CLASS)
public class RequestScopedService {
    
    private String requestId = UUID.randomUUID().toString();
    private LocalDateTime createdAt = LocalDateTime.now();
    
    // 각 HTTP 요청마다 다른 인스턴스
}

@RestController
public class TestController {
    
    @Autowired
    private RequestScopedService requestScopedService; // 프록시 주입
    
    @GetMapping("/test")
    public Map<String, Object> test() {
        return Map.of(
            "requestId", requestScopedService.getRequestId(), // 요청마다 다른 값
            "createdAt", requestScopedService.getCreatedAt()
        );
    }
}
```

**Session 스코프 활용:**
```java
@Component
@Scope(value = WebApplicationContext.SCOPE_SESSION, proxyMode = ScopedProxyMode.TARGET_CLASS)
public class ShoppingCart {
    
    private List<CartItem> items = new ArrayList<>();
    
    public void addItem(CartItem item) {
        items.add(item);
    }
    
    public int getTotalCount() {
        return items.size();
    }
    
    // 사용자별로 독립적인 장바구니 상태 유지
}
```

---

## 7. Spring WebMVC

### DispatcherServlet의 실제 동작 과정

**HTTP 요청 처리 과정:**
```
POST /orders/123/items
Content-Type: application/json
Body: {"productId": 456, "quantity": 2}

1. DispatcherServlet.doDispatch()
2. HandlerMapping - @RequestMapping 정보로 핸들러 찾기
3. HandlerAdapter 선택
4. Interceptor.preHandle() 실행
5. ArgumentResolver로 메소드 파라미터 준비
6. 컨트롤러 메소드 실행
7. ReturnValueHandler로 응답 처리
8. Interceptor.postHandle() 실행
9. View 렌더링 (REST API는 생략)
10. Interceptor.afterCompletion() 실행
```

**실제 DispatcherServlet 코드:**
```java
protected void doDispatch(HttpServletRequest request, HttpServletResponse response) {
    HandlerExecutionChain mappedHandler = null;
    
    try {
        // 1. 핸들러 찾기
        mappedHandler = getHandler(request);
        
        // 2. HandlerAdapter 가져오기
        HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());
        
        // 3. Interceptor preHandle 실행
        if (!mappedHandler.applyPreHandle(request, response)) {
            return;
        }
        
        // 4. 실제 핸들러 실행
        ModelAndView mv = ha.handle(request, response, mappedHandler.getHandler());
        
        // 5. Interceptor postHandle 실행
        mappedHandler.applyPostHandle(request, response, mv);
        
    } catch (Exception ex) {
        processDispatchResult(request, response, mappedHandler, null, ex);
    }
}
```

### ArgumentResolver - 메소드 파라미터 자동 바인딩

**다양한 파라미터 자동 바인딩:**
```java
@RestController
public class ExampleController {
    
    public ResponseEntity<?> complexMethod(
        @PathVariable Long id,                    // URL 경로에서 추출
        @RequestParam String category,            // 쿼리 파라미터
        @RequestBody @Valid UserRequest request,  // JSON을 객체로 변환
        @RequestHeader("User-Agent") String ua,   // HTTP 헤더
        Authentication authentication,            // 인증 정보 (Security)
        HttpServletRequest httpRequest,           // 서블릿 요청 객체
        @ModelAttribute SearchCriteria criteria  // 폼 데이터 바인딩
    ) {
        // 모든 파라미터가 자동으로 바인딩됨!
        return ResponseEntity.ok().build();
    }
}
```

**커스텀 ArgumentResolver:**
```java
@Target(ElementType.PARAMETER)
@Retention(RetentionPolicy.RUNTIME)
public @interface CurrentUser {
}

@Component
public class CurrentUserArgumentResolver implements HandlerMethodArgumentResolver {
    
    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        return parameter.hasParameterAnnotation(CurrentUser.class) &&
               parameter.getParameterType().equals(User.class);
    }
    
    @Override
    public Object resolveArgument(MethodParameter parameter, ...) throws Exception {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (auth != null && auth.isAuthenticated()) {
            return userService.findByUsername(auth.getName());
        }
        return null;
    }
}

// 사용
@GetMapping("/profile")
public ResponseEntity<UserProfile> getProfile(@CurrentUser User currentUser) {
    // currentUser가 자동으로 주입됨!
    return ResponseEntity.ok(userService.getProfile(currentUser));
}
```

### MessageConverter - 요청/응답 데이터 변환

**주요 MessageConverter들:**
```java
// JSON 변환 - MappingJackson2HttpMessageConverter
@PostMapping(value = "/json", consumes = "application/json", produces = "application/json")
public ResponseEntity<UserResponse> handleJson(@RequestBody UserRequest request) {
    // 요청: JSON → UserRequest 객체 (역직렬화)
    // 응답: UserResponse 객체 → JSON (직렬화)
    return ResponseEntity.ok(new UserResponse(request.getName()));
}

// 폼 데이터 - FormHttpMessageConverter
@PostMapping(value = "/form", consumes = "application/x-www-form-urlencoded")
public ResponseEntity<String> handleForm(@RequestBody MultiValueMap<String, String> formData) {
    String name = formData.getFirst("name");
    return ResponseEntity.ok("Hello " + name);
}
```

### 예외 처리 메커니즘

**예외 처리 우선순위:**
```java
@RestController
public class UserController {
    
    @GetMapping("/{id}")
    public ResponseEntity<User> getUser(@PathVariable Long id) {
        User user = userService.findById(id);
        if (user == null) {
            throw new UserNotFoundException("사용자를 찾을 수 없습니다: " + id);
        }
        return ResponseEntity.ok(user);
    }
    
    // 1순위: 같은 컨트롤러 내의 @ExceptionHandler
    @ExceptionHandler(UserNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleUserNotFound(UserNotFoundException e) {
        ErrorResponse error = ErrorResponse.builder()
            .code("USER_NOT_FOUND")
            .message(e.getMessage())
            .timestamp(LocalDateTime.now())
            .build();
        return ResponseEntity.status(404).body(error);
    }
}

// 2순위: @ControllerAdvice의 @ExceptionHandler
@ControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(UserNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleUserNotFound(UserNotFoundException e) {
        // 컨트롤러 레벨 핸들러가 있으면 실행되지 않음
        return ResponseEntity.status(404).body(createErrorResponse("USER_NOT_FOUND", e.getMessage()));
    }
    
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ValidationErrorResponse> handleValidationErrors(MethodArgumentNotValidException e) {
        ValidationErrorResponse response = new ValidationErrorResponse();
        
        Map<String, String> fieldErrors = new HashMap<>();
        e.getBindingResult().getFieldErrors().forEach(error -> 
            fieldErrors.put(error.getField(), error.getDefaultMessage())
        );
        
        response.setFieldErrors(fieldErrors);
        return ResponseEntity.status(400).body(response);
    }
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGenericException(Exception e) {
        return ResponseEntity.status(500).body(
            createErrorResponse("INTERNAL_SERVER_ERROR", "서버 내부 오류가 발생했습니다")
        );
    }
}
```

---

## 8. 테스트 환경

### 테스트 슬라이스별 로딩 범위

**전체 통합 테스트 vs 슬라이스 테스트:**
```java
// @SpringBootTest - 전체 애플리케이션 컨텍스트 로딩 (5-10초)
@SpringBootTest
class FullIntegrationTest {
    
    @Autowired
    private OrderService orderService; // 실제 구현체
    
    @Autowired
    private OrderRepository orderRepository; // 실제 DB 연결
    
    @Test
    void 주문_생성_통합_테스트() {
        // 실제 환경과 동일, 모든 빈 로딩, 느림
        OrderRequest request = new OrderRequest();
        Order order = orderService.createOrder(request);
        
        Order savedOrder = orderRepository.findById(order.getId()).get();
        assertThat(savedOrder.getStatus()).isEqualTo(OrderStatus.PENDING);
    }
}

// @WebMvcTest - 웹 계층만 테스트 (1-2초)
@WebMvcTest(OrderController.class)
class OrderControllerTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @MockBean
    private OrderService orderService; // Mock으로 대체
    
    @Test
    void 주문_생성_API_테스트() throws Exception {
        when(orderService.createOrder(any())).thenReturn(new Order());
        
        mockMvc.perform(post("/orders")
                .contentType(MediaType.APPLICATION_JSON)
                .content("{\"customerId\": 1}"))
                .andExpect(status().isOk());
    }
}

// @DataJpaTest - JPA 계층만 테스트 (0.5-1초)
@DataJpaTest
class OrderRepositoryTest {
    
    @Autowired
    private TestEntityManager entityManager;
    
    @Autowired
    private OrderRepository orderRepository;
    
    @Test
    void 주문_조회_테스트() {
        Order order = new Order();
        order.setCustomerId(1L);
        entityManager.persistAndFlush(order);
        
        List<Order> orders = orderRepository.findByCustomerId(1L);
        assertThat(orders).hasSize(1);
    }
}
```

### @MockBean vs @Mock

**@Mock (Mockito) - 단순 Mock 객체:**
```java
@ExtendWith(MockitoExtension.class)
class OrderServiceUnitTest {
    
    @Mock
    private OrderRepository orderRepository; // 순수 Mock 객체
    
    @InjectMocks
    private OrderService orderService; // Mock들을 주입받음
    
    @Test
    void 주문_생성_단위_테스트() {
        // Spring 컨텍스트 없이 순수 자바 객체로 테스트
        when(orderRepository.save(any())).thenReturn(new Order());
        
        OrderRequest request = new OrderRequest();
        Order result = orderService.createOrder(request);
        
        assertThat(result).isNotNull();
        verify(orderRepository).save(any());
    }
}

// @MockBean - Spring 컨텍스트의 빈을 Mock으로 대체
@SpringBootTest
class OrderServiceIntegrationTest {
    
    @Autowired
    private OrderService orderService; // 실제 Spring 빈
    
    @MockBean
    private PaymentService paymentService; // Spring 빈을 Mock으로 대체
    
    @Test
    void 주문_생성_통합_테스트() {
        when(paymentService.processPayment(any())).thenReturn(true);
        
        OrderRequest request = new OrderRequest();
        Order result = orderService.createOrder(request);
        
        assertThat(result.getId()).isNotNull(); // 실제 DB에 저장됨
    }
}
```

### 트랜잭션 테스트

**테스트에서 @Transactional의 기본 동작:**
```java
@SpringBootTest
@Transactional // 테스트에서는 기본적으로 롤백됨
class TransactionalTestExample {
    
    @Test
    void 주문_생성_후_자동_롤백() {
        Customer customer = new Customer("홍길동");
        customerRepository.save(customer);
        
        Order order = new Order();
        order.setCustomer(customer);
        orderRepository.save(order);
        
        // 테스트 메소드 내에서는 데이터 존재
        assertThat(orderRepository.findAll()).hasSize(1);
        
        // 테스트 완료 후 자동으로 롤백됨 (DB에 데이터 남지 않음)
    }
    
    @Test
    @Rollback(false) // 롤백하지 않고 커밋
    void 주문_생성_후_커밋() {
        Order order = new Order();
        orderRepository.save(order);
        // 테스트 완료 후에도 DB에 데이터가 남음
    }
}
```

### TestContainers - 실제 DB로 테스트

**실제 데이터베이스 사용:**
```java
@SpringBootTest
@Testcontainers
class RealDatabaseTest {
    
    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:13")
            .withDatabaseName("testdb")
            .withUsername("test")
            .withPassword("test");
    
    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);
    }
    
    @Test
    void PostgreSQL_JSON_기능_테스트() {
        // 실제 PostgreSQL에서 테스트
        Order order = new Order();
        order.setMetadata("{\"items\": [{\"name\": \"book\", \"price\": 15000}]}");
        
        Order saved = orderRepository.save(order);
        
        // PostgreSQL의 JSON 연산자 테스트 가능
        List<Order> orders = orderRepository.findByJsonPath("$.items[0].name", "book");
        assertThat(orders).hasSize(1);
    }
}
```

---

## 9. Spring Boot Actuator

### Health Check 구현과 활용

**기본 Health Check:**
```yaml
# application.yml
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics
  endpoint:
    health:
      show-details: always
```

**GET /actuator/health 응답:**
```json
{
  "status": "UP",
  "components": {
    "db": {
      "status": "UP",
      "details": {
        "database": "PostgreSQL",
        "validationQuery": "isValid()"
      }
    },
    "diskSpace": {
      "status": "UP",
      "details": {
        "total": 250685575168,
        "free": 48929718272
      }
    }
  }
}
```

**커스텀 Health Indicator:**
```java
@Component
public class ExternalApiHealthIndicator implements HealthIndicator {
    
    private final WebClient webClient;
    
    @Override
    public Health health() {
        try {
            long startTime = System.currentTimeMillis();
            
            String response = webClient.get()
                .uri("https://api.external-service.com/health")
                .retrieve()
                .bodyToMono(String.class)
                .timeout(Duration.ofSeconds(5))
                .block();
            
            long responseTime = System.currentTimeMillis() - startTime;
            
            if (response != null && response.contains("\"status\":\"UP\"")) {
                return Health.up()
                    .withDetail("responseTime", responseTime + "ms")
                    .withDetail("response", response)
                    .build();
            } else {
                return Health.down()
                    .withDetail("error", "Unexpected response: " + response)
                    .build();
            }
            
        } catch (Exception e) {
            return Health.down()
                .withDetail("error", e.getMessage())
                .withException(e)
                .build();
        }
    }
}
```

### Metrics - 비즈니스 지표 수집

**커스텀 메트릭 생성:**
```java
@Component
public class OrderMetrics {
    
    private final Counter orderCreatedCounter;
    private final Timer orderProcessingTimer;
    private final Gauge pendingOrdersGauge;
    
    public OrderMetrics(MeterRegistry meterRegistry, OrderRepository orderRepository) {
        // 주문 생성 횟수 카운터
        this.orderCreatedCounter = Counter.builder("orders.created")
            .description("Number of orders created")
            .register(meterRegistry);
            
        // 주문 처리 시간 측정
        this.orderProcessingTimer = Timer.builder("orders.processing.time")
            .description("Order processing time")
            .register(meterRegistry);
            
        // 대기 중인 주문 수 (실시간 값)
        this.pendingOrdersGauge = Gauge.builder("orders.pending")
            .description("Number of pending orders")
            .register(meterRegistry, this, OrderMetrics::getPendingOrdersCount);
    }
    
    public void recordOrderCreated(String region, String paymentMethod) {
        orderCreatedCounter.increment(
            Tags.of("region", region, "payment.method", paymentMethod)
        );
    }
    
    private double getPendingOrdersCount() {
        return orderRepository.countByStatus(OrderStatus.PENDING);
    }
}

@Service
public class OrderService {
    
    public Order createOrder(OrderRequest request) {
        Timer.Sample sample = Timer.start(meterRegistry);
        
        try {
            Order order = processOrder(request);
            
            // 성공 메트릭 기록
            orderMetrics.recordOrderCreated(
                request.getRegion(), 
                request.getPaymentMethod()
            );
            
            sample.stop(Timer.builder("orders.processing.time")
                .tag("result", "success")
                .register(meterRegistry));
            
            return order;
            
        } catch (Exception e) {
            sample.stop(Timer.builder("orders.processing.time")
                .tag("result", "failure")
                .register(meterRegistry));
            throw e;
        }
    }
}
```

### 커스텀 Endpoint

**시스템 상태 종합 정보:**
```java
@Component
@Endpoint(id = "system-status")
public class SystemStatusEndpoint {
    
    @ReadOperation
    public Map<String, Object> getSystemStatus() {
        Map<String, Object> status = new HashMap<>();
        
        // 데이터베이스 상태
        long totalOrders = orderRepository.count();
        long pendingOrders = orderRepository.countByStatus(OrderStatus.PENDING);
        
        status.put("database", Map.of(
            "status", "UP",
            "totalOrders", totalOrders,
            "pendingOrders", pendingOrders
        ));
        
        // JVM 메모리 상태
        Runtime runtime = Runtime.getRuntime();
        long maxMemory = runtime.maxMemory();
        long usedMemory = runtime.totalMemory() - runtime.freeMemory();
        
        status.put("memory", Map.of(
            "maxMemoryMB", maxMemory / 1024 / 1024,
            "usedMemoryMB", usedMemory / 1024 / 1024,
            "memoryUsagePercent", (usedMemory * 100.0) / maxMemory
        ));
        
        return status;
    }
}

// 캐시 관리 엔드포인트
@Component
@Endpoint(id = "cache-management")
public class CacheManagementEndpoint {
    
    @ReadOperation
    public Map<String, Object> getCacheStatus() {
        // 캐시별 상태 정보 반환
    }
    
    @WriteOperation
    public Map<String, String> clearCache(@Selector String cacheName) {
        Cache cache = cacheManager.getCache(cacheName);
        if (cache != null) {
            cache.clear();
            return Map.of("result", "Cache '" + cacheName + "' cleared");
        }
        return Map.of("error", "Cache not found");
    }
}
```

### 프로덕션 보안 설정

**보안을 고려한 설정:**
```yaml
# application-prod.yml
management:
  endpoints:
    web:
      base-path: /internal/actuator # 기본 경로 변경
      exposure:
        include: health,info,metrics # 필요한 것만 노출
        exclude: shutdown,env # 위험한 엔드포인트 제외
  endpoint:
    health:
      show-details: when-authorized # 인증된 사용자만 상세 정보
      roles: ADMIN
  server:
    port: 9090 # 관리용 포트 분리
    address: 127.0.0.1 # 로컬 접근만 허용
```

**Spring Security 연동:**
```java
@Configuration
public class ActuatorSecurityConfig {
    
    @Bean
    @Order(1)
    public SecurityFilterChain actuatorSecurityFilterChain(HttpSecurity http) throws Exception {
        return http
            .securityMatcher("/internal/actuator/**")
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/internal/actuator/health").permitAll()
                .requestMatchers("/internal/actuator/**").hasRole("ADMIN")
            )
            .httpBasic()
            .build();
    }
}
```

---

## 10. 성능 최적화와 트러블슈팅

### 시작 시간 최적화

**시작 시간을 느리게 만드는 요소들:**
```java
// 문제 1: 불필요하게 넓은 컴포넌트 스캔
@ComponentScan(basePackages = {"com.example", "com.other.huge.package"})

// 문제 2: 복잡한 @PostConstruct
@Component
public class HeavyComponent {
    @PostConstruct
    public void heavyInit() {
        // 큰 파일 읽기, 복잡한 계산 등
        // 애플리케이션 시작을 지연시킴
    }
}
```

**최적화 방법:**
```yaml
# application.yml
spring:
  main:
    lazy-initialization: true # 지연 초기화
  jpa:
    defer-datasource-initialization: true
    hibernate:
      ddl-auto: none # 운영환경에서는 DDL 비활성화
```

```java
@SpringBootApplication
@ComponentScan(basePackages = "com.example.core") // 필요한 패키지만
public class OptimizedApplication {
    
    public static void main(String[] args) {
        SpringApplication app = new SpringApplication(OptimizedApplication.class);
        app.setLazyInitialization(true);
        app.run(args);
    }
}

// 무거운 초기화는 비동기로
@Component
public class AsyncInitComponent {
    
    @EventListener(ApplicationReadyEvent.class)
    @Async
    public void initAfterStartup() {
        // 시작 완료 후 비동기로 초기화
        performHeavyInit();
    }
}
```

### 메모리 누수 방지

**흔한 메모리 누수 원인들:**
```java
// 문제 1: 정적 컬렉션에 계속 추가
@Component
public class LeakyComponent {
    private static final Map<String, User> cache = new HashMap<>(); // 위험!
    
    public void cacheUser(String id, User user) {
        cache.put(id, user); // 계속 쌓이면서 메모리 누수
    }
}

// 문제 2: ThreadLocal 정리 안함
public class ThreadLocalLeak {
    private static final ThreadLocal<User> currentUser = new ThreadLocal<>();
    
    public void setUser(User user) {
        currentUser.set(user);
        // remove() 호출 안하면 메모리 누수
    }
}
```

**올바른 메모리 관리:**
```java
@Component
public class ProperMemoryManagement {
    
    // 적절한 크기 제한과 TTL 설정
    private final Cache<String, User> userCache = Caffeine.newBuilder()
        .maximumSize(10000)
        .expireAfterWrite(Duration.ofHours(1))
        .build();
    
    @PreDestroy
    public void cleanup() {
        userCache.invalidateAll();
    }
}

// ThreadLocal 안전 사용
@Component
public class SafeThreadLocal {
    private static final ThreadLocal<RequestContext> context = new ThreadLocal<>();
    
    @EventListener
    public void onRequestCompleted(RequestCompletedEvent event) {
        context.remove(); // 반드시 정리
    }
}
```

### 데이터베이스 성능 최적화

**효율적인 트랜잭션 관리:**
```java
@Service
public class OptimizedOrderService {
    
    @Transactional(readOnly = true) // 읽기 전용으로 성능 향상
    public List<OrderSummary> getOrderSummaries(Pageable pageable) {
        return orderRepository.findSummaries(pageable);
    }
    
    @Transactional
    public void createOrder(OrderRequest request) {
        // 필요한 쓰기 작업만 트랜잭션 적용
    }
    
    public void processLargeDataset() {
        // 대량 처리는 배치로 분할
        try (Stream<Order> orders = orderRepository.streamByStatus(OrderStatus.PENDING)) {
            orders.forEach(this::processInSeparateTransaction);
        }
    }
    
    @Transactional
    public void processInSeparateTransaction(Order order) {
        // 각 항목을 별도 트랜잭션으로 처리
        order.process();
        orderRepository.save(order);
    }
}
```

**효율적인 쿼리 작성:**
```java
@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {
    
    // 필요한 컬럼만 조회 (DTO Projection)
    @Query("SELECT new OrderSummaryDto(o.id, o.amount, c.name) " +
           "FROM Order o JOIN o.customer c WHERE o.status = :status")
    List<OrderSummaryDto> findOrderSummaries(@Param("status") OrderStatus status);
    
    // 배치 처리용 ID 기반 페이징
    @Query("SELECT o FROM Order o WHERE o.id > :lastId ORDER BY o.id")
    List<Order> findBatchAfter(@Param("lastId") Long lastId, Pageable pageable);
}

// 안정적인 배치 처리
@Service
public class BatchProcessor {
    
    private static final int BATCH_SIZE = 1000;
    
    @Transactional
    public void processPendingOrders() {
        Long lastId = 0L;
        List<Order> batch;
        
// 안정적인 배치 처리
@Service
public class BatchProcessor {
    
    private static final int BATCH_SIZE = 1000;
    
    @Transactional
    public void processPendingOrders() {
        Long lastId = 0L;
        List<Order> batch;
        
        do {
            batch = orderRepository.findBatchAfter(lastId, PageRequest.of(0, BATCH_SIZE));
            
            if (!batch.isEmpty()) {
                processBatch(batch);
                lastId = batch.get(batch.size() - 1).getId();
            }
            
            entityManager.clear(); // 메모리 정리
            
        } while (batch.size() == BATCH_SIZE);
    }
    
    private void processBatch(List<Order> orders) {
        orders.forEach(Order::process);
        orderRepository.saveAll(orders);
    }
}
```

---

## 실무 적용 체크리스트

### 프로젝트 시작 시 고려사항
- [ ] **의존성 주입 전략** - 생성자 주입 우선, 순환 참조 방지
- [ ] **트랜잭션 경계 설계** - 적절한 범위와 전파 속성 설정
- [ ] **AOP 적용 범위** - 횡단 관심사 분리, Self-Invocation 문제 고려
- [ ] **JPA 페치 전략** - N+1 문제 대응 방안 수립
- [ ] **보안 요구사항** - Spring Security 설정과 인증/인가 전략
- [ ] **테스트 전략** - 단위/통합/슬라이스 테스트 비율 결정

### 성능 최적화 체크포인트
- [ ] **애플리케이션 시작 시간** - 지연 초기화, 컴포넌트 스캔 범위 최적화
- [ ] **메모리 사용량** - GC 패턴 모니터링, 캐시 크기 제한
- [ ] **데이터베이스 쿼리** - N+1 해결, 적절한 인덱스, 페이징 처리
- [ ] **캐시 전략** - 1차/2차 캐시, TTL 설정
- [ ] **운영 지표 수집** - Actuator 메트릭, 비즈니스 지표

### 운영 환경 준비사항
- [ ] **Health Check 설정** - 커스텀 헬스 체크, 외부 시스템 상태 확인
- [ ] **로그 수준과 모니터링** - 적절한 로그 레벨, 구조화된 로깅
- [ ] **보안 설정** - Actuator 접근 제한, 민감한 엔드포인트 비활성화
- [ ] **외부 시스템 연동** - Circuit Breaker, 타임아웃 설정
- [ ] **장애 대응** - 에러 핸들링, 복구 메커니즘

### 주요 트러블슈팅 포인트

**1. 자주 발생하는 예외들:**
- `NoUniqueBeanDefinitionException` → `@Qualifier`나 `@Primary` 사용
- `LazyInitializationException` → `@Transactional` 범위 확인
- `BeanCurrentlyInCreationException` → 순환 참조 해결
- `BeanCreationException` → 빈 생성 과정 예외 스택 추적

**2. 성능 문제 진단:**
- N+1 쿼리 로그 확인 (`show-sql: true`, `format_sql: true`)
- 메모리 힙 덤프 분석
- GC 로그 모니터링
- Actuator 메트릭으로 병목 지점 파악

**3. 보안 문제 해결:**
- CORS 설정 확인
- JWT 토큰 만료 시간 적절성
- CSRF 보호 필요성 검토
- 민감한 정보 로그 출력 방지

---

## 추가 학습 가이드

### 단계별 학습 접근법

**1. 기초 다지기 (1-2개월)**
- 의존성 주입 개념과 생성자 주입 방식
- 기본적인 AOP 사용법 (@Transactional, @Cacheable)
- JPA 기본 CRUD와 연관관계 매핑
- Spring Boot 자동 설정 이해

**2. 심화 학습 (2-3개월)**
- AOP 프록시 메커니즘과 Self-Invocation 해결
- JPA N+1 문제와 해결책들
- Spring Security 필터 체인과 JWT 구현
- 테스트 전략과 슬라이스 테스트

**3. 실무 적용 (3-6개월)**
- 성능 최적화 기법들
- Actuator를 활용한 운영 모니터링
- 대용량 데이터 처리와 배치 최적화
- 마이크로서비스 패턴 적용

### 실습 프로젝트 아이디어

**1. 온라인 쇼핑몰 시스템**
- 사용자 인증/인가 (Spring Security + JWT)
- 주문 처리 트랜잭션 관리
- 상품 조회 시 N+1 해결
- 장바구니 세션 관리

**2. 게시판 시스템**
- AOP를 활용한 로깅과 권한 체크
- 파일 업로드와 다운로드
- 페이징과 검색 기능
- 캐싱 전략 적용

**3. 배치 처리 시스템**
- 대용량 데이터 처리 최적화
- 스케줄러와 비동기 처리
- 실패 처리와 재시도 로직
- 모니터링과 알림

### 유용한 도구들

**개발 도구:**
- IntelliJ IDEA Ultimate (Spring 개발 지원)
- Spring Boot DevTools (자동 재시작)
- H2 Console (개발용 DB 확인)
- Postman (API 테스트)

**모니터링 도구:**
- Micrometer + Prometheus + Grafana (메트릭 수집/시각화)
- ELK Stack (로그 분석)
- JProfiler (성능 프로파일링)
- VisualVM (JVM 모니터링)

**테스트 도구:**
- TestContainers (실제 DB 테스트)
- WireMock (외부 API 모킹)
- JMeter (부하 테스트)

---


**핵심 포인트들:**
- 의존성 주입은 단순히 객체를 주입받는 것이 아니라, 유연하고 테스트 가능한 설계의 기초
- AOP는 횡단 관심사를 분리하여 비즈니스 로직에 집중할 수 있게 해주는 강력한 도구
- JPA 영속성 컨텍스트를 이해해야 N+1 문제와 같은 성능 이슈를 해결할 수 있음
- Spring Security는 복잡해 보이지만 필터 체인의 동작 원리를 이해하면 명확해짐
- 테스트는 빠른 피드백과 안전한 리팩토링의 핵심
- 운영 환경에서는 모니터링과 성능 최적화가 필수



Spring Framework는 방대하고 복잡하지만, 제대로 이해하고 활용하면 매우 강력한 도구가 됩니다. 이 가이드가 Spring 마스터가 되는 여정에 도움이 되기를 바랍니다.
