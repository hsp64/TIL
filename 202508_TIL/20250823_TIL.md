# 25년 8월 23일

---


# sqld 정리

## 1장. 데이터 모델링

### 1-1. 데이터 모델링 개요
- **정의**: 현실 세계 데이터를 DBMS에서 관리할 수 있게 구조화하는 과정
- **단계**: 개념적 → 논리적 → 물리적
- **ERD 구성요소**
  - 엔터티(Entity): 관리 대상 (회원, 주문)
  - 속성(Attribute): 특징 (회원ID, 이름)
  - 관계(Relationship): 연관 (회원–주문: 1:N)

### 1-2. 키(Key)
- 슈퍼키(Super): 유일성 보장하는 속성 집합
- 후보키(Candidate): 최소 슈퍼키
- 기본키(Primary): 대표 후보키, NULL/중복 불가
- 대체키(Alternate): 기본키 제외 후보키
- 외래키(Foreign): 참조 무결성 보장
- 대리키(Surrogate): 의미 없는 인조키

### 1-3. 정규화
- **목적**: 이상현상 제거 (삽입/갱신/삭제 이상)
- 1NF: 원자값
- 2NF: 부분 종속 제거
- 3NF: 이행 종속 제거
- BCNF: 결정자가 후보키 아닌 경우 제거
- **반정규화**: 성능 위해 중복 허용 (조인 과다시)

---

## 2장. SQL 기본

### 2-1. SELECT 실행 순서
FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY

### 2-2. 제약조건
- PRIMARY KEY: 유일 + NULL 불가
- UNIQUE: 중복 불가, NULL 허용
- NOT NULL: NULL 불가
- CHECK: 조건 제약
- FOREIGN KEY: 참조 무결성

### 2-3. 집합 연산자
- UNION: 중복 제거 합집합
- UNION ALL: 중복 포함 합집합
- INTERSECT: 교집합
- MINUS(EXCEPT): 차집합

---

## 3장. SQL 심화

### 3-1. JOIN
- INNER JOIN: 교집합
- OUTER JOIN: LEFT/RIGHT/FULL
- SELF JOIN: 자기 자신과 조인

### 3-2. 서브쿼리
- 단일 행: =, <, >
- 다중 행: IN, ANY, ALL
- 상관 서브쿼리: 외부 값 참조
- EXISTS/NOT EXISTS: 존재 여부

### 3-3. NULL 처리
- NVL(expr1, expr2)
- COALESCE(expr1, expr2, ...)
- NULLIF(expr1, expr2)

### 3-4. 윈도우 함수
- 순위: ROW_NUMBER, RANK, DENSE_RANK
- 이동: LAG, LEAD
- 집계: SUM() OVER(PARTITION BY ...)
- 누적 합: ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW

### 3-5. 조건부 집계
```sql
SELECT dept,
       SUM(CASE WHEN grade='A' THEN 1 ELSE 0 END) AS cnt_a
FROM emp GROUP BY dept;
```

### 3-6. CTE (WITH절)
- 복잡 쿼리 단순화
- 재귀 CTE: 계층 구조 조회

---

## 4장. 성능 최적화

### 4-1. 인덱스
- 클러스터형 vs 비클러스터형
- Left-most Rule: (A,B,C) → A, A+B, A+B+C에서만 사용
- LIKE '값%': 인덱스 사용
- LIKE '%값': 인덱스 미사용
- 컬럼에 함수/연산 사용 시 인덱스 무력화

### 4-2. 조인 알고리즘
- Nested Loop: 소량+인덱스
- Hash Join: 대량+동등 조인
- Sort Merge: 대량+정렬 후 병합

### 4-3. 뷰(View)
- 장점: 보안, SQL 단순화
- WITH CHECK OPTION: 뷰 조건 위반 입력 방지
- READ ONLY: 수정 금지

---

## 5장. 트랜잭션/동시성

### 5-1. ACID
- 원자성(Atomicity): 전부 실행/취소
- 일관성(Consistency): 무결성 유지
- 고립성(Isolation): 동시 실행 결과 동일
- 지속성(Durability): 커밋 결과 영구

### 5-2. TCL
- COMMIT, ROLLBACK, SAVEPOINT

### 5-3. 격리 수준과 이상현상
- Read Uncommitted: Dirty Read 발생
- Read Committed: Dirty X, Non-repeatable 가능 (Oracle 기본)
- Repeatable Read: Non-repeatable X, Phantom 가능 (MySQL InnoDB 기본)
- Serializable: 모든 이상현상 차단

---

## 6장. 자주 나오는 기출 함정

1. NOT IN + NULL → 결과 없음 → NOT EXISTS 사용
2. OUTER JOIN 후 WHERE 조건 → 의미 상실 (조건은 ON에)
3. COUNT(col) vs COUNT(*) → col은 NULL 제외
4. UNION vs UNION ALL → 성능/중복 차이
5. LIKE '%값' 인덱스 미사용
6. UNIQUE는 NULL 허용, PK는 NULL 불가

---

## 7장. 기출 유형별 예제문제 + 풀이

### 예제 1. Top-N per Group (부서별 급여 상위 2명)
```sql
SELECT *
FROM (
  SELECT e.*, ROW_NUMBER() OVER(PARTITION BY dept ORDER BY salary DESC) rn
  FROM emp e
) x
WHERE rn <= 2;
```
**풀이**: 윈도우 함수로 그룹 내 순번 매겨 상위 2명 추출.

---

### 예제 2. 주문 없는 고객 찾기 (Anti-Join)
```sql
SELECT c.*
FROM customer c
WHERE NOT EXISTS (SELECT 1 FROM orders o WHERE o.customer_id = c.id);
```
**풀이**: `NOT IN`은 NULL 문제 발생 → `NOT EXISTS` 안전.

---

### 예제 3. OUTER JOIN 필터링 주의
```sql
-- 잘못된 예
SELECT a.*, b.col
FROM A a LEFT JOIN B b ON a.id = b.id
WHERE b.flag = 'Y';

-- 올바른 예
SELECT a.*, b.col
FROM A a LEFT JOIN B b ON a.id = b.id AND b.flag = 'Y';
```
**풀이**: WHERE절 조건 걸면 OUTER JOIN 의미 사라짐. 조건은 ON절에.

---

### 예제 4. 월별 누적 판매액
```sql
SELECT month,
       SUM(amount) OVER(ORDER BY month
         ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cum_amt
FROM sales_by_month;
```
**풀이**: 윈도우 함수 + 프레임 지정으로 누적 합 계산.

---

### 예제 5. 조건부 집계
```sql
SELECT dept,
       SUM(CASE WHEN grade='A' THEN 1 ELSE 0 END) AS a_cnt,
       SUM(CASE WHEN grade='B' THEN 1 ELSE 0 END) AS b_cnt
FROM emp GROUP BY dept;
```
**풀이**: CASE로 조건별 COUNT를 집계.

---

### 예제 6. 트랜잭션 격리 수준
- Dirty Read: Read Uncommitted에서만 발생
- Non-repeatable Read: Read Committed에서 발생 가능
- Phantom Read: Repeatable Read에서 발생 가능
- Serializable: 모두 방지

**풀이**: 각 격리 수준과 이상현상 매칭 암기 필수.

---

## 8장. 시험 직전 암기 카드

- 정규화 단계 & 이상현상
- SELECT 실행 순서
- JOIN 종류 & OUTER JOIN 주의점
- EXISTS vs IN vs NOT IN(NULL)
- 윈도우 함수 5종 (ROW_NUMBER, RANK, DENSE_RANK, LAG, LEAD)
- 인덱스 Left-most Rule, LIKE 패턴
- 트랜잭션 ACID + 격리 수준

---
