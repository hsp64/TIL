# 25년 8월 18일


---

# 여행일지/태그/파일업로드/QueryDSL/컨트롤러/프론트

---

## 0. 전체 흐름(아키텍처 개요)

```
[Frontend]
travel-log-form.html / travel-log-form.js
        │  FormData(텍스트 + 파일)
        ▼
[API] TravelLogController (POST /api/travel-logs)
        │  유효성 검증, 인증정보 추출
        ▼
[Service] TravelLogService.createTravelLog()
        │  사용자/여행 검증 → 엔티티 생성 → 파일 검증/저장 → 사진 메타데이터 저장
        ▼
[Repository] TravelLog / Tag / TravelPhoto (+ QueryDSL 동적조회/통계)
        ▼
[Static] /uploads/** (WebMvc 리소스 핸들러로 로컬 파일 서빙)
```

---

## 1. 도메인 설계와 관계

### 1) 핵심 엔티티

* **TravelLog**: 여행 하루/구간의 기록(본문, 기분, 별점, 지출 등)
* **TravelPhoto**: 여행일지의 사진 메타데이터(파일명, URL, 정렬순서)
* **Tag**, **TagCategory**: 태그 분류와 색상
* **TravelLogTag**: `TravelLog` ↔ `Tag` 다대다를 풀기 위한 조인 엔티티

### 2) 왜 조인 엔티티를 사용했나?

* 다대다 직접 매핑은 **추가 속성**(예: 태그 부여 시점, 정렬) 관리가 어려움.
* `TravelLogTag`를 두면 **중복 방지**, **ID 기반 제어**, **추가 속성** 확장이 쉬움.

### 3) 관계 요약

* Trip(여행) : TravelLog = **1\:N**
* TravelLog : TravelPhoto = **1\:N** (사진 정렬/썸네일 용이)
* TravelLog : Tag = **N\:M** (조인 엔티티 TravelLogTag로 구현)

> 베스트 프랙티스: **단방향 연관관계**를 기본으로 시작하고, 필요 시에만 양방향을 연다. 조회 최적화는 QueryDSL로 해결.

---

## 2. 파일 업로드 설계

### 1) 요구사항 → 설계 포인트

* 이미지 **최대 5개**, 확장자/마임타입 검증, 저장 실패 시 롤백
* 로컬 개발에서는 `/uploads/**`로 서빙, 운영에서는 S3/NFS로 대체 가능하게 **추상화**

### 2) 설정 예시

```yaml
# application.yml
upload:
  base-dir: ./uploads
  image-allowed-ext: jpg,jpeg,png,webp
  max-count: 5
```

```java
// FileUploadConfig.java
@Configuration
public class FileUploadConfig {
    @Value("${upload.base-dir}")
    private Path baseDir;

    @PostConstruct
    public void init() throws IOException {
        Files.createDirectories(baseDir.resolve("images")); // 필요 디렉토리 미리 생성
    }
}
```

```java
// WebResourceConfig.java
@Configuration
public class WebResourceConfig implements WebMvcConfigurer {
    @Value("${upload.base-dir}")
    private String baseDir;

    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/uploads/**")
                .addResourceLocations("file:" + Paths.get(baseDir).toAbsolutePath().toString() + "/");
    }
}
```

### 3) 서비스 레벨 구현 스켈레톤

```java
// TravelLogService.java
@Service
@RequiredArgsConstructor
@Transactional
public class TravelLogService {
    private final UserRepository userRepository;
    private final TripRepository tripRepository;
    private final TravelLogRepository travelLogRepository;
    private final TravelPhotoRepository travelPhotoRepository;
    private final TagRepository tagRepository;
    private final FileStorageService fileStorageService; // 로컬/S3 교체 가능 추상화

    public Long createTravelLog(Long userId, Long tripId,
                                TravelLogRequestDto dto,
                                List<MultipartFile> images) {
        // 1) 사용자/여행 검증
        User user = userRepository.findById(userId)
            .orElseThrow(() -> new ApiException(ErrorCode.USER_NOT_FOUND));
        Trip trip = tripRepository.findById(tripId)
            .orElseThrow(() -> new ApiException(ErrorCode.TRIP_NOT_FOUND));

        // 2) 엔티티 생성
        TravelLog log = TravelLog.create(trip, user, dto.getTitle(), dto.getContent(),
                                         dto.getMood(), dto.getRating(), dto.getExpense());
        travelLogRepository.save(log);

        // 3) 태그 매핑 (중복 방지)
        if (dto.getTagIds() != null) {
            List<Tag> tags = tagRepository.findAllById(dto.getTagIds());
            log.attachTags(tags); // 내부에서 중복 체크 & 조인엔티티 생성
        }

        // 4) 이미지 검증/저장 (최대 5개)
        if (images != null && !images.isEmpty()) {
            if (images.size() > 5) throw new ApiException(ErrorCode.FILE_UPLOAD_LIMIT_EXCEEDED);
            int order = 0;
            for (MultipartFile file : images) {
                if (file.isEmpty()) continue;
                String url = fileStorageService.storeImage(file); // 확장자/마임 검증 포함
                TravelPhoto photo = TravelPhoto.of(log, url, order++);
                travelPhotoRepository.save(photo);
            }
        }
        return log.getId();
    }
}
```

> 트랜잭션 내부에서 파일 저장 실패 시 예외를 던져 **DB 롤백**. 파일 정리(보상 트랜잭션)는 운영 단계에서 별도 고려.

---

## 3. DTO 설계 (요청/응답 분리)

```java
@Getter @Builder
@AllArgsConstructor @NoArgsConstructor
public class TravelLogRequestDto {
    @NotBlank private String title;
    @NotBlank private String content;
    private String mood;      // 선택값
    private Integer rating;   // 0~5
    private Integer expense;  // 지출 금액(원)
    private List<Long> tagIds; // 선택 태그 ID 목록

    public void validate() {
        if (rating != null && (rating < 0 || rating > 5))
            throw new ApiException(ErrorCode.INVALID_RATING_RANGE);
        if (expense != null && expense < 0)
            throw new ApiException(ErrorCode.INVALID_EXPENSE_VALUE);
    }
}
```

* **왜 분리?**: API 안정성(계약), 보안(불필요 데이터 노출 방지), 프론트/백 독립 진화.

---

## 4. 컨트롤러 — 멀티파트 처리 핵심

```java
// TravelLogController.java
@RestController
@RequiredArgsConstructor
@RequestMapping("/api/travel-logs")
public class TravelLogController {
    private final TravelLogService travelLogService;

    @PostMapping(consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public ApiResponse<Long> create(
        @AuthenticationPrincipal AuthUser auth, // username/userId 보유 가정
        @RequestPart("data") @Valid TravelLogRequestDto data,
        @RequestPart(value = "images", required = false) List<MultipartFile> images,
        @RequestParam("tripId") Long tripId
    ) {
        data.validate();
        Long id = travelLogService.createTravelLog(auth.getUserId(), tripId, data, images);
        return ApiResponse.ok(id);
    }
}
```

* **핵심 포인트**: `FormData`를 쓸 때 **프론트가 `Content-Type`을 직접 지정하지 않는다.**(브라우저가 boundary 포함해서 설정)
* JSON + 파일을 함께 전송하려면 JSON을 문자열로 보내고 `@RequestPart("data")`로 매핑하거나 `@ModelAttribute`를 사용.

---

## 5. QueryDSL — 동적 조회 & 통계 예시

### 1) 인터페이스

```java
public interface TravelLogQuery {
    Page<TravelLog> search(Long tripId, List<Long> tagIds, LocalDate from, LocalDate to, Pageable pageable);
    List<TagUsageDto> topTags(Long tripId, int limit);
}
```

### 2) 구현 (요지)

```java
@Repository
@RequiredArgsConstructor
public class TravelLogQueryImpl implements TravelLogQuery {
    private final JPAQueryFactory query;

    @Override
    public Page<TravelLog> search(Long tripId, List<Long> tagIds, LocalDate from, LocalDate to, Pageable pageable) {
        QTravelLog log = QTravelLog.travelLog;
        QTravelLogTag ltag = QTravelLogTag.travelLogTag;

        BooleanBuilder where = new BooleanBuilder();
        if (tripId != null) where.and(log.trip.id.eq(tripId));
        if (from != null) where.and(log.createdAt.goe(from.atStartOfDay()));
        if (to != null) where.and(log.createdAt.loe(to.atTime(23,59,59)));
        JPAQuery<TravelLog> base = query.selectFrom(log)
                .leftJoin(log.travelLogTags, ltag).fetchJoin()
                .where(where)
                .distinct();
        if (tagIds != null && !tagIds.isEmpty()) {
            base.where(ltag.tag.id.in(tagIds));
        }
        List<TravelLog> content = base
                .offset(pageable.getOffset())
                .limit(pageable.getPageSize())
                .orderBy(log.createdAt.desc())
                .fetch();
        long total = query.select(log.count()).from(log).where(where).fetchOne();
        return new PageImpl<>(content, pageable, total);
    }

    @Override
    public List<TagUsageDto> topTags(Long tripId, int limit) {
        QTravelLog log = QTravelLog.travelLog;
        QTravelLogTag ltag = QTravelLogTag.travelLogTag;
        QTag tag = QTag.tag;
        return query.select(Projections.constructor(TagUsageDto.class,
                    tag.id, tag.name, ltag.count()))
                .from(ltag)
                .join(ltag.travelLog, log)
                .join(ltag.tag, tag)
                .where(tripId != null ? log.trip.id.eq(tripId) : null)
                .groupBy(tag.id, tag.name)
                .orderBy(ltag.count().desc())
                .limit(limit)
                .fetch();
    }
}
```

* **주의**: 통계 쿼리는 꼭 `groupBy` 컬럼을 명시. 목록 조회는 **N+1 방지**를 위해 필요한 곳에만 fetch join 사용.

---

## 6. 에러 코드 & 예외 처리

```java
@Getter
@AllArgsConstructor
public enum ErrorCode {
    USER_NOT_FOUND(404, "USER_NOT_FOUND"),
    TRIP_NOT_FOUND(404, "TRIP_NOT_FOUND"),
    TRAVEL_LOG_NOT_FOUND(404, "TRAVEL_LOG_NOT_FOUND"),
    TAG_NOT_FOUND(404, "TAG_NOT_FOUND"),
    FILE_UPLOAD_LIMIT_EXCEEDED(400, "FILE_UPLOAD_LIMIT_EXCEEDED"),
    FILE_TYPE_NOT_ALLOWED(400, "FILE_TYPE_NOT_ALLOWED"),
    INVALID_RATING_RANGE(400, "INVALID_RATING_RANGE"),
    INVALID_EXPENSE_VALUE(400, "INVALID_EXPENSE_VALUE"),
    FILE_STORE_FAILED(500, "FILE_STORE_FAILED");

    private final int status;
    private final String code;
}
```

* **핵심**: 예외는 서비스 계층에서 던지고, 컨트롤러 어드바이스에서 **일관된 JSON** 응답으로 변환.

---

## 7. Frontend — FormData 전송과 미리보기

### 1) HTML 골격

```html
<!-- travel-log-form.html (요지) -->
<form id="logForm">
  <input name="tripId" type="hidden" value="{{tripId}}" />
  <input name="title" required />
  <textarea name="content" required></textarea>
  <input name="rating" type="number" min="0" max="5" />
  <input id="images" type="file" accept="image/*" multiple />
  <button type="submit">저장</button>
</form>
<div id="preview"></div>
```

### 2) JS — 핵심 로직

```js
// api.js
export async function postMultipart(url, formData, token) {
  const res = await fetch(url, {
    method: 'POST',
    headers: token ? { Authorization: `Bearer ${token}` } : undefined,
    body: formData, // ✨ Content-Type 직접 지정 금지 (브라우저가 boundary 포함 설정)
  });
  if (!res.ok) throw new Error("Upload failed");
  return res.json();
}
```

```js
// travel-log-form.js (요지)
import { postMultipart } from './api.js';

const state = { images: [] };

const $form = document.getElementById('logForm');
const $images = document.getElementById('images');
const $preview = document.getElementById('preview');

$images.addEventListener('change', (e) => {
  state.images = Array.from(e.target.files).slice(0, 5); // 최대 5장 제한
  $preview.innerHTML = '';
  state.images.forEach(file => {
    const url = URL.createObjectURL(file);
    const img = document.createElement('img');
    img.src = url; img.width = 120; img.height = 120;
    $preview.appendChild(img);
  });
});

$form.addEventListener('submit', async (e) => {
  e.preventDefault();
  const fd = new FormData();
  // JSON payload 분리
  const data = {
    title: $form.title.value,
    content: $form.content.value,
    rating: Number($form.rating.value || 0),
    tagIds: []
  };
  fd.append('data', new Blob([JSON.stringify(data)], { type: 'application/json' }));
  fd.append('tripId', $form.tripId.value);
  state.images.forEach(f => fd.append('images', f));

  const res = await postMultipart('/api/travel-logs', fd, localStorage.getItem('token'));
  console.log('created id:', res.data);
});
```

---

## 8. 로깅 전략

* 파일 업로드: **단계 로그**(수신 → 검증 → 저장경로 → 결과 URL)
* 도메인 검증: userId, tripId, dto 주요 필드 **샘플링 로그**만 남김(민감정보 제외)
* 에러 시 ErrorCode, traceId(요청 ID) 같이 출력하면 운영 디버깅이 편리

```java
@Slf4j
public class FileStorageService {
    public String storeImage(MultipartFile f) {
        log.debug("[FILE] name={}, size={}B, type={}", f.getOriginalFilename(), f.getSize(), f.getContentType());
        // ... 저장 로직
    }
}
```

---

## 9. 보안 설정 체크

```java
// SecurityConfig (요지)
.authorizeHttpRequests(auth -> auth
    .requestMatchers("/uploads/**").permitAll()
    .requestMatchers(HttpMethod.POST, "/api/travel-logs").authenticated()
    .anyRequest().permitAll()
)
```

* 정적 자원(`/uploads/**`) 공개, 생성 API는 인증 필요.

---

## 10. 테스트 전략 (TDD 관점)

* **Service 단위 테스트**

  * 정상 플로우: 사용자/여행 존재, 3장 업로드, 태그 2개 → 로그/사진/태그 매핑 저장 검증
  * 경계값: 5장 업로드 OK, 6장 업로드 에러(`FILE_UPLOAD_LIMIT_EXCEEDED`)
  * 이상케이스: 허용되지 않은 확장자 → `FILE_TYPE_NOT_ALLOWED`
* **Controller 통합 테스트 (MockMvc)**

  * `MockMultipartFile`로 이미지 2개, `@RequestPart("data")` JSON 전송
  * 응답 200/201, Location/ID 확인
* **QueryDSL 리포지토리 테스트**

  * 태그 필터/기간 필터/페이지네이션 검증, 통계(topTags) 정합성 확인

> 팁: 파일 테스트는 temp 디렉토리 격리 사용. 저장 후 삭제(cleanup) 훅 작성.

---

## 11. 리팩토링 포인트(주석 가이드)

* **도메인 행위 메서드**: `TravelLog.attachTags(tags)` 내부에서 중복 제거/유효성 처리 → 서비스 로직 가벼워짐
* **파일 저장 추상화**: `FileStorageService`(인터페이스) ← `LocalFileStorageService`, `S3FileStorageService` 교체 주입
* **DTO 검증 규칙**: 빈번한 규칙은 `@Valid` + 커스텀 어노테이션으로 이동 (`@RatingRange` 등)
* **정렬/썸네일**: `TravelPhoto`에 `orderIndex` 보장(Unique 제약은 코드 레벨 방지)
* **BaseTimeEntity**: 생성/수정시각 상속으로 중복 제거

---

## 12. PR 체크리스트

* [ ] 멀티파트 전송 시 프론트에서 `Content-Type` 수동 지정 금지
* [ ] 이미지 5장 제한/허용 확장자 검증 동작
* [ ] `/uploads/**` 리소스 매핑 정상 동작
* [ ] 예외 발생 시 표준 응답 포맷 유지(ErrorCode)
* [ ] QueryDSL 조회/통계 테스트 통과
* [ ] 민감 로그 없음(파일명만, 사용자 PII 제거)

---
* 파일 저장소 **S3 전환** 실습 (인터페이스 교체 주입)
* 통계 대시보드(태그 사용량, 지출 합계/평균, 평점 분포) 화면 설계
