# 25년 8월 17일


---


# 프론트엔드에서 **인증(Authentication)** 과 **인가(Authorization)**

오늘은 **React(SPA) 관점**에서 인증/인가를 정리했습니다. 백엔드/DB 보안과 조합될 때 가장 튼튼합니다.

---

## 0) 용어 한 장 요약

* **인증(Authentication)**: 사용자가 누구인지 증명 (로그인)
* **인가(Authorization)**: 인증된 사용자가 뭘 할 수 있는지 결정 (권한)
* **세션 기반**: 서버 세션 ID(쿠키)로 상태를 유지
* **토큰 기반**: JWT Access/Refresh 토큰으로 상태를 유지(주로 SPA)
* **RBAC**: 역할 기반 권한 (HOST, PARTICIPANT 등)
* **ABAC**: 속성 기반 권한 (작성자=나, 상태=APPROVED 등 조건)

> 비유(백화점 VIP 라운지)
>
> * 인증: 입구에서 신분증/멤버십 확인 (로그인)
> * 인가: 라운지·샤워실 등 이용 가능 구역 구분 (권한/역할)

---

## 1) 프론트엔드 인증 설계 관점

1. **세션-쿠키 방식**: 서버가 세션 저장, 클라이언트는 세션ID 쿠키 보유. CSRF 방어 필수.
2. **JWT 토큰 방식**: 클라이언트가 Access/Refresh 토큰으로 호출. XSS/탈취 방어가 핵심.
3. **OAuth2/OIDC (소셜/외부 IdP)**: SPA는 **Authorization Code + PKCE** 권장(Implicit은 지양).

### 기본 흐름(JWT 예)

1. 사용자가 로그인 폼 제출 → `/auth/login`
2. 서버: **Refresh 토큰을 HttpOnly·Secure·SameSite 쿠키로** 세팅, Access 토큰은 응답(JSON)
3. 클라이언트: Access 토큰을 **메모리**에 저장하고 Authorization 헤더로 API 호출
4. 만료 시 `/auth/refresh`로 새 Access 토큰 발급(쿠키의 Refresh 사용)
5. 로그아웃 시 서버 Refresh 무효화 + 클라이언트 상태 초기화

---

## 2) 토큰 저장 전략 (안전 우선)

* **Access 토큰**: **메모리 보관** 권장(페이지 새로고침 시 재발급). 필요하면 sessionStorage(임시) 사용.
* **Refresh 토큰**: **HttpOnly + Secure + SameSite=strict 쿠키**(JS로 접근 불가, 탈취 리스크↓)
* **localStorage 보관 지양**: 편하지만 XSS에 취약. 꼭 쓰면 CSP/입력정제 등 보강 필요.

---

## 3) 쿠키 인증 시 CSRF 방어

* **SameSite=Lax/Strict** 쿠키 사용
* **CSRF 토큰**: 서버가 랜덤 토큰 발급 → 프런트가 헤더(`X-CSRF-TOKEN`)로 동봉
* **더블 서브밋** 패턴: 쿠키의 CSRF 값과 헤더 값 모두 검증

---

## 4) CORS/자격증명(크로스 도메인)

* 프론트 요청: `fetch/axios`에 `credentials: 'include'`(axios는 `withCredentials: true`)
* 서버 응답 헤더: `Access-Control-Allow-Origin`(정확한 도메인), `Access-Control-Allow-Credentials: true`
* `*` 와 `Allow-Credentials: true`는 함께 쓰지 않기

---

## 5) React 기준 기본 코드 스캐폴드

### 5.1 Axios 인스턴스 + 인터셉터(Access 갱신 큐 포함)

```js
// api.js
import axios from 'axios';

export const api = axios.create({
  baseURL: '/api',
  withCredentials: true, // refresh 쿠키 전송
});

let accessToken = null;
let isRefreshing = false;
let queue = [];

export function setAccessToken(token) {
  accessToken = token;
}

function getCsrfFromMeta() {
  const el = document.querySelector('meta[name="csrf-token"]');
  return el?.getAttribute('content');
}

api.interceptors.request.use((config) => {
  if (accessToken) config.headers.Authorization = `Bearer ${accessToken}`;
  return config;
});

async function refreshToken() {
  const { data } = await api.post('/auth/refresh', null, {
    headers: { 'X-CSRF-TOKEN': getCsrfFromMeta() },
  });
  setAccessToken(data.accessToken);
  return data.accessToken;
}

api.interceptors.response.use(
  (res) => res,
  async (error) => {
    const original = error.config;
    if (error.response?.status === 401 && !original._retry) {
      if (isRefreshing) {
        return new Promise((resolve, reject) => {
          queue.push({ resolve, reject });
        }).then((token) => {
          original.headers.Authorization = `Bearer ${token}`;
          return api(original);
        });
      }
      original._retry = true;
      isRefreshing = true;
      try {
        const newToken = await refreshToken();
        queue.forEach((p) => p.resolve(newToken));
        queue = [];
        original.headers.Authorization = `Bearer ${newToken}`;
        return api(original);
      } catch (e) {
        queue.forEach((p) => p.reject(e));
        queue = [];
        return Promise.reject(e);
      } finally {
        isRefreshing = false;
      }
    }
    return Promise.reject(error);
  }
);
```

### 5.2 AuthContext — 상태/역할/권한 관리

```jsx
// AuthContext.jsx
import React, { createContext, useContext, useState, useEffect } from 'react';
import { api, setAccessToken } from './api';

const AuthContext = createContext(null);
export const useAuth = () => useContext(AuthContext);

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  // 앱 시작 시 세션 복구(쿠키의 refresh로 access 재발급)
  useEffect(() => {
    (async () => {
      try {
        const { data } = await api.post('/auth/refresh');
        setAccessToken(data.accessToken);
        setUser(data.user);
      } catch (_) {
        setUser(null);
      } finally {
        setLoading(false);
      }
    })();
  }, []);

  async function login(email, password) {
    const { data } = await api.post('/auth/login', { email, password });
    setAccessToken(data.accessToken); // refresh는 쿠키로 세팅됨
    setUser(data.user);
  }

  async function logout() {
    try { await api.post('/auth/logout'); } finally {
      setAccessToken(null);
      setUser(null);
    }
  }

  const value = { user, login, logout };
  return (
    <AuthContext.Provider value={value}>
      {loading ? <div>Loading...</div> : children}
    </AuthContext.Provider>
  );
}
```

### 5.3 라우트 가드(React Router v6)

```jsx
// RequireAuth.jsx
import { Navigate, useLocation } from 'react-router-dom';
import { useAuth } from './AuthContext';

export default function RequireAuth({ children, roles }) {
  const { user } = useAuth();
  const loc = useLocation();

  if (!user) return <Navigate to="/login" replace state={{ from: loc }} />;
  if (roles && !roles.some((r) => user.roles?.includes(r)))
    return <Navigate to="/403" replace />;

  return children;
}
```

```jsx
// App.jsx
<Route path="/meeting/:id" element={
  <RequireAuth roles={["HOST", "APPROVED_PARTICIPANT"]}>
    <MeetingDetail />
  </RequireAuth>
} />
```

---

## 6) 권한 모델링(Authorization)

### 6.1 RBAC 권한 맵 + 헬퍼

```js
// acl.js
export const PERMISSIONS = {
  POST_CREATE: ["HOST", "APPROVED_PARTICIPANT"],
  POST_EDIT:   ["HOST", "AUTHOR"],
  POST_DELETE: ["HOST", "AUTHOR"],
  POST_APPROVE:["HOST"],
};

export function can(user, perm, ctx = {}) {
  if (!user) return false;
  const allowedRoles = PERMISSIONS[perm] || [];
  const roleOk = user.roles?.some((r) => allowedRoles.includes(r));
  // ABAC 예: 자신이 쓴 글만 수정
  if (perm === 'POST_EDIT' && ctx.authorId) {
    return roleOk || user.id === ctx.authorId;
  }
  return roleOk;
}
```

```jsx
// 사용 예시
{can(user, 'POST_CREATE') && (
  <button onClick={onCreate}>글쓰기</button>
)}

{can(user, 'POST_EDIT', { authorId: post.authorId }) ? (
  <button onClick={onEdit}>수정</button>
) : null}
```

> **중요**: UI에서 숨기더라도 **백엔드에서 반드시 재검증**(권한 체크) 필요. 프론트 권한은 UX 편의일 뿐.

---

## 7) 멀티 탭/새로고침 고려

* Access 토큰은 메모리 보관 → 새로고침 시 `/auth/refresh`로 복구
* **BroadcastChannel** 또는 `storage` 이벤트로 탭 간 로그인/로그아웃 동기화

```js
const bc = new BroadcastChannel('auth');
function broadcast(type) { bc.postMessage({ type }); }
// 로그인/로그아웃 시 broadcast('login'|'logout') 호출 → 다른 탭에서 수신
```

---

## 8) 로그아웃

1. 서버 `/auth/logout`로 Refresh 무효화(화이트리스트/블랙리스트)
2. 클라이언트 Access 초기화, 사용자 상태 초기화, 민감 캐시 제거

---

## 9) 보안 체크리스트(프론트)

* [ ] **XSS 방어**: 입력값 정제, 위험한 HTML 삽입 금지, DOMPurify 등 사용
* [ ] **CSP 적용**: `Content-Security-Policy` 헤더로 인라인 스크립트 차단
* [ ] **토큰 최소화**: Access는 짧게, Refresh는 쿠키(HttpOnly)
* [ ] **에러 처리**: 401→재로그인/리프레시, 403→권한 없음 화면
* [ ] **CORS/쿠키 설정**: `withCredentials`, 정확한 Origin 허용
* [ ] **역할/권한**: UI 제어 + 서버 재검증(이중 체크)

---

## 10) 트러블슈팅 FAQ

* *401이 계속 발생* → 인터셉터 순환(무한 리프레시) 여부, `original._retry` 플래그 확인
* *새 테이블 접근 불가* → 서버 CORS·쿠키·도메인, 경로(/api) 일치 여부 확인
* *토큰이 사라짐* → 새로고침 시 Access는 메모리라 초기화됨 → `/auth/refresh`로 복구 로직 필요
* *다중 요청 동시 만료* → **리프레시 큐/뮤텍스** 구현으로 1회만 갱신

---

## 11) 미니 실습 과제

1. 위 `AuthProvider`, `api` 인터셉터, `RequireAuth`를 복사해 프로젝트에 연결
2. 백엔드 `/auth/login|refresh|logout` 엔드포인트와 합치기
3. 역할(HOST/APPROVED\_PARTICIPANT) 포함한 더미 유저로 라우트 가드 동작 확인

---

## 12) 한 줄 요약

> **SPA 인증은 “Access=메모리, Refresh=HttpOnly 쿠키, 인터셉터로 안전하게 갱신, 라우트/컴포넌트에서 권한 가드 + 서버 재검증”이 정석입니다.**
