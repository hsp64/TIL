# 25년 8월 6일

---

## Spring Security를 도입하여 비밀번호 암호화를 적용하고, 전역 예외 처리 및 표준 API 응답을 통해 안정성과 보안이 강화된 회원가입 및 로그인 기능을 구현

오늘은 사용자 인증의 핵심 기능인 회원가입과 로그인 기능을 구현하며, 안정적이고 확장성 있는 백엔드 시스템을 구축하는 방법에 대해 깊이 있게 학습했습니다. 주요 작업 내용은 기능 구현뿐만 아니라, 일관된 API 응답 형식 설계, 체계적인 예외 처리, 그리고 보안 강화를 위한 비밀번호 암호화까지 포함합니다.

### 1. 회원가입 기능 구현 및 API 응답 개선

**- 초기 기능 구현 (Controller, Service, DTO)**
사용자 회원가입 요청을 처리하기 위해 `AuthController`를 생성하고, 실제 비즈니스 로직을 담당할 `UserService`를 구현했습니다. 사용자로부터 회원가입 정보를 받아오기 위해 `SignUpRequest` DTO(Data Transfer Object)를 추가했으며, `@Valid` 어노테이션을 사용하여 각 필드(사용자명, 이메일, 비밀번호 등)에 대한 유효성 검증 규칙을 적용했습니다.

**- API 응답 형식의 표준화**
초기에는 단순히 성공/실패 여부만 반환했지만, 클라이언트와의 원활한 통신을 위해 응답 형식을 개선했습니다.

1.  **`UserResponse` DTO 추가**: 회원가입 성공 시 반환할 사용자 정보(ID, 사용자명, 이메일 등)를 담는 `UserResponse` DTO를 생성하여 민감한 정보(비밀번호 등)가 응답에 포함되지 않도록 했습니다.
2.  **`ApiResponse` 클래스 도입**: 모든 API 응답을 일관된 형식으로 제공하기 위해 제네릭 `ApiResponse<T>` 클래스를 구현했습니다. 이 클래스는 성공 여부, 메시지, 그리고 실제 데이터(T)를 포함하는 구조로, 클라이언트가 응답을 파싱하고 처리하기 용이하게 만듭니다.

### 2. 전역 예외 처리 시스템 구축

애플리케이션 전반에서 발생하는 예외를 중앙에서 효과적으로 관리하기 위해 전역 예외 처리 시스템을 구축했습니다.

**- 사용자 정의 예외 `BusinessException`**
'이미 존재하는 사용자명'이나 '중복된 이메일'과 같이 비즈니스 로직 상에서 발생하는 예측 가능한 예외들을 처리하기 위해 `BusinessException` 클래스를 정의했습니다. 이 예외는 특정 에러 상황을 나타내는 `ErrorCode`를 포함합니다.

**- `ErrorCode` 열거체**
`NOT_FOUND_USER`, `DUPLICATE_USERNAME` 등 애플리케이션에서 발생할 수 있는 모든 예외 상황을 `ErrorCode` 열거체로 정의했습니다. 각 코드는 HTTP 상태 코드와 구체적인 에러 메시지를 포함하여, 에러 정보를 체계적으로 관리할 수 있게 합니다.

**- `GlobalExceptionHandler`와 `ErrorResponse`**
`@RestControllerAdvice` 어노테이션을 사용하여 `GlobalExceptionHandler`를 구현했습니다. 이 핸들러는 다음과 같은 역할을 수행합니다.

*   `BusinessException`이 발생하면, 예외에 담긴 `ErrorCode`를 바탕으로 `ErrorResponse` DTO를 생성하여 클라이언트에 반환합니다.
*   `@Valid` 유효성 검증에 실패했을 때 발생하는 `MethodArgumentNotValidException`을 처리합니다. 각 필드의 유효성 검증 실패 정보를 `ValidationError` 객체로 만들어 `ErrorResponse`에 포함시켜, 클라이언트가 어떤 필드가 왜 잘못되었는지 명확히 알 수 있도록 했습니다.
*   `@JsonInclude(JsonInclude.Include.NON_NULL)` 설정을 `ErrorResponse`에 적용하여, 특정 에러 응답에서 값이 없는(null) 필드는 JSON 결과에서 제외되도록 하여 응답 메시지를 간결하게 유지했습니다.

### 3. Spring Security를 이용한 보안 강화

사용자의 비밀번호를 안전하게 저장하고 관리하기 위해 Spring Security 프레임워크를 도입했습니다.

**- 의존성 추가 및 기본 설정**
`build.gradle` 파일에 Spring Security 의존성을 추가했습니다. 이후, `SecurityConfig` 클래스를 생성하여 모든 요청을 기본적으로 허용하도록 설정하고, CSRF(Cross-Site Request Forgery) 보호 기능은 비활성화하여 API 서버 환경에 맞게 조정했습니다.

**- 비밀번호 암호화**
`PasswordEncoderConfig` 클래스를 만들어 `PasswordEncoder`의 구현체인 `BCryptPasswordEncoder`를 스프링 빈(Bean)으로 등록했습니다. `UserService`에서는 이 `PasswordEncoder`를 주입받아, 회원가입 시 사용자의 비밀번호를 해시(hash)하여 데이터베이스에 저장하도록 구현했습니다. 이로써 원본 비밀번호가 노출될 위험을 원천적으로 차단했습니다.

### 4. 로그인 기능 구현

회원가입 기능에 이어 사용자가 시스템에 자신을 인증할 수 있는 로그인 기능을 추가했습니다.

**- `LoginRequest` DTO 생성**
로그인에 필요한 사용자명(또는 이메일)과 비밀번호를 전달받기 위한 `LoginRequest` DTO를 생성하고, 각 필드에 유효성 검증 어노테이션을 적용했습니다.

**- 인증 로직 구현**
`UserService`에 `authenticate` 메서드를 추가했습니다. 이 메서드는 다음의 로직을 수행합니다.
1.  `LoginRequest`로 전달된 식별자(사용자명 또는 이메일)를 사용해 데이터베이스에서 사용자를 조회합니다. 사용자가 존재하지 않으면 `BusinessException`을 발생시킵니다.
2.  조회된 사용자의 암호화된 비밀번호와 `LoginRequest`로 받은 평문 비밀번호를 `PasswordEncoder`의 `matches()` 메서드를 통해 비교합니다.
3.  비밀번호가 일치하지 않으면 `BusinessException`을 발생시켜 로그인 실패를 알립니다.

**- 로그인 API 추가**
`AuthController`에 `/login` 엔드포인트를 처리하는 `login` 메서드를 구현했습니다. 이 메서드는 `LoginRequest`를 받아 `UserService`의 `authenticate` 메서드를 호출하고, 인증 성공 시 성공 응답을 반환합니다.
