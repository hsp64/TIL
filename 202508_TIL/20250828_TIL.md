# 25년 8월 28일


---


# sideEffect/useEffect Hook, useEffect 의존성 배열과 cleanup 함수

### 1. React Fragment

React의 Fragment는 일련의 자식 요소를 그룹화하되, 불필요한 DOM 노드를 추가하지 않고 컴포넌트를 반환하는 기능이다.

#### 왜 사용하는가?

React 컴포넌트는 기본적으로 단일 루트 노드만 반환해야 하는 규칙이 있다. Fragment를 사용하면 여러 자식 요소를 반환하면서도 불필요한 wrapper 엘리먼트를 DOM에 추가하지 않을 수 있다.

#### Fragment의 등장 배경

JSX는 Babel과 같은 트랜스파일러를 통해 JavaScript로 변환되며, 이 과정에서 `React.createElement()` 함수가 호출된다. 이 함수는 단일 노드만 반환하도록 설계되었기 때문에 Fragment가 필요하다.

#### 사용법

```jsx
import React, { Fragment } from 'react';

function Example() {
  return (
    <Fragment>
      <ChildA />
      <ChildB />
      <ChildC />
    </Fragment>
  );
}

// 또는 짧은 문법 사용
function Example() {
  return (
    <>
      <ChildA />
      <ChildB />
      <ChildC />
    </>
  );
}
```

### 2. React Portal

React의 Portal은 컴포넌트의 자식 요소를 부모 컴포넌트의 외부에 있는 DOM 노드로 렌더링하는 기능을 제공한다.

#### Portal의 필요성

Portal의 주요 사용 사례는 모달 대화상자, 툴팁, 드롭다운 메뉴 등의 UI 구성 요소를 렌더링하는 경우다. 이러한 요소들은 일반적으로 상위 레벨에서 렌더링되어야 하며, 가끔은 body에 직접 붙여야 하는 경우도 있다.

#### Portal 사용법

`ReactDOM.createPortal()` 함수를 사용하여 Portal을 생성한다. 이 함수는 두 개의 매개변수를 받는다: 렌더링할 React 자식과, 이 자식을 삽입할 DOM 요소.

```jsx
import ReactDOM from 'react-dom';

ReactDOM.createPortal(
  <BackDrop onConfirm={onConfirm} />,
  document.getElementById('backdrop-root')
)
```

#### index.html 설정

Portal을 사용하려면 먼저 `index.html` 파일에 Portal을 위한 DOM 요소를 추가해야 한다.

```html
<body>
  <div id="root"></div>
  <div id="backdrop-root"></div>
  <div id="overlay-root"></div>
</body>
```

#### Overlay와 Backdrop

- **Overlay**: 화면 전체를 덮는 요소로서, 특정 UI 요소를 강조하기 위해 사용
- **Backdrop**: 사용자가 특정 UI 요소 외부를 클릭했을 때 그 요소를 닫는 등의 인터랙션을 제공

### 3. React useRef

React의 `useRef`는 무언가를 "기억"하는 방법이며, 그 "기억"은 컴포넌트가 다시 렌더링될 때도 사라지지 않는다.

#### useRef 사용하기

```jsx
import React, { useRef } from 'react';

const MyComponent = () => {
  const myInputRef = useRef();

  const focusInput = () => {
    myInputRef.current.focus();
  };

  return (
    <div>
      <input ref={myInputRef} type="text" />
      <button onClick={focusInput}>Focus the input</button>
    </div>
  );
};
```

#### useRef는 무엇을 위해 사용되는가?

1. **DOM 요소에 직접 접근할 때**: DOM 요소에 직접 접근하여 그 요소의 속성을 읽거나 변경할 때 사용
2. **값을 기억하게 할 때**: 특정 값을 컴포넌트가 다시 렌더링될 때마다 유지하고 싶을 때 사용

중요한 점은 `useRef`의 `current` 값을 변경해도 컴포넌트가 리렌더링되지 않는다는 것이다.

### 4. Side Effect와 useEffect

#### Side Effect란?

Side Effect는 함수형 프로그래밍에서 말하는 용어로, 함수 내부에서 함수 외부에 영향을 미치는 것을 의미한다.

React 컴포넌트에서의 Side Effect들:
- 데이터를 가져오거나, 구독하거나, 수동으로 변경하는 등의 I/O 작업
- DOM을 직접적으로 조작하는 작업
- setTimeout이나 setInterval 같은 타이머를 설정하는 작업

#### 무한 루프 문제

```jsx
const App = () => {
  const [isLoggedIn, setIsLoggedIn] = useState(false);

  const storedUserLoggedInInformation = localStorage.getItem('isLoggedIn');

  if (storedUserLoggedInInformation === '1') {
    setIsLoggedIn(true); // 무한 루프 발생!
  }
  
  // ...
};
```

위 코드에서 무한 루프가 발생하는 이유는 `setIsLoggedIn` 함수가 컴포넌트의 상태를 변경하면서 컴포넌트가 다시 렌더링되고, 렌더링될 때마다 `localStorage`에서 로그인 정보를 가져와서 `setIsLoggedIn`을 호출하기 때문이다.

#### useEffect란?

`useEffect`는 React의 Hook 중 하나로, 컴포넌트의 라이프 사이클 내에서 Side Effect를 수행할 수 있다.

```jsx
useEffect(() => {
  // side effect를 수행하는 코드

  return () => {
    // cleanup 코드
    // 컴포넌트가 unmount되거나, 다음 effect가 실행되기 전에 수행
  };
}, [dependency1, dependency2]); // 의존성 배열
```

### 5. useEffect와 의존성 배열

useEffect Hook은 두 개의 인자를 받는다. 첫 번째 인자는 실행하려는 사이드 이펙트 함수이며, 두 번째 인자는 의존성 배열이다.

```jsx
useEffect(() => {
  console.log('useEffect call in Login.js');
  setFormIsValid(
    enteredEmail.includes('@') && enteredPassword.trim().length > 6
  );
}, [enteredEmail, enteredPassword]);
```

#### 의존성 배열의 역할

의존성 배열은 useEffect Hook이 실행되어야 하는 조건을 결정한다. 배열 안에 명시된 값들이 변할 때만, 사이드 이펙트 함수가 호출된다.

- **빈 배열 (`[]`)**: 컴포넌트가 처음 렌더링될 때만 한 번 실행
- **배열 생략**: 컴포넌트가 리렌더링될 때마다 실행
- **특정 값들**: 해당 값들이 변경될 때만 실행

#### 의존성 배열 결정 기준

1. **사이드 이펙트가 특정 상태 혹은 prop에 의존한다면** → 그 상태 혹은 prop는 의존성 배열에 포함
2. **사이드 이펙트가 한번만 실행되어야 한다면** → 빈 배열 (`[]`) 사용
3. **사이드 이펙트가 컴포넌트가 리렌더링될 때마다 실행되어야 한다면** → 의존성 배열 생략

### 6. useEffect Cleanup Function

`useEffect`의 반환값으로 cleanup function을 사용하여 컴포넌트가 언마운트되거나 업데이트되기 전에 특정 작업을 수행할 수 있다.

```jsx
useEffect(() => {
  const identifier = setTimeout(() => {
    console.log('입력값 검증 시작!');
    setFormIsValid(
      enteredEmail.includes('@') && enteredPassword.trim().length > 6
    );
  }, 500);

  return () => {
    console.log('cleanup!!');
    clearTimeout(identifier);
  };
}, [enteredEmail, enteredPassword]);
```

### 7. Debouncing과 Throttling

#### Debouncing

일정 시간 동안 동일한 이벤트가 계속 발생할 경우, 마지막 이벤트가 발생한 후 일정 시간이 지난 후에만 실제 이벤트 처리를 수행하는 방법이다.

```jsx
import { debounce } from 'lodash';

function SearchInput({ onSearch }) {
  const handleSearch = debounce((value) => {
    onSearch(value);
  }, 300);

  return (
    <input
      type="text"
      onChange={(e) => handleSearch(e.target.value)}
    />
  );
}
```

#### Throttling

일정 시간 동안 이벤트가 여러 번 발생하더라도, 그 이벤트의 처리를 일정 시간 간격으로 제한하여 과도한 이벤트 처리를 방지하는 방법이다.

```jsx
import { throttle } from 'lodash';

window.addEventListener('scroll', throttle(() => {
  console.log('스크롤 이벤트 처리');
}, 300));
```

#### Debouncing vs Throttling

- **Debouncing**: 이벤트의 마지막 발생 시점 이후 일정 시간이 지나면 한 번만 이벤트 처리 수행 (주로 사용자 입력 검증에 사용)
- **Throttling**: 이벤트가 연속적으로 발생하더라도 일정 시간 간격으로 이벤트 처리 수행 (주로 스크롤이나 마우스 이동 이벤트에 사용)

## 핵심 정리

1. **Fragment**는 불필요한 DOM 노드 없이 여러 요소를 그룹화할 때 사용한다.
2. **Portal**은 모달이나 툴팁 같은 UI 요소를 DOM 계층 구조 외부로 렌더링할 때 사용한다.
3. **useRef**는 DOM 요소에 직접 접근하거나 리렌더링과 관계없이 값을 유지할 때 사용한다.
4. **useEffect**는 Side Effect를 처리하며, 의존성 배열로 실행 조건을 제어한다.
5. **Cleanup function**으로 메모리 누수를 방지하고 리소스를 정리한다.
6. **Debouncing과 Throttling**으로 성능을 최적화하고 불필요한 함수 호출을 줄인다.
