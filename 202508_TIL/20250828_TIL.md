# 25년 8월 28일


---


# sideEffect/useEffect Hook, useEffect 의존성 배열과 cleanup 함수, 타이머게임 프로젝트 코드분석

### 1. React Fragment

React의 Fragment는 일련의 자식 요소를 그룹화하되, 불필요한 DOM 노드를 추가하지 않고 컴포넌트를 반환하는 기능이다.

#### 왜 사용하는가?

React 컴포넌트는 기본적으로 단일 루트 노드만 반환해야 하는 규칙이 있다. Fragment를 사용하면 여러 자식 요소를 반환하면서도 불필요한 wrapper 엘리먼트를 DOM에 추가하지 않을 수 있다.

#### Fragment의 등장 배경

JSX는 Babel과 같은 트랜스파일러를 통해 JavaScript로 변환되며, 이 과정에서 `React.createElement()` 함수가 호출된다. 이 함수는 단일 노드만 반환하도록 설계되었기 때문에 Fragment가 필요하다.

#### 사용법

```jsx
import React, { Fragment } from 'react';

function Example() {
  return (
    <Fragment>
      <ChildA />
      <ChildB />
      <ChildC />
    </Fragment>
  );
}

// 또는 짧은 문법 사용
function Example() {
  return (
    <>
      <ChildA />
      <ChildB />
      <ChildC />
    </>
  );
}
```

### 2. React Portal

React의 Portal은 컴포넌트의 자식 요소를 부모 컴포넌트의 외부에 있는 DOM 노드로 렌더링하는 기능을 제공한다.

#### Portal의 필요성

Portal의 주요 사용 사례는 모달 대화상자, 툴팁, 드롭다운 메뉴 등의 UI 구성 요소를 렌더링하는 경우다. 이러한 요소들은 일반적으로 상위 레벨에서 렌더링되어야 하며, 가끔은 body에 직접 붙여야 하는 경우도 있다.

#### Portal 사용법

`ReactDOM.createPortal()` 함수를 사용하여 Portal을 생성한다. 이 함수는 두 개의 매개변수를 받는다: 렌더링할 React 자식과, 이 자식을 삽입할 DOM 요소.

```jsx
import ReactDOM from 'react-dom';

ReactDOM.createPortal(
  <BackDrop onConfirm={onConfirm} />,
  document.getElementById('backdrop-root')
)
```

#### index.html 설정

Portal을 사용하려면 먼저 `index.html` 파일에 Portal을 위한 DOM 요소를 추가해야 한다.

```html
<body>
  <div id="root"></div>
  <div id="backdrop-root"></div>
  <div id="overlay-root"></div>
</body>
```

#### Overlay와 Backdrop

- **Overlay**: 화면 전체를 덮는 요소로서, 특정 UI 요소를 강조하기 위해 사용
- **Backdrop**: 사용자가 특정 UI 요소 외부를 클릭했을 때 그 요소를 닫는 등의 인터랙션을 제공

### 3. React useRef

React의 `useRef`는 무언가를 "기억"하는 방법이며, 그 "기억"은 컴포넌트가 다시 렌더링될 때도 사라지지 않는다.

#### useRef 사용하기

```jsx
import React, { useRef } from 'react';

const MyComponent = () => {
  const myInputRef = useRef();

  const focusInput = () => {
    myInputRef.current.focus();
  };

  return (
    <div>
      <input ref={myInputRef} type="text" />
      <button onClick={focusInput}>Focus the input</button>
    </div>
  );
};
```

#### useRef는 무엇을 위해 사용되는가?

1. **DOM 요소에 직접 접근할 때**: DOM 요소에 직접 접근하여 그 요소의 속성을 읽거나 변경할 때 사용
2. **값을 기억하게 할 때**: 특정 값을 컴포넌트가 다시 렌더링될 때마다 유지하고 싶을 때 사용

중요한 점은 `useRef`의 `current` 값을 변경해도 컴포넌트가 리렌더링되지 않는다는 것이다.

### 4. Side Effect와 useEffect

#### Side Effect란?

Side Effect는 함수형 프로그래밍에서 말하는 용어로, 함수 내부에서 함수 외부에 영향을 미치는 것을 의미한다.

React 컴포넌트에서의 Side Effect들:
- 데이터를 가져오거나, 구독하거나, 수동으로 변경하는 등의 I/O 작업
- DOM을 직접적으로 조작하는 작업
- setTimeout이나 setInterval 같은 타이머를 설정하는 작업

#### 무한 루프 문제

```jsx
const App = () => {
  const [isLoggedIn, setIsLoggedIn] = useState(false);

  const storedUserLoggedInInformation = localStorage.getItem('isLoggedIn');

  if (storedUserLoggedInInformation === '1') {
    setIsLoggedIn(true); // 무한 루프 발생!
  }
  
  // ...
};
```

위 코드에서 무한 루프가 발생하는 이유는 `setIsLoggedIn` 함수가 컴포넌트의 상태를 변경하면서 컴포넌트가 다시 렌더링되고, 렌더링될 때마다 `localStorage`에서 로그인 정보를 가져와서 `setIsLoggedIn`을 호출하기 때문이다.

#### useEffect란?

`useEffect`는 React의 Hook 중 하나로, 컴포넌트의 라이프 사이클 내에서 Side Effect를 수행할 수 있다.

```jsx
useEffect(() => {
  // side effect를 수행하는 코드

  return () => {
    // cleanup 코드
    // 컴포넌트가 unmount되거나, 다음 effect가 실행되기 전에 수행
  };
}, [dependency1, dependency2]); // 의존성 배열
```

### 5. useEffect와 의존성 배열

useEffect Hook은 두 개의 인자를 받는다. 첫 번째 인자는 실행하려는 사이드 이펙트 함수이며, 두 번째 인자는 의존성 배열이다.

```jsx
useEffect(() => {
  console.log('useEffect call in Login.js');
  setFormIsValid(
    enteredEmail.includes('@') && enteredPassword.trim().length > 6
  );
}, [enteredEmail, enteredPassword]);
```

#### 의존성 배열의 역할

의존성 배열은 useEffect Hook이 실행되어야 하는 조건을 결정한다. 배열 안에 명시된 값들이 변할 때만, 사이드 이펙트 함수가 호출된다.

- **빈 배열 (`[]`)**: 컴포넌트가 처음 렌더링될 때만 한 번 실행
- **배열 생략**: 컴포넌트가 리렌더링될 때마다 실행
- **특정 값들**: 해당 값들이 변경될 때만 실행

#### 의존성 배열 결정 기준

1. **사이드 이펙트가 특정 상태 혹은 prop에 의존한다면** → 그 상태 혹은 prop는 의존성 배열에 포함
2. **사이드 이펙트가 한번만 실행되어야 한다면** → 빈 배열 (`[]`) 사용
3. **사이드 이펙트가 컴포넌트가 리렌더링될 때마다 실행되어야 한다면** → 의존성 배열 생략

### 6. useEffect Cleanup Function

`useEffect`의 반환값으로 cleanup function을 사용하여 컴포넌트가 언마운트되거나 업데이트되기 전에 특정 작업을 수행할 수 있다.

```jsx
useEffect(() => {
  const identifier = setTimeout(() => {
    console.log('입력값 검증 시작!');
    setFormIsValid(
      enteredEmail.includes('@') && enteredPassword.trim().length > 6
    );
  }, 500);

  return () => {
    console.log('cleanup!!');
    clearTimeout(identifier);
  };
}, [enteredEmail, enteredPassword]);
```

### 7. Debouncing과 Throttling

#### Debouncing

일정 시간 동안 동일한 이벤트가 계속 발생할 경우, 마지막 이벤트가 발생한 후 일정 시간이 지난 후에만 실제 이벤트 처리를 수행하는 방법이다.

```jsx
import { debounce } from 'lodash';

function SearchInput({ onSearch }) {
  const handleSearch = debounce((value) => {
    onSearch(value);
  }, 300);

  return (
    <input
      type="text"
      onChange={(e) => handleSearch(e.target.value)}
    />
  );
}
```

#### Throttling

일정 시간 동안 이벤트가 여러 번 발생하더라도, 그 이벤트의 처리를 일정 시간 간격으로 제한하여 과도한 이벤트 처리를 방지하는 방법이다.

```jsx
import { throttle } from 'lodash';

window.addEventListener('scroll', throttle(() => {
  console.log('스크롤 이벤트 처리');
}, 300));
```

#### Debouncing vs Throttling

- **Debouncing**: 이벤트의 마지막 발생 시점 이후 일정 시간이 지나면 한 번만 이벤트 처리 수행 (주로 사용자 입력 검증에 사용)
- **Throttling**: 이벤트가 연속적으로 발생하더라도 일정 시간 간격으로 이벤트 처리 수행 (주로 스크롤이나 마우스 이동 이벤트에 사용)

## 핵심 정리

1. **Fragment**는 불필요한 DOM 노드 없이 여러 요소를 그룹화할 때 사용한다.
2. **Portal**은 모달이나 툴팁 같은 UI 요소를 DOM 계층 구조 외부로 렌더링할 때 사용한다.
3. **useRef**는 DOM 요소에 직접 접근하거나 리렌더링과 관계없이 값을 유지할 때 사용한다.
4. **useEffect**는 Side Effect를 처리하며, 의존성 배열로 실행 조건을 제어한다.
5. **Cleanup function**으로 메모리 누수를 방지하고 리소스를 정리한다.
6. **Debouncing과 Throttling**으로 성능을 최적화하고 불필요한 함수 호출을 줄인다.


# 타이머 게임 프로젝트

- useRef, forwardRef, Portal을 실제 프로젝트에서 활용하는 방법을 이해하고, 컴포넌트 간 상태 관리와 타이머 제어의 문제점 및 해결 방법을 학습한다.
- 사용자가 정해진 시간 내에 타이머를 멈춰야 하는 타이머 게임을 React로 구현한 프로젝트

## 주요 컴포넌트 분석

### 1. Player 컴포넌트

플레이어의 이름을 입력받는 컴포넌트로, useRef를 활용한 DOM 직접 조작의 예시다.

```jsx
const Player = () => {
    const nameRef = useRef();
    const [enteredName, setEnteredName] = useState('anonymous');

    const nameChangeHandler = e => {
        setEnteredName(nameRef.current.value);
        nameRef.current.value = '';  // DOM 직접 조작으로 입력창 클리어
    };

    return (
        <section id='player'>
            <h2>Welcome {enteredName}!</h2>
            <p>
                <input type='text' ref={nameRef} />
                <button onClick={nameChangeHandler}>Set Name</button>
            </p>
        </section>
    );
};
```

#### 핵심 학습 포인트
- useRef를 사용해 DOM 요소에 직접 접근
- input 값을 가져온 후 DOM 조작으로 입력창을 초기화
- 상태 변수와 ref를 조합한 하이브리드 방식

### 2. TimerChallenge 컴포넌트

타이머 게임의 핵심 로직을 담당하는 컴포넌트로, useRef를 통한 타이머 ID 관리가 핵심이다.

#### 전역 변수 문제와 해결책

```jsx
// 문제가 되는 코드 (전역 변수)
let timerId;

// 해결책 (useRef 사용)
const TimerChallenge = ({title, targetTime}) => {
    const timerId = useRef();  // 컴포넌트별로 독립적인 타이머 ID 관리
    const dialogRef = useRef();
    
    const [timeRemaining, setTimeRemaining] = useState(targetTime * 1000);
    
    // ...
};
```

#### 타이머 관리의 핵심 문제
주석에서 명확히 설명된 문제점:
1. **전역 변수 사용시**: 여러 컴포넌트가 하나의 timerId를 공유하여 타이머가 제대로 중지되지 않음
2. **지역 변수 사용시**: 리렌더링시 변수가 사라져버림
3. **상태 변수 사용시**: 상태 변경이 복잡해짐

#### 타이머 로직 구현

```jsx
// 타이머 시작
const handleStart = e => {
    timerId.current = setInterval(() => {
        setTimeRemaining((prevTime) => prevTime - 10);
    }, 10);
};

// 타이머 중지
const handleStop = e => {
    clearInterval(timerId.current);
    dialogRef.current.showModal();
};

// 게임 종료 조건 체크
if (timeRemaining <= 0) {
    clearInterval(timerId.current);
    dialogRef.current.showModal();
}
```

#### 동적 버튼 상태 관리

```jsx
const timerIsActive = timeRemaining > 0 && timeRemaining < targetTime * 1000;

<button onClick={timerIsActive ? handleStop : handleStart}>
    {timerIsActive ? 'Stop' : 'Start'} Challenge
</button>
```

### 3. ResultModal 컴포넌트

forwardRef를 사용한 모달 컴포넌트로, 부모 컴포넌트에서 모달을 제어할 수 있게 한다.

```jsx
const ResultModal = forwardRef(({ result, targetTime, timeRemaining, onReset }, ref) => {
    // 점수 계산 로직
    const formattedTime = (timeRemaining / 1000).toFixed(2);
    const score = Math.round((1 - timeRemaining / (targetTime * 1000)) * 100);

    return (
        <dialog ref={ref} className='result-modal'>
            <h2>Your {result}!</h2>
            {result === 'won' && <h2>Score: {score}</h2>}
            <p>
                The target time was <strong>{targetTime} seconds.</strong>
            </p>
            <p>
                You stopped the timer with <strong>{formattedTime} seconds left.</strong>
            </p>
            <form method='dialog'>
                <button onClick={onReset}>Close</button>
            </form>
        </dialog>
    );
});
```

#### forwardRef 사용 이유
- 부모 컴포넌트에서 `dialogRef.current.showModal()`로 모달을 직접 제어
- HTML dialog 요소의 네이티브 API 활용
- Portal과 함께 사용하면 더욱 강력한 모달 시스템 구축 가능

## 핵심 학습 내용

### 1. useRef의 실제 활용 사례

#### DOM 직접 조작
- input 요소 접근 및 값 조작
- 모달 다이얼로그 제어 (showModal 메서드 호출)

#### 값 유지 (변수 대용)
- 타이머 ID 저장 (리렌더링에 영향받지 않음)
- 리렌더링을 트리거하지 않는 값 저장

### 2. 컴포넌트 간 데이터 공유 문제

#### 전역 변수의 문제점
```jsx
// 5초 start -> 10초 start -> 10초 stop -> 5초 stop
// 순서대로 실행시 5초 타이머가 제대로 중지되지 않는 문제
```

#### 해결 방법
- useRef를 사용하여 각 컴포넌트 인스턴스별로 독립적인 값 관리
- 리렌더링에도 값이 유지되면서, 각 컴포넌트가 고유한 값을 가짐

### 3. 정밀한 타이머 구현

```jsx
// 10ms 간격으로 업데이트하여 정밀한 시간 측정
timerId.current = setInterval(() => {
    setTimeRemaining((prevTime) => prevTime - 10);
}, 10);

// 밀리초 단위 관리로 정확한 시간 계산
const [timeRemaining, setTimeRemaining] = useState(targetTime * 1000);
```

### 4. 조건부 렌더링과 상태 기반 UI

```jsx
// 타이머 상태에 따른 버튼 텍스트 및 기능 변경
const timerIsActive = timeRemaining > 0 && timeRemaining < targetTime * 1000;

// 게임 결과에 따른 조건부 렌더링
{result === 'won' && <h2>Score: {score}</h2>}
```

### 5. 점수 계산 로직

```jsx
// 남은 시간 비율을 활용한 점수 계산
const score = Math.round((1 - timeRemaining / (targetTime * 1000)) * 100);

// 시간 포맷팅
const formattedTime = (timeRemaining / 1000).toFixed(2);
```

## 실제 개발에서 배운 점

### 1. 상태 관리 방법 선택 기준
- **useState**: UI에 영향을 주는 데이터
- **useRef**: 리렌더링과 무관하지만 유지해야 하는 데이터
- **전역 변수**: 여러 컴포넌트가 공유하는 경우 문제 발생 가능

### 2. 타이머 관리시 주의사항
- 메모리 누수 방지를 위한 clearInterval 호출
- 컴포넌트 언마운트시 cleanup 처리 필요
- 다중 타이머 인스턴스 관리시 각각 독립적인 ID 보장

### 3. HTML5 dialog 요소 활용
- 네이티브 모달 기능 활용
- showModal() 메서드로 프로그래밍 방식 제어
- CSS backdrop 스타일링 가능

## 개선 가능한 점

1. **useEffect cleanup**: 컴포넌트 언마운트시 타이머 정리
2. **커스텀 훅**: 타이머 로직을 재사용 가능한 훅으로 분리
3. **접근성**: 키보드 접근성, 스크린 리더 지원
4. **에러 처리**: 타이머 관련 예외 상황 처리

