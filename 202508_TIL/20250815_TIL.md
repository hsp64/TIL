# 25년 8월 16일

---

# 백엔드 인증/인가 (Spring Boot / JWT)



## 1) 오늘의 목표

* \*\*인증(Authentication)\*\*과 \*\*인가(Authorization)\*\*의 차이를 정확히 이해한다.
* 실무에서 흔히 쓰는 **JWT 기반 무상태(stateless) 인증** 흐름을 처음부터 끝까지 구현 가능한 수준으로 정리한다.
* **Spring Security**의 필터 체인, `AuthenticationManager`, `AuthenticationProvider`, `SecurityContext`의 역할을 명확히 파악한다.
* Access/Refresh 토큰, CORS/CSRF, 예외 처리, 테스트 전략까지 **끝단부터 끝단까지** 정리한다.

---

## 2) 핵심 개념 한눈에 보기

* **인증(Authentication)**: “너 누구야?”를 확인. 사용자의 **신원 확인** 단계.

  * 비유: **백화점 VIP 라운지** 입구에서 신분을 확인하는 것(멤버십 카드, 신분증).
* **인가(Authorization)**: “들어와서 **무엇을 할 수 있는지**”를 결정. 권한 검증 단계.

  * 비유: 라운지에 들어왔지만 **VIP 등급**에 따라 좌석/서비스 이용 범위가 다름.
* **주요 용어**

  * **Principal**: 인증된 사용자 식별 정보(예: username, userId).
  * **Credential**: 인증 수단(비밀번호, 토큰 등).
  * **Claim**: 토큰이 담고 있는 사실(예: userId, roles, 만료 시간 등).
* **세션/쿠키 vs 토큰(JWT)**

  * **세션/쿠키**: 서버 상태 필요(세션 저장소). 브라우저 친화, `HttpOnly` 쿠키로 XSS 방어 용이. 서버 확장 시 세션 공유 필요.
  * **JWT**: 서버 상태 불필요(무상태). 마이크로서비스/모바일 클라이언트 친화. 단, **토큰 유출 시 회수 어렵고** 만료/블랙리스트 전략 필요.

---

## 3) 아키텍처 선택 가이드

* **내부 서비스/어드민**: 세션-쿠키 + 서버 렌더링이 간단.
* **다중 클라이언트(SPA/모바일)**: **JWT(Access/Refresh)** 권장.
* **소셜 로그인**: OAuth2/OIDC(구글, 깃허브 등) + 내부 JWT 연동.

---

## 4) Spring Security 핵심 흐름

1. **요청 → 필터 체인(SecurityFilterChain)** 진입
2. **인증 필터**(예: `UsernamePasswordAuthenticationFilter` 또는 커스텀 `JwtAuthenticationFilter`)가 **Credential**을 확인
3. **AuthenticationManager → AuthenticationProvider**가 실제 인증 수행(비번 비교, 토큰 검증)
4. 성공 시 **SecurityContext**에 `Authentication` 저장 → 이후 인가 결정에서 사용
5. 실패 시 **AuthenticationEntryPoint**(401) 또는 **AccessDeniedHandler**(403)로 분기

> 요점: **인증은 한 번**(요청 단위), **인가(접근 결정)는 매 요청마다** 수행.

---

## 5) JWT 기반 구현 순서 (Step by Step)

### 5-1. 의존성 (Gradle 예시)

```gradle
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-security'
    implementation 'io.jsonwebtoken:jjwt-api:0.11.5'
    runtimeOnly    'io.jsonwebtoken:jjwt-impl:0.11.5'
    runtimeOnly    'io.jsonwebtoken:jjwt-jackson:0.11.5'
    implementation 'org.springframework.boot:spring-boot-starter-validation'

    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.springframework.security:spring-security-test'
}
```

### 5-2. User/Role 모델 설계

* **User**: `userId`, `email`, `password(BCrypt)`, `nickname`, `roles(Set<String> or Enum)`
* **Role/Authority**: `ROLE_HOST`, `ROLE_USER`, 필요 시 세분화된 `permission` 추가

```java
// 예시: 간단한 User 엔티티 (JPA)
@Entity
@Table(name = "user")
@Getter @NoArgsConstructor(access = AccessLevel.PROTECTED)
public class User {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long userId;

    @Column(nullable = false, unique = true)
    private String email;

    @Column(nullable = false)
    private String password; // BCrypt 해시

    @Column(nullable = false)
    private String nickname;

    @ElementCollection(fetch = FetchType.EAGER)
    @CollectionTable(name = "user_roles", joinColumns = @JoinColumn(name = "user_id"))
    @Column(name = "role")
    private Set<String> roles = new HashSet<>(); // ex) ["ROLE_USER", "ROLE_HOST"]

    @Builder
    private User(String email, String password, String nickname, Set<String> roles) {
        this.email = email;
        this.password = password;
        this.nickname = nickname;
        if (roles != null) this.roles = roles;
    }
}
```

### 5-3. PasswordEncoder & UserDetailsService

```java
@Service
@RequiredArgsConstructor
public class CustomUserDetailsService implements UserDetailsService {
    private final UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new UsernameNotFoundException("not found: " + email));
        return org.springframework.security.core.userdetails.User
                .withUsername(user.getEmail())
                .password(user.getPassword())
                .authorities(user.getRoles().toArray(String[]::new))
                .build();
    }
}
```

### 5-4. JWT 토큰 서비스

* Access: 짧게(예: 15분), Refresh: 길게(예: 7일) 권장.
* **Claim**에 `sub(email)`, `userId`, `roles`, `iat/exp` 포함.

```java
@Component
@RequiredArgsConstructor
public class JwtTokenService {
    @Value("${jwt.secret}") private String secret;
    @Value("${jwt.access-exp-minutes:15}") private long accessExpMinutes;
    @Value("${jwt.refresh-exp-days:7}") private long refreshExpDays;

    private Key key() { return Keys.hmacShaKeyFor(Decoders.BASE64.decode(secret)); }

    public String createAccessToken(Long userId, String email, Collection<String> roles) {
        Instant now = Instant.now();
        Instant exp = now.plus(accessExpMinutes, ChronoUnit.MINUTES);
        return Jwts.builder()
                .setSubject(email)
                .claim("uid", userId)
                .claim("roles", roles)
                .setIssuedAt(Date.from(now))
                .setExpiration(Date.from(exp))
                .signWith(key(), SignatureAlgorithm.HS256)
                .compact();
    }

    public String createRefreshToken(Long userId, String email) {
        Instant now = Instant.now();
        Instant exp = now.plus(refreshExpDays, ChronoUnit.DAYS);
        return Jwts.builder()
                .setSubject(email)
                .claim("uid", userId)
                .setIssuedAt(Date.from(now))
                .setExpiration(Date.from(exp))
                .signWith(key(), SignatureAlgorithm.HS256)
                .compact();
    }

    public Claims parse(String token) {
        return Jwts.parserBuilder().setSigningKey(key()).build()
                .parseClaimsJws(token).getBody();
    }
}
```

### 5-5. JwtAuthenticationFilter (OncePerRequestFilter)

* `Authorization: Bearer <token>`에서 토큰 추출
* 유효하면 `SecurityContext`에 `Authentication` 저장

```java
@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    private final JwtTokenService tokenService;
    private final CustomUserDetailsService userDetailsService;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
            throws ServletException, IOException {
        String header = request.getHeader("Authorization");
        if (header != null && header.startsWith("Bearer ")) {
            String token = header.substring(7);
            try {
                Claims claims = tokenService.parse(token);
                String email = claims.getSubject();
                UserDetails userDetails = userDetailsService.loadUserByUsername(email);
                UsernamePasswordAuthenticationToken auth = new UsernamePasswordAuthenticationToken(
                        userDetails, null, userDetails.getAuthorities());
                SecurityContextHolder.getContext().setAuthentication(auth);
            } catch (JwtException | UsernameNotFoundException e) {
                // 유효하지 않은 토큰 → 401 처리용 EntryPoint로 위임 (여기서 바로 종료하지 않음)
            }
        }
        chain.doFilter(request, response);
    }
}
```

### 5-6. SecurityConfig (무상태 + CORS/CSRF + 엔드포인트 권한)

```java
@Configuration
@EnableMethodSecurity // @PreAuthorize 사용
@RequiredArgsConstructor
public class SecurityConfig {
    private final JwtAuthenticationFilter jwtFilter;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
          .csrf(csrf -> csrf.disable()) // JWT + 헤더 인증이면 보통 비활성화
          .cors(Customizer.withDefaults())
          .sessionManagement(sm -> sm.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
          .authorizeHttpRequests(auth -> auth
              .requestMatchers("/api/auth/**", "/docs/**", "/health").permitAll()
              .requestMatchers(HttpMethod.GET, "/api/meetings/**").permitAll()
              .anyRequest().authenticated()
          )
          .exceptionHandling(ex -> ex
              .authenticationEntryPoint((req, res, e) -> {
                  res.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
                  res.setContentType("application/json");
                  res.getWriter().write("{\"message\":\"Unauthorized\"}");
              })
              .accessDeniedHandler((req, res, e) -> {
                  res.setStatus(HttpServletResponse.SC_FORBIDDEN);
                  res.setContentType("application/json");
                  res.getWriter().write("{\"message\":\"Forbidden\"}");
              })
          )
          .addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class);
        return http.build();
    }

    @Bean PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); }
}
```

### 5-7. 인증 API (회원가입/로그인/토큰 재발급)

```java
@RestController
@RequestMapping("/api/auth")
@RequiredArgsConstructor
public class AuthController {
    private final UserRepository userRepository;
    private final PasswordEncoder encoder;
    private final JwtTokenService tokenService;

    @PostMapping("/register")
    public ResponseEntity<?> register(@Valid @RequestBody RegisterRequest req){
        if (userRepository.existsByEmail(req.email())) {
            return ResponseEntity.status(HttpStatus.CONFLICT).body(Map.of("message","email exists"));
        }
        User user = User.builder()
                .email(req.email())
                .password(encoder.encode(req.password()))
                .nickname(req.nickname())
                .roles(Set.of("ROLE_USER"))
                .build();
        userRepository.save(user);
        return ResponseEntity.ok(Map.of("userId", user.getUserId()));
    }

    @PostMapping("/login")
    public ResponseEntity<LoginResponse> login(@Valid @RequestBody LoginRequest req){
        User user = userRepository.findByEmail(req.email())
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.UNAUTHORIZED));
        if (!encoder.matches(req.password(), user.getPassword())) {
            throw new ResponseStatusException(HttpStatus.UNAUTHORIZED);
        }
        String access = tokenService.createAccessToken(user.getUserId(), user.getEmail(), user.getRoles());
        String refresh = tokenService.createRefreshToken(user.getUserId(), user.getEmail());
        return ResponseEntity.ok(new LoginResponse(access, refresh));
    }

    @PostMapping("/token/refresh")
    public ResponseEntity<LoginResponse> refresh(@RequestBody RefreshRequest req){
        Claims c = tokenService.parse(req.refreshToken()); // 만료/위조 검사
        String access = tokenService.createAccessToken(((Number)c.get("uid")).longValue(), c.getSubject(), List.of("ROLE_USER"));
        String refresh = tokenService.createRefreshToken(((Number)c.get("uid")).longValue(), c.getSubject());
        return ResponseEntity.ok(new LoginResponse(access, refresh));
    }
}

public record RegisterRequest(@Email String email, @NotBlank String password, @NotBlank String nickname) {}
public record LoginRequest(@Email String email, @NotBlank String password) {}
public record RefreshRequest(String refreshToken) {}
public record LoginResponse(String accessToken, String refreshToken) {}
```

### 5-8. 컨트롤러에서 인증 사용자 사용하기

```java
@GetMapping("/me")
public Map<String, Object> me(@AuthenticationPrincipal UserDetails user){
    return Map.of("email", user.getUsername(), "roles", user.getAuthorities());
}
```

---

## 6) 인가 설계(도메인 규칙 반영)

> **BookJuk 예시**: “게시글/댓글 작성은 **HOST** 또는 **APPROVED 상태의 참여자**만 가능”

### 6-1. 서비스 레벨 검증

* 가장 명확하고 테스트 용이. DB 조회로 상태 검증 후 권한 없으면 `AccessDenied` 처리.

```java
@Service
@RequiredArgsConstructor
public class PostPermission {
    private final MeetingParticipantRepository mpRepo;

    public boolean canWritePost(Long meetingId, Long userId){
        // HOST 이거나 APPROVED 상태의 참가자인지 체크
        boolean isHost = mpRepo.existsByMeeting_IdAndParticipant_IdAndRole(meetingId, userId, ParticipantRole.HOST);
        boolean isApproved = mpRepo.existsByMeeting_IdAndParticipant_IdAndStatus(meetingId, userId, ParticipantStatus.APPROVED);
        return isHost || isApproved;
    }
}
```

### 6-2. @PreAuthorize로 선언적 인가

```java
@RestController
@RequiredArgsConstructor
@RequestMapping("/api/posts")
public class PostController {
    private final PostService postService;

    @PostMapping
    @PreAuthorize("@postPermission.canWritePost(#req.meetingId(), authentication.principal.username)")
    public ResponseEntity<?> create(@RequestBody CreatePostRequest req, @AuthenticationPrincipal UserDetails user){
        Long userId = postService.userIdOf(user.getUsername());
        postService.create(req.meetingId(), userId, req.title(), req.content());
        return ResponseEntity.status(HttpStatus.CREATED).build();
    }
}
```

> 주의: `authentication.principal`에서 **userId**가 필요하면, JWT에 `uid` 클레임을 넣고 커스텀 `UserPrincipal`을 만들어 쓰는 것이 깔끔하다.

---

## 7) 예외 처리 & 응답 통일

* 401(Unauthenticated): 로그인 필요/토큰 없음/유효하지 않음
* 403(Forbidden): 인증은 되었지만 권한 없음
* 글로벌 예외 처리(`@ControllerAdvice`)로 **일관된 JSON** 응답

```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<Map<String,Object>> handle(AccessDeniedException e){
        return ResponseEntity.status(HttpStatus.FORBIDDEN).body(Map.of("message","Forbidden"));
    }
    @ExceptionHandler({BadCredentialsException.class, UsernameNotFoundException.class})
    public ResponseEntity<Map<String,Object>> authFail(Exception e){
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(Map.of("message","Unauthorized"));
    }
}
```

---

## 8) 보안 체크리스트 (실무 베스트 프랙티스)

* **비밀번호 해시**: BCrypt(10\~14), 절대 평문 저장 금지
* **토큰 수명**: Access 짧게(10~~30분), Refresh 7~~14일
* **토큰 저장 위치**

  * 모바일/네이티브: 보안 스토리지 추천(Keychain/Keystore)
  * 웹: `Authorization` 헤더(가장 단순) 또는 **HttpOnly, Secure 쿠키 + CSRF 대응**
* **토큰 로테이션**: Refresh 교환 시 **새 Refresh 발급**, 이전 토큰 즉시 블랙리스트/리유즈 감지(서버 저장소 필요: DB/Redis)
* **로그아웃**: Refresh 저장소에서 무효화, Access는 짧은 TTL로 자연 만료
* **CORS**: 정확한 Origin/메서드/헤더 지정
* **시계 스큐**: 서버 시간 동기화(NTP), 토큰 파싱 시 약간의 clockSkew 허용
* **민감 정보 노출 금지**: 에러 메시지에 과한 정보 금지(“존재하지 않는 이메일” 대신 401)
* **HTTPS 강제**: 전 구간 TLS

---

## 9) 테스트 전략

* **단위 테스트**: `JwtTokenService`(만료/클레임/서명), 권한 유틸(도메인 규칙)
* **슬라이스 테스트**: `@WebMvcTest` + `spring-security-test`로 401/403 동작 검증
* **통합 테스트**: `@SpringBootTest` + MockMvc로 로그인→보호 API 접근 시나리오

```java
@Test
void 보호자원_미인증_요청시_401(){
    mockMvc.perform(get("/api/posts"))
           .andExpect(status().isUnauthorized());
}

@Test
void 토큰_있으면_200(){
    String access = tokenService.createAccessToken(1L, "a@a.com", List.of("ROLE_USER"));
    mockMvc.perform(get("/api/posts").header(HttpHeaders.AUTHORIZATION, "Bearer "+access))
           .andExpect(status().isOk());
}
```

---

## 10) 자주 겪는 문제 & 해결

* **401 vs 403 헷갈림**: 토큰 없음/유효하지 않음 → **401**. 인증은 됐는데 권한 부족 → **403**.
* **필터 순서 문제**: `addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class)` 순서 점검.
* **SecurityContext 비어있음**: 토큰 파싱 성공 후 `SecurityContextHolder.getContext().setAuthentication(auth)` 누락 체크.
* **CORS 프리플라이트(OPTIONS) 실패**: `CorsConfigurationSource` 또는 `spring.mvc.cors` 설정 추가.
* **쿠키 기반 JWT + CSRF**: 쿠키 사용 시 CSRF 고려 필요. 헤더 기반이면 보통 `csrf.disable()`.

---

## 11) HTTP 상호작용 예시

```
POST /api/auth/login
Content-Type: application/json

{ "email":"book@user.com", "password":"pass1234" }
```

```
200 OK
{
  "accessToken": "eyJhbGciOiJI...",
  "refreshToken": "eyJhbGciOiJI..."
}
```

```
GET /api/posts
Authorization: Bearer eyJhbGciOiJI...
```

---

## 12) 오늘 정리 (요약)

* 인증은 “신원 확인”, 인가는 “허용 범위 결정”.
* Spring Security는 **필터 → Provider → SecurityContext** 단계로 흘러간다.
* JWT 기반 인증은 **무상태**라 확장에 유리하지만 **유출/무효화 전략**이 중요하다.
* 실무에서는 **권한 규칙을 서비스 계층에서 DB 조회로 검증**하고, 필요 시 `@PreAuthorize`로 선언적 보완.

---

## 13) 내일 할 일

* `UserPrincipal` 커스텀(이메일/유저ID/닉네임 보유) 및 JWT `uid` 클레임 연동
* Refresh 저장소(예: Redis) + **토큰 로테이션 & 재사용 감지** 구현
* `@ControllerAdvice` 기반 **에러 응답 포맷** 일원화
* `spring-security-test`로 401/403 E2E 테스트 추가
