# 25년 8월 25일

---

# React 기초

## React와 React Component

### React.js 개요
- Facebook의 소프트웨어 엔지니어 Jordan Walke가 개발
- 2013년 오픈 소스로 공개
- 복잡한 사용자 인터페이스를 효과적으로 관리하기 위해 등장

### React.js vs Vanilla JS 주요 차이점

#### 1. Component-Based Architecture
- UI를 독립적이고 재사용 가능한 부분으로 분할
- 코드 재사용성 향상 및 유지보수 용이성 제공

```jsx
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}

function App() {
  return (
    <div>
      <Welcome name="Alice" />
      <Welcome name="Bob" />
    </div>
  );
}
```

#### 2. Virtual DOM
- 브라우저 리렌더링 성능 향상
- 변화가 발생한 부분만 업데이트하여 성능 개선

#### 3. Declarative Approach
- UI가 어떤 모습이어야 하는지만 선언
- 업데이트 과정에 대한 걱정 불필요

#### 4. Strong Ecosystem and Community Support
- 풍부한 라이브러리와 도구
- 활발한 커뮤니티 지원

## React 컴포넌트

### 컴포넌트의 종류

#### 함수 컴포넌트
- 가장 간단한 형태의 React 컴포넌트
- JavaScript 함수로 구현
- props를 매개변수로 받고 React 요소 반환

```jsx
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}
```

#### 클래스 컴포넌트
- ES6 클래스를 활용하여 정의
- 라이프사이클 메서드와 상태 관리 기능 제공

```jsx
class Welcome extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
```

### Props와 State
- **Props**: 부모 컴포넌트에서 자식 컴포넌트로 전달되는 읽기 전용 데이터
- **State**: 컴포넌트 내부 상태를 관리하는 변경 가능한 데이터

### React 컴포넌트의 장점
- 재사용성: 한 번 정의하면 여러 곳에서 재사용 가능
- 분리: 각 컴포넌트는 독립적이므로 코드 모듈화
- 관리: 복잡한 UI를 작은 부분으로 분리하여 개발 및 유지보수 용이

## 개발 환경 설정

### 1. Node.js 설치
- JavaScript 런타임 환경
- npm(Node Package Manager) 포함
- 공식 웹사이트에서 LTS 버전 다운로드
- 설치 확인: `node -v`

### 2. Vite를 사용한 React 프로젝트 생성
```bash
npm create vite@latest my-vite-app
cd my-vite-app
npm install
npm run dev
```

### 3. 프로젝트 구조
```
my-vite-app
├── public/             # 정적 파일
├── src/                # 소스 코드
│   ├── App.jsx         # React 메인 컴포넌트
│   ├── index.css       # 전역 스타일
│   └── main.jsx        # ReactDOM 렌더링 엔트리
├── .gitignore          # Git 무시 파일
├── index.html          # HTML 템플릿
├── package.json        # 프로젝트 설정 및 의존성
├── vite.config.js      # Vite 설정 파일
└── node_modules/       # 설치된 패키지
```

## JSX (JavaScript XML)

### JSX 개념
- JavaScript의 확장 문법
- React 요소를 생성
- HTML과 비슷하지만 JavaScript에 근접

```jsx
const element = <h1>Hello, world!</h1>;
```

### JSX 변환 과정
Babel을 통해 일반 JavaScript로 변환:
```jsx
// JSX
const element = <h1>Hello, world!</h1>;

// 변환된 JavaScript
const element = React.createElement(
  "h1",
  null,
  "Hello, world!"
);
```

### React의 작동 방식
- Virtual DOM 사용
- 이전 Virtual DOM과 비교하여 변화 부분만 실제 DOM에 반영
- 이 과정을 '재조정(reconciliation)'이라고 함

## 선언적 vs 명령적 프로그래밍

### 선언적 프로그래밍 (React 방식)
- '무엇을' 할 것인지에 대한 로직 기술
- 어떻게 목표에 도달할지는 신경쓰지 않음
- 코드 가독성 향상 및 디버깅 용이

```jsx
function Greeting({ isLogin }) {
  return isLogin ? <h1>Welcome back!</h1> : <h1>Please sign up.</h1>;
}
```

### 명령적 프로그래밍
- '어떻게' 작업을 수행할 것인지에 대한 로직 기술
- 코드의 상태와 상태 변화를 명시적으로 관리

```jsx
let greeting;
if (isLogin) {
  greeting = document.createElement('h1');
  greeting.textContent = 'Welcome back!';
} else {
  greeting = document.createElement('h1');
  greeting.textContent = 'Please sign up.';
}
```

## JSX 태그 작성 규칙

### 1. 하나의 루트 태그
- JSX 요소는 반드시 하나의 루트 태그만 존재해야 함
- 여러 태그는 하나의 루트 태그로 감싸야 함

```jsx
// 올바른 사용 예
function Hello() {
  return (
    <div>
      <h1>Hello</h1>
      <h1>World</h1>
    </div>
  );
}
```

### 2. 자기 닫힘 태그
- 모든 태그는 반드시 닫아야 함
- 자기 닫힘 태그도 `/`로 닫아야 함

```jsx
// 올바른 사용 예
const element = <img src="image.jpg" />;
```

## React Fragment

### Fragment 개념
- 복수의 자식 요소를 그룹화
- 불필요한 DOM 노드 추가하지 않음
- 세 가지 사용 방법 제공

```jsx
// React.Fragment 사용
function Example() {
  return (
    <React.Fragment>
      <ChildA />
      <ChildB />
      <ChildC />
    </React.Fragment>
  );
}

// 간단한 문법 사용
function Example() {
  return (
    <>
      <ChildA />
      <ChildB />
      <ChildC />
    </>
  );
}
```

## React Props

### Props 개념
- 속성(properties)을 의미
- 컴포넌트 간 데이터 전달 메커니즘
- 단방향 데이터 흐름 지원 (부모 → 자식)
- 모든 JavaScript 데이터 타입 전달 가능

### Props 사용 예제

#### 기본 사용법
```jsx
function Person(props) {
  return <h1>Hello, {props.name}. You are {props.age} years old.</h1>;
}

function App() {
  return <Person name="Sarah" age={28} />;
}
```

#### 배열 전달
```jsx
function List(props) {
  const items = props.items;
  return (
    <ul>
      {items.map((item, index) => (
        <li key={index}>{item}</li>
      ))}
    </ul>
  );
}

function App() {
  return <List items={['Apple', 'Banana', 'Cherry']} />;
}
```

#### 객체 전달
```jsx
function Profile(props) {
  const profile = props.profile;
  return (
    <div>
      <h1>{profile.name}</h1>
      <p>{profile.description}</p>
    </div>
  );
}

function App() {
  const profileData = {
    name: 'Sarah',
    description: 'A software developer'
  };

  return <Profile profile={profileData} />;
}
```

## props.children

### children 개념
- React의 특별한 prop
- 컴포넌트 태그 사이에 배치되는 모든 것을 포함
- 포함(Wrapper) 컴포넌트나 동적 구성에 사용

### children 사용 예제

#### 기본 사용법
```jsx
function Welcome(props) {
  return <div>{props.children}</div>;
}

function App() {
  return <Welcome>Hello, world!</Welcome>;
}
```

#### 포함 컴포넌트로 사용
```jsx
function Card(props) {
  return (
    <div style={{ border: '1px solid gray', margin: '10px', padding: '10px' }}>
      {props.children}
    </div>
  );
}

function App() {
  return (
    <Card>
      <h1>Hello, world!</h1>
      <p>Welcome to my application.</p>
    </Card>
  );
}
```

#### 동적 구성 예제
```jsx
function ToggleText(props) {
  const [isShown, setIsShown] = useState(false);
  return (
    <div onClick={() => setIsShown(!isShown)}>
      {isShown ? props.children : props.alternative}
    </div>
  );
}

function App() {
  return <ToggleText alternative="Click to show text">Hello, world!</ToggleText>;
}
```

## 이벤트 바인딩

### 바닐라 JavaScript vs React

#### 바닐라 JavaScript
```jsx
const button = document.querySelector('button');
button.addEventListener('click', function() {
    console.log('Button was clicked!');
});
```

#### React
```jsx
function MyButton() {
    const handleClick = () => {
        console.log('Button was clicked!');
    };

    return (
        <button onClick={handleClick}>
            Click me!
        </button>
    );
}
```

### React 이벤트 바인딩의 특징
- camelCase 이벤트 핸들러 이름 사용
- 문자열이 아닌 함수로 전달
- 함수형 컴포넌트에서 `this` 바인딩 걱정 불필요

### 이벤트 바인딩 방식

#### 외부에 선언한 후 바인딩
```jsx
function handleClick() {
    console.log('Button was clicked!');
}

function MyButton() {
    return (
        <button onClick={handleClick}>
            Click me!
        </button>
    );
}
```

#### 인라인 바인딩 (화살표 함수)
```jsx
function MyButton() {
    return (
        <button onClick={() => console.log('Button was clicked!')}>
            Click me!
        </button>
    );
}
```

## React State (상태)

### State 개념
- 컴포넌트 내부에서 관리되는 데이터
- 시간에 따라 변할 수 있는 값
- 상태 변경 시 컴포넌트 재렌더링 발생
- 사용자와 상호작용하는 동적 웹 애플리케이션에 필요

### 상태값의 불변성
- 상태값을 직접 수정하지 않음
- 새로운 상태값으로 이전 상태 대체
- React의 상태 변경 감지 및 올바른 업데이트를 위한 요구사항

### useState 훅

#### 기본 사용법
```jsx
import React, { useState } from 'react';

function MyComponent() {
    const [myState, setMyState] = useState(initialState);
    
    // 상태 변경
    setMyState(newValue);
}
```

#### 클릭 이벤트 처리 예시
```jsx
import React, { useState } from 'react';

function ClickCounter() {
    const [count, setCount] = useState(0);

    const handleClick = () => {
        setCount(count + 1);
    }

    return (
        <div>
            <button onClick={handleClick}>Click me!</button>
            <p>You clicked {count} times</p>
        </div>
    );
}
```

### 상태 관리 방식

#### 단일 값 상태
```jsx
const [enteredTitle, setEnteredTitle] = useState('');
const [enteredPrice, setEnteredPrice] = useState('');
const [enteredDate, setEnteredDate] = useState('');
```

#### 객체 상태
```jsx
const [userInput, setUserInput] = useState({
  enteredTitle: '',
  enteredPrice: '',
  enteredDate: ''
});
```

### 상태 업데이트와 불변성

#### 기본 객체 상태 업데이트
```jsx
const titleChangeHandler = (e) => {
  setUserInput({
    ...userInput,
    enteredTitle: e.target.value
  });
};
```

#### 함수형 업데이트 (권장)
```jsx
const titleChangeHandler = (e) => {
  setUserInput((prevUserInput) => ({
    ...prevUserInput,
    enteredTitle: e.target.value
  }));
};
```

### 상태 업데이트 주의사항
- React의 상태 업데이트는 비동기적으로 처리
- 여러 상태 업데이트가 동시에 발생하면 이전 상태 기반 업데이트가 올바르게 반영되지 않을 수 있음
- 함수형 업데이트를 사용하여 최신 상태 보장
- setter 함수를 통해서만 상태 변경 (직접 변경 금지)

### 상태 업데이트가 비동기인 이유
- 상태 업데이트 요청 직후 즉시 업데이트된 상태 가져올 수 없음
- 상태 업데이트와 컴포넌트 재렌더링 사이의 시간 동안 이전 상태 유지
- 함수형 업데이트를 통해 여러 상태 업데이트 간의 간섭 방지
