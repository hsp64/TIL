# 25년 8월 22일

---

# 🏆 SQLD 시험 대비 완전 정복 가이드

---

## 🎯 PART 1. 데이터 모델링의 이해

### 1장. 데이터 모델링 개요

#### 📚 핵심 개념
- **데이터 모델링**: 현실 세계의 데이터를 컴퓨터 시스템에서 관리할 수 있게 구조화하는 과정
- **3단계 스키마**: 외부(View) → 개념적(논리) → 내부(물리)
- **모델링 단계**: 개념적 → 논리적 → 물리적

#### 🔍 ERD 구성요소
1. **엔터티(Entity)**: 관리하려는 객체 (사각형)
2. **속성(Attribute)**: 엔터티의 특성 (타원)  
3. **관계(Relationship)**: 엔터티 간 연관성 (다이아몬드)

#### 💡 예제문제 1: 데이터 모델링 단계
**문제**: 다음 중 데이터 모델링 3단계를 순서대로 나열한 것은?
1) 물리적 → 논리적 → 개념적
2) 개념적 → 논리적 → 물리적 ✅
3) 논리적 → 개념적 → 물리적
4) 개념적 → 물리적 → 논리적

**해설**: 개념적(업무 요구사항) → 논리적(테이블 구조) → 물리적(실제 DBMS 구현) 순서

---

### 2장. 엔터티와 속성

#### 📊 엔터티 분류
- **유형별**: 유형(고객, 상품) vs 개념(주문, 계약) vs 사건(결제, 배송)
- **발생시점**: 기본(독립 존재) vs 중심(업무 중심) vs 행위(관계로 생성)

#### 🏷️ 속성 분류
- **특성별**: 기본속성, 설계속성, 파생속성
- **구성방식**: 단순(원자) vs 복합, 단일값 vs 다중값
- **필수성**: 필수 vs 선택

#### 💡 예제문제 2: 속성의 특성
**문제**: 다음 중 파생속성에 해당하는 것은?
1) 고객명
2) 주민번호  
3) 나이 ✅
4) 전화번호

**해설**: 나이는 주민번호나 생년월일로부터 계산되는 파생속성

---

### 3장. 관계와 식별자

#### 🔗 관계의 분류
- **연결정도**: 1:1, 1:M, M:N
- **선택성**: 필수(Mandatory) vs 선택(Optional)
- **종속성**: 식별관계 vs 비식별관계

#### 🗝️ 식별자(키) 완전 정리
```
슈퍼키(Super Key)
├── 후보키(Candidate Key) = 최소 슈퍼키
    ├── 기본키(Primary Key) = 선택된 후보키
    └── 대체키(Alternate Key) = 나머지 후보키
    
외래키(Foreign Key) = 다른 테이블 기본키 참조
대리키(Surrogate Key) = 인위적으로 생성한 키
```

#### 💡 예제문제 3: 키의 특성
**문제**: 다음 중 UNIQUE 제약조건에 대한 설명으로 옳은 것은?
1) NULL 값을 허용하지 않는다
2) NULL 값을 허용한다 ✅
3) 테이블당 하나만 생성 가능하다  
4) 자동으로 인덱스가 생성되지 않는다

**해설**: UNIQUE는 중복만 방지하고 NULL은 허용 (PRIMARY KEY는 NULL 불허)

---

### 4장. 정규화

#### 📐 정규화 단계별 상세
```sql
-- 비정규화 예시 테이블
학생번호 | 이름 | 수강과목 | 교수 | 교수연락처
001     | 김철수 | 수학,영어 | 이교수,박교수 | 010-1111,010-2222

-- 1NF: 원자값 (반복 그룹 제거)
학생번호 | 이름   | 수강과목 | 교수   | 교수연락처
001     | 김철수 | 수학     | 이교수 | 010-1111  
001     | 김철수 | 영어     | 박교수 | 010-2222

-- 2NF: 부분함수종속 제거 (기본키가 복합키일 때)
[학생] 테이블: 학생번호, 이름
[수강] 테이블: 학생번호, 수강과목, 교수, 교수연락처  

-- 3NF: 이행함수종속 제거
[학생] 테이블: 학생번호, 이름
[교수] 테이블: 교수, 교수연락처
[수강] 테이블: 학생번호, 수강과목, 교수
```

#### ⚡ 이상현상(Anomaly)
- **삽입이상**: 불필요한 데이터도 함께 입력
- **갱신이상**: 중복 데이터로 인한 불일치
- **삭제이상**: 필요한 데이터까지 같이 삭제

#### 💡 예제문제 4: 정규화
**문제**: 다음 중 제2정규형의 조건은?
1) 원자값을 가져야 한다
2) 부분함수종속을 제거해야 한다 ✅
3) 이행함수종속을 제거해야 한다
4) 결정자가 후보키여야 한다

**해설**: 2NF는 1NF + 부분함수종속 제거

---

## 🎯 PART 2. SQL 기본 및 활용

### 5장. SQL 기본 문법

#### 📝 DDL (Data Definition Language)
```sql
-- 테이블 생성
CREATE TABLE 학생 (
    학번 CHAR(10) PRIMARY KEY,
    이름 VARCHAR(20) NOT NULL,
    학과 VARCHAR(30),
    입학년도 NUMBER(4),
    CONSTRAINT fk_dept FOREIGN KEY(학과) REFERENCES 학과(학과명)
);

-- 테이블 수정
ALTER TABLE 학생 ADD 전화번호 VARCHAR(15);
ALTER TABLE 학생 MODIFY 이름 VARCHAR(30);
ALTER TABLE 학생 DROP COLUMN 전화번호;

-- 테이블 삭제
DROP TABLE 학생;           -- 구조+데이터 완전삭제
TRUNCATE TABLE 학생;       -- 데이터만 삭제(빠름)
DELETE FROM 학생;          -- 데이터 삭제(로그 남김)
```

#### 🔧 제약조건 완전 정리
```sql
-- PRIMARY KEY: 유일성 + NOT NULL
-- UNIQUE: 유일성만 (NULL 허용)
-- NOT NULL: NULL 금지
-- CHECK: 조건 검사
-- FOREIGN KEY: 참조 무결성
-- DEFAULT: 기본값

CREATE TABLE 직원 (
    직원번호 NUMBER PRIMARY KEY,
    이름 VARCHAR(20) NOT NULL,
    이메일 VARCHAR(50) UNIQUE,
    부서코드 CHAR(2) REFERENCES 부서(부서코드),
    급여 NUMBER CHECK(급여 > 0),
    입사일 DATE DEFAULT SYSDATE
);
```

#### 💡 예제문제 5: 제약조건
**문제**: 다음 중 UNIQUE 제약조건과 PRIMARY KEY 제약조건의 차이점은?
1) UNIQUE는 여러 개 생성 가능, PRIMARY KEY는 한 개만 가능 ✅
2) UNIQUE는 NULL 불허, PRIMARY KEY는 NULL 허용
3) 둘 다 자동으로 인덱스 생성 안함
4) 차이점이 없다

**해설**: UNIQUE는 여러 개 가능하고 NULL 허용, PK는 하나만 가능하고 NULL 불허

---

### 6장. 기본 SELECT와 함수

#### 🔍 SELECT 실행 순서 (외우기 필수!)
```
FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY
(F)   (W)     (G)        (H)      (S)      (O)
```

#### 📊 집계함수와 GROUP BY
```sql
-- 기본 집계함수
SELECT COUNT(*),          -- 전체 행 수 (NULL 포함)
       COUNT(컬럼),       -- NULL 제외한 행 수  
       SUM(급여),         -- 합계
       AVG(급여),         -- 평균
       MAX(급여),         -- 최대값
       MIN(급여)          -- 최소값
FROM 직원
WHERE 부서 = '영업'
GROUP BY 직급
HAVING COUNT(*) >= 2;
```

#### 💡 예제문제 6: 집계함수
**문제**: 다음 중 COUNT() 함수에 대한 설명으로 옳은 것은?
1) COUNT(*)와 COUNT(컬럼)은 항상 같은 결과
2) COUNT(컬럼)은 NULL 값을 포함한다
3) COUNT(컬럼)은 NULL 값을 제외한다 ✅  
4) COUNT는 문자형 컬럼에 사용할 수 없다

**해설**: COUNT(컬럼)은 NULL 제외, COUNT(*)는 NULL 포함

---

### 7장. WHERE절과 연산자

#### 🔍 비교연산자와 논리연산자
```sql
-- 기본 비교
WHERE 급여 >= 3000000
WHERE 이름 = '김철수'
WHERE 입사일 BETWEEN '2020-01-01' AND '2020-12-31'
WHERE 부서 IN ('영업', '마케팅', '개발')
WHERE 이름 LIKE '김%'        -- 김으로 시작
WHERE 이름 LIKE '%수'        -- 수로 끝
WHERE 이름 LIKE '김_수'      -- 김?수 (3글자)

-- NULL 처리 (중요!)
WHERE 전화번호 IS NULL
WHERE 전화번호 IS NOT NULL
WHERE 급여 IS NOT NULL AND 급여 > 0
```

#### ⚠️ NULL 관련 함정 (시험 단골!)
```sql
-- 틀린 예
WHERE 부서번호 = NULL           -- 항상 FALSE
WHERE 부서번호 != NULL          -- 항상 FALSE
WHERE 부서번호 NOT IN (10, 20, NULL)  -- 결과 없음!

-- 올바른 예  
WHERE 부서번호 IS NULL
WHERE 부서번호 IS NOT NULL
WHERE NOT EXISTS (SELECT 1 FROM ... WHERE 부서번호 = 테이블.부서번호)
```

#### 💡 예제문제 7: NULL 처리
**문제**: 다음 SQL의 결과는?
```sql
SELECT * FROM 직원 WHERE 부서번호 NOT IN (10, 20, NULL);
```
1) 부서번호가 10, 20, NULL이 아닌 모든 직원
2) 부서번호가 10, 20이 아닌 모든 직원  
3) 결과 없음 ✅
4) 오류 발생

**해설**: NOT IN에 NULL이 포함되면 결과가 없음 (Unknown 때문)

---

### 8장. JOIN 완전 정복

#### 🔗 JOIN 종류별 상세 설명
```sql
-- INNER JOIN (교집합)
SELECT a.이름, b.부서명
FROM 직원 a INNER JOIN 부서 b ON a.부서코드 = b.부서코드;

-- LEFT OUTER JOIN (왼쪽 기준)
SELECT a.이름, b.부서명  
FROM 직원 a LEFT JOIN 부서 b ON a.부서코드 = b.부서코드;
-- 모든 직원 + 매칭되는 부서 (부서 없으면 NULL)

-- RIGHT OUTER JOIN (오른쪽 기준)  
SELECT a.이름, b.부서명
FROM 직원 a RIGHT JOIN 부서 b ON a.부서코드 = b.부서코드;
-- 모든 부서 + 매칭되는 직원 (직원 없으면 NULL)

-- FULL OUTER JOIN (합집합)
SELECT a.이름, b.부서명
FROM 직원 a FULL OUTER JOIN 부서 b ON a.부서코드 = b.부서코드;

-- CROSS JOIN (카티션 곱)
SELECT a.이름, b.부서명 FROM 직원 a CROSS JOIN 부서 b;
```

#### ⚠️ OUTER JOIN 함정 (매우 중요!)
```sql
-- 잘못된 예 (OUTER JOIN 의미 상실)
SELECT a.*, b.컬럼
FROM A a LEFT JOIN B b ON a.id = b.id  
WHERE b.상태 = 'Y';  -- 여기서 NULL 행들이 제거됨!

-- 올바른 예
SELECT a.*, b.컬럼
FROM A a LEFT JOIN B b ON a.id = b.id AND b.상태 = 'Y';
```

#### 💡 예제문제 8: JOIN 결과
**문제**: A 테이블(3행), B 테이블(2행)에서 A LEFT JOIN B 했을 때 최대 결과 행 수는?
1) 2행
2) 3행 ✅
3) 5행  
4) 6행

**해설**: LEFT JOIN은 왼쪽 테이블 기준이므로 최소 3행 이상

---

### 9장. 서브쿼리 마스터

#### 📋 서브쿼리 분류
```sql
-- 1. 단일행 서브쿼리 (=, >, < 사용)
SELECT * FROM 직원 
WHERE 급여 > (SELECT AVG(급여) FROM 직원);

-- 2. 다중행 서브쿼리 (IN, ANY, ALL 사용)
SELECT * FROM 직원
WHERE 부서코드 IN (SELECT 부서코드 FROM 부서 WHERE 지역 = '서울');

-- 3. 다중컬럼 서브쿼리
SELECT * FROM 직원  
WHERE (부서코드, 직급) IN (SELECT 부서코드, 직급 FROM 임원);

-- 4. 상관 서브쿼리 (외부 쿼리 값 참조)
SELECT * FROM 직원 a
WHERE 급여 > (SELECT AVG(급여) FROM 직원 b WHERE b.부서코드 = a.부서코드);
```

#### 🔍 EXISTS vs IN 비교
```sql
-- EXISTS (존재하면 TRUE, 효율적)
SELECT * FROM 고객 c
WHERE EXISTS (SELECT 1 FROM 주문 o WHERE o.고객번호 = c.고객번호);

-- IN (값 비교, NULL 주의)  
SELECT * FROM 고객
WHERE 고객번호 IN (SELECT 고객번호 FROM 주문);

-- NOT EXISTS (안전)
SELECT * FROM 고객 c  
WHERE NOT EXISTS (SELECT 1 FROM 주문 o WHERE o.고객번호 = c.고객번호);

-- NOT IN (NULL 문제!)
SELECT * FROM 고객
WHERE 고객번호 NOT IN (SELECT 고객번호 FROM 주문); -- 주문에 NULL있으면 결과없음
```

#### 💡 예제문제 9: 서브쿼리
**문제**: 다음 중 상관 서브쿼리의 특징은?
1) 메인 쿼리와 독립적으로 실행된다
2) 메인 쿼리의 값을 참조한다 ✅
3) 한 번만 실행된다
4) 다중행을 반환할 수 없다

**해설**: 상관 서브쿼리는 외부 쿼리의 각 행에 대해 실행되며 외부 값을 참조

---

### 10장. 집합 연산자

#### 🔢 집합 연산자 완전 정리
```sql
-- UNION (합집합, 중복 제거)
SELECT 부서코드 FROM 직원
UNION  
SELECT 부서코드 FROM 부서;

-- UNION ALL (합집합, 중복 포함, 빠름)
SELECT 부서코드 FROM 직원
UNION ALL
SELECT 부서코드 FROM 부서;

-- INTERSECT (교집합)
SELECT 부서코드 FROM 직원  
INTERSECT
SELECT 부서코드 FROM 부서;

-- MINUS/EXCEPT (차집합)
SELECT 부서코드 FROM 부서
MINUS
SELECT 부서코드 FROM 직원;  -- 직원이 없는 부서
```

#### 📏 집합 연산자 규칙
1. SELECT 항목 수와 데이터 타입 일치
2. ORDER BY는 마지막에만 사용
3. 컬럼명은 첫 번째 쿼리 기준

#### 💡 예제문제 10: 집합 연산
**문제**: UNION과 UNION ALL의 차이점은?
1) 성능은 동일하다
2) UNION은 중복 제거, UNION ALL은 중복 포함 ✅  
3) 결과는 항상 동일하다
4) UNION ALL은 정렬된다

**해설**: UNION은 중복 제거하므로 느리고, UNION ALL은 중복 포함하므로 빠름

---

### 11장. 윈도우 함수 (고득점 구간)

#### 🪟 순위 함수
```sql
SELECT 이름, 급여,
       ROW_NUMBER() OVER(ORDER BY 급여 DESC) AS 행번호,  -- 1,2,3,4
       RANK() OVER(ORDER BY 급여 DESC) AS 순위,         -- 1,2,2,4  
       DENSE_RANK() OVER(ORDER BY 급여 DESC) AS 밀집순위 -- 1,2,2,3
FROM 직원;
```

#### 📊 집계 윈도우 함수
```sql
SELECT 이름, 부서, 급여,
       -- 부서별 급여 합계
       SUM(급여) OVER(PARTITION BY 부서) AS 부서합계,
       -- 누적 합계  
       SUM(급여) OVER(ORDER BY 입사일 
         ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS 누적합계,
       -- 이동 평균 (현재 포함 앞뒤 1개씩)
       AVG(급여) OVER(ORDER BY 입사일
         ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS 이동평균
FROM 직원;
```

#### 🔄 행 순서 함수
```sql
SELECT 이름, 급여,
       LAG(급여, 1) OVER(ORDER BY 입사일) AS 이전급여,    -- 1행 이전
       LEAD(급여, 1) OVER(ORDER BY 입사일) AS 다음급여,   -- 1행 이후
       FIRST_VALUE(급여) OVER(ORDER BY 입사일) AS 첫급여,
       LAST_VALUE(급여) OVER(ORDER BY 입사일 
         ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) AS 마지막급여
FROM 직원;
```

#### 💡 예제문제 11: 윈도우 함수
**문제**: 다음 SQL의 결과에서 급여가 같은 직원의 순위는?
```sql
SELECT 이름, RANK() OVER(ORDER BY 급여 DESC) FROM 직원;
```
급여: 김철수(500만), 이영희(400만), 박민수(400만), 최수진(300만)

1) 1, 2, 2, 4 ✅
2) 1, 2, 3, 4
3) 1, 2, 2, 3  
4) 오류 발생

**해설**: RANK()는 동점자에게 같은 순위를 주고 다음 순위는 건너뜀

---

### 12장. 고급 SQL 기법

#### 🔄 재귀 쿼리 (계층 구조)
```sql
-- Oracle CONNECT BY
SELECT 직원번호, 이름, 관리자번호, LEVEL
FROM 직원
START WITH 관리자번호 IS NULL  -- 최상위
CONNECT BY PRIOR 직원번호 = 관리자번호  -- 부모-자식 관계
ORDER SIBLINGS BY 이름;

-- 표준 SQL (재귀 CTE)
WITH RECURSIVE 조직도 AS (
  -- 앵커 멤버 (시작점)
  SELECT 직원번호, 이름, 관리자번호, 1 as level
  FROM 직원 WHERE 관리자번호 IS NULL
  
  UNION ALL
  
  -- 재귀 멤버
  SELECT e.직원번호, e.이름, e.관리자번호, o.level + 1
  FROM 직원 e JOIN 조직도 o ON e.관리자번호 = o.직원번호
)
SELECT * FROM 조직도;
```

#### 🔄 PIVOT과 UNPIVOT
```sql
-- PIVOT (행 → 열)
SELECT *
FROM (SELECT 부서, 직급 FROM 직원) 
PIVOT (COUNT(*) FOR 직급 IN ('과장', '대리', '사원'));

-- 결과
-- 부서    과장  대리  사원
-- 영업     2    3    5
-- 개발     1    4    6

-- 조건부 집계로 PIVOT 구현
SELECT 부서,
       SUM(CASE WHEN 직급='과장' THEN 1 ELSE 0 END) AS 과장,
       SUM(CASE WHEN 직급='대리' THEN 1 ELSE 0 END) AS 대리,  
       SUM(CASE WHEN 직급='사원' THEN 1 ELSE 0 END) AS 사원
FROM 직원 GROUP BY 부서;
```

#### 💡 예제문제 12: CASE 문
**문제**: 다음 SQL의 결과에서 A등급 개수는?
```sql
SELECT 부서,
       SUM(CASE WHEN 등급='A' THEN 1 ELSE 0 END) as A등급
FROM 직원 GROUP BY 부서;
```
1) 각 부서별 A등급 직원 수 ✅
2) 전체 A등급 직원 수
3) 각 부서별 전체 직원 수
4) 오류 발생

**해설**: GROUP BY로 부서별로 묶고, CASE로 A등급만 카운트

---

## 🎯 PART 3. 관리 구문 및 성능

### 13장. DML과 트랜잭션

#### 📝 데이터 조작어 (DML)
```sql
-- INSERT
INSERT INTO 직원 (직원번호, 이름, 급여) VALUES (1001, '김철수', 5000000);
INSERT INTO 직원 SELECT * FROM 임시직원;  -- 대량 입력

-- UPDATE
UPDATE 직원 SET 급여 = 급여 * 1.1 WHERE 부서 = '영업';

-- DELETE  
DELETE FROM 직원 WHERE 퇴사일 IS NOT NULL;

-- MERGE (UPSERT)
MERGE INTO 직원 t USING 신규직원 s ON (t.직원번호 = s.직원번호)
WHEN MATCHED THEN UPDATE SET t.급여 = s.급여
WHEN NOT MATCHED THEN INSERT VALUES (s.직원번호, s.이름, s.급여);
```

#### 🔄 트랜잭션 제어어 (TCL)
```sql
-- 기본 명령어
BEGIN TRANSACTION;      -- 트랜잭션 시작
COMMIT;                -- 확정
ROLLBACK;              -- 취소
SAVEPOINT sp1;         -- 저장점
ROLLBACK TO sp1;       -- 저장점까지 롤백

-- 자동 커밋 설정
SET AUTOCOMMIT ON/OFF;
```

#### ⚖️ ACID 속성
- **원자성(Atomicity)**: 전부 성공 또는 전부 실패
- **일관성(Consistency)**: 데이터 무결성 유지  
- **고립성(Isolation)**: 동시 실행 결과 = 순차 실행 결과
- **지속성(Durability)**: 커밋된 결과는 영구 보존

#### 💡 예제문제 13: 트랜잭션
**문제**: 다음 중 트랜잭션의 ACID 특성에 해당하지 않는 것은?
1) Atomicity (원자성)
2) Consistency (일관성)  
3) Isolation (고립성)
4) Availability (가용성) ✅

**해설**: ACID는 Atomicity, Consistency, Isolation, Durability

---

### 14장. 동시성과 락

#### 🔒 락(Lock) 종류
```sql
-- 공유락(Shared Lock): 읽기 락
SELECT * FROM 직원 WHERE 직원번호 = 1001;

-- 배타락(Exclusive Lock): 쓰기 락  
UPDATE 직원 SET 급여 = 5500000 WHERE 직원번호 = 1001;

-- 의도락(Intent Lock): 상위 레벨 락 예약
-- 스키마락(Schema Lock): DDL 방지
```

#### 📊 격리 수준 (Isolation Level)
```sql
-- 격리수준별 이상현상
                    Dirty   Non-repeatable  Phantom
Read Uncommitted      O           O            O
Read Committed        X           O            O    ← Oracle 기본
Repeatable Read       X           X            O    ← MySQL 기본  
Serializable          X           X            X

-- 설정 방법
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

#### ⚠️ 이상현상 상세
```sql
-- 1. Dirty Read: 커밋 안된 데이터 읽기
-- 트랜잭션 A: UPDATE 직원 SET 급여=6000000 WHERE 직원번호=1; (미커밋)
-- 트랜잭션 B: SELECT 급여 FROM 직원 WHERE 직원번호=1; (6000000 읽음)
-- 트랜잭션 A: ROLLBACK; (실제로는 원래 값)

-- 2. Non-repeatable Read: 같은 쿼리 다른 결과
-- 트랜잭션 A: SELECT 급여 FROM 직원 WHERE 직원번호=1; (5000000)
-- 트랜잭션 B: UPDATE 직원 SET 급여=6000000 WHERE 직원번호=1; COMMIT;
-- 트랜잭션 A: SELECT 급여 FROM 직원 WHERE 직원번호=1; (6000000) ← 다름!

-- 3. Phantom Read: 범위 조회시 새로운 행 나타남
-- 트랜잭션 A: SELECT COUNT(*) FROM 직원 WHERE 급여 > 5000000; (3건)
-- 트랜잭션 B: INSERT INTO 직원 VALUES(1002, '이영희', 5500000); COMMIT;
-- 트랜잭션 A: SELECT COUNT(*) FROM 직원 WHERE 급여 > 5000000; (4건) ← 다름!
```

#### 💡 예제문제 14: 격리수준
**문제**: Read Committed 격리수준에서 발생 가능한 이상현상은?
1) Dirty Read만
2) Non-repeatable Read만  
3) Non-repeatable Read, Phantom Read ✅
4) 모든 이상현상

**해설**: Read Committed는 Dirty Read는 방지하지만 Non-repeatable, Phantom은 발생 가능

---

### 15장. 인덱스와 성능 최적화

#### 🗂️ 인덱스 종류
```sql
-- 클러스터형 인덱스 (PK에 자동 생성)
-- 데이터가 인덱스 순서로 물리적 정렬
CREATE CLUSTERED INDEX idx_emp_no ON 직원(직원번호);

-- 비클러스터형 인덱스 (일반 인덱스)  
-- 별도 구조로 데이터 위치 가리킴
CREATE INDEX idx_emp_name ON 직원(이름);
CREATE UNIQUE INDEX idx_emp_email ON 직원(이메일);

-- 복합 인덱스
CREATE INDEX idx_emp_dept_sal ON 직원(부서코드, 급여);

-- 함수 기반 인덱스
CREATE INDEX idx_upper_name ON 직원(UPPER(이름));
```

#### ⚡ 인덱스 사용 조건 (중요!)
```sql
-- ✅ 인덱스 사용 O
WHERE 컬럼 = '값'
WHERE 컬럼 > 100  
WHERE 컬럼 BETWEEN 100 AND 200
WHERE 컬럼 IN (1,2,3)
WHERE 컬럼 LIKE '김%'        -- 앞부분 고정
WHERE 컬럼 IS NULL          -- 일부 DBMS

-- ❌ 인덱스 사용 X  
WHERE UPPER(컬럼) = 'KIM'    -- 함수 사용
WHERE 컬럼 + 1 = 100         -- 연산 사용
WHERE 컬럼 LIKE '%김'        -- 앞부분 와일드카드
WHERE 컬럼 != '값'           -- 부정 조건
WHERE 컬럼 IS NOT NULL       -- 부정 조건
```

#### 📏 Left-most Rule (복합 인덱스)
```sql
-- 인덱스: (A, B, C)
WHERE A = 1                  -- ✅ 사용  
WHERE A = 1 AND B = 2        -- ✅ 사용
WHERE A = 1 AND B = 2 AND C = 3  -- ✅ 사용
WHERE A = 1 AND C = 3        -- ✅ A만 사용
WHERE B = 2                  -- ❌ 사용 안함
WHERE B = 2 AND C = 3        -- ❌ 사용 안함
WHERE C = 3                  -- ❌ 사용 안함
```

#### 💡 예제문제 15: 인덱스
**문제**: 복합 인덱스 (부서코드, 급여)가 있을 때 인덱스를 사용하지 않는 조건은?
1) WHERE 부서코드 = 'A01'
2) WHERE 부서코드 = 'A01' AND 급여 > 3000000
3) WHERE 급여 > 3000000 ✅
4) WHERE 부서코드 = 'A01' AND 급여 BETWEEN 3000000 AND 5000000

**해설**: 복합 인덱스는 첫 번째 컬럼이 있어야 사용 가능 (Left-most Rule)

---

### 16장. 뷰와 가상 테이블

#### 👁️ 뷰(View) 생성과 활용
```sql
-- 뷰 생성
CREATE VIEW v_직원정보 AS
SELECT 직원번호, 이름, 부서명, 급여등급
FROM 직원 a JOIN 부서 b ON a.부서코드 = b.부서코드
           JOIN 급여등급 c ON a.급여 BETWEEN c.최소급여 AND c.최대급여;

-- 뷰 사용
SELECT * FROM v_직원정보 WHERE 부서명 = '영업부';

-- 제약 조건
CREATE VIEW v_고급직원 AS  
SELECT * FROM 직원 WHERE 급여 >= 5000000
WITH CHECK OPTION;  -- 뷰 조건 위반하는 DML 방지

CREATE VIEW v_직원목록 AS
SELECT 직원번호, 이름, 부서코드 FROM 직원
WITH READ ONLY;     -- 읽기 전용
```

#### 🎯 뷰의 장단점
**장점:**
- 복잡한 쿼리 단순화
- 보안 (특정 컬럼만 노출)
- 데이터 독립성

**단점:**
- 성능 저하 가능
- 인덱스 직접 생성 불가

#### 💡 예제문제 16: 뷰
**문제**: WITH CHECK OPTION의 기능은?
1) 뷰를 읽기 전용으로 만든다
2) 뷰 정의 조건을 위반하는 DML을 방지한다 ✅
3) 뷰에 인덱스를 생성할 수 있게 한다  
4) 뷰의 성능을 향상시킨다

**해설**: WITH CHECK OPTION은 뷰의 WHERE 조건을 위반하는 INSERT/UPDATE를 방지

---

### 17장. 고급 최적화 기법

#### 🏃‍♂️ 조인 알고리즘
```sql
-- 1. Nested Loop Join
-- 작은 테이블을 기준으로 큰 테이블과 하나씩 비교
-- 소량 데이터 + 인덱스 있을 때 효율적
SELECT /*+ USE_NL(b) */ a.*, b.*
FROM 작은테이블 a, 큰테이블 b  
WHERE a.id = b.id;

-- 2. Hash Join  
-- 작은 테이블로 해시 테이블 생성 후 큰 테이블과 조인
-- 대량 데이터 + 등가 조인에 효율적
SELECT /*+ USE_HASH(a,b) */ a.*, b.*
FROM 테이블A a, 테이블B b
WHERE a.key = b.key;

-- 3. Sort Merge Join
-- 양쪽 테이블을 정렬 후 병합
-- 대량 데이터 + 비등가 조인에 사용
SELECT /*+ USE_MERGE(a,b) */ a.*, b.*  
FROM 테이블A a, 테이블B b
WHERE a.key >= b.key;
```

#### 📈 실행계획 읽기
```sql
-- Oracle
EXPLAIN PLAN FOR
SELECT * FROM 직원 WHERE 부서코드 = 'A01';
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- SQL Server
SET SHOWPLAN_ALL ON
SELECT * FROM 직원 WHERE 부서코드 = 'A01';

-- 주요 확인 사항
-- 1. 인덱스 사용 여부 (Index Scan vs Table Scan)
-- 2. 조인 방식 (Nested Loop, Hash, Merge)  
-- 3. 비용(Cost) 비교
-- 4. 카디널리티(예상 행 수)
```

#### 💡 예제문제 17: 조인 최적화
**문제**: 대량의 데이터에서 등가 조인할 때 가장 효율적인 조인 방식은?
1) Nested Loop Join
2) Hash Join ✅
3) Sort Merge Join
4) Cross Join

**해설**: 대량 데이터의 등가 조인에는 Hash Join이 가장 효율적

---

## 🎯 PART 4. 실전 문제 및 함정 포인트

### 18장. 절대 놓치면 안 되는 함정들

#### ⚠️ NULL 관련 함정 총정리
```sql
-- 함정 1: 산술 연산 + NULL = NULL
SELECT 급여 + 상여금 FROM 직원;  -- 상여금이 NULL이면 결과도 NULL

-- 함정 2: 집계함수와 NULL
SELECT COUNT(*) FROM 직원;       -- 5 (NULL 포함)
SELECT COUNT(상여금) FROM 직원;   -- 3 (NULL 제외)

-- 함정 3: GROUP BY와 NULL
SELECT 부서코드, COUNT(*) FROM 직원 GROUP BY 부서코드;
-- NULL도 하나의 그룹으로 처리됨

-- 함정 4: ORDER BY와 NULL  
SELECT * FROM 직원 ORDER BY 상여금;
-- Oracle: NULL이 마지막 / SQL Server: NULL이 처음

-- 해결책: NULL 처리 함수
SELECT NVL(상여금, 0),           -- Oracle
       ISNULL(상여금, 0),        -- SQL Server  
       COALESCE(상여금, 0)       -- 표준 SQL
FROM 직원;
```

#### 🔄 OUTER JOIN 후 WHERE 조건 함정
```sql
-- ❌ 잘못된 예 (LEFT JOIN 의미 상실)
SELECT a.고객번호, a.고객명, b.주문번호
FROM 고객 a LEFT JOIN 주문 b ON a.고객번호 = b.고객번호  
WHERE b.주문상태 = '완료';  -- 주문 없는 고객 제외됨!

-- ✅ 올바른 예 1 (조건을 ON절로)
SELECT a.고객번호, a.고객명, b.주문번호  
FROM 고객 a LEFT JOIN 주문 b ON a.고객번호 = b.고객번호 AND b.주문상태 = '완료';

-- ✅ 올바른 예 2 (NULL 조건 추가)
SELECT a.고객번호, a.고객명, b.주문번호
FROM 고객 a LEFT JOIN 주문 b ON a.고객번호 = b.고객번호
WHERE b.주문상태 = '완료' OR b.주문상태 IS NULL;
```

#### 📊 GROUP BY 함정
```sql
-- ❌ 잘못된 예 (SELECT에 집계함수 아닌 컬럼)
SELECT 부서코드, 이름, COUNT(*)  -- 이름은 GROUP BY에 없음!
FROM 직원  
GROUP BY 부서코드;

-- ✅ 올바른 예
SELECT 부서코드, COUNT(*)
FROM 직원
GROUP BY 부서코드;

-- 또는 
SELECT 부서코드, 이름, COUNT(*)
FROM 직원
GROUP BY 부서코드, 이름;
```

#### 💡 예제문제 18: 함정 종합
**문제**: 다음 SQL의 문제점은?
```sql
SELECT a.*, b.주문금액
FROM 고객 a LEFT JOIN 주문 b ON a.고객번호 = b.고객번호
WHERE b.주문금액 >= 100000;
```
1) 문법 오류
2) LEFT JOIN의 의미가 사라진다 ✅
3) 성능이 느리다
4) 문제없다

**해설**: WHERE절에서 b.주문금액 조건으로 인해 주문 없는 고객(NULL)이 제외됨

---

### 19장. 고난도 SQL 패턴

#### 🏆 Top-N per Group (그룹별 상위 N개)
```sql
-- 부서별 급여 상위 2명  
SELECT *
FROM (
  SELECT 직원번호, 이름, 부서코드, 급여,
         ROW_NUMBER() OVER(PARTITION BY 부서코드 ORDER BY 급여 DESC) as rn
  FROM 직원
) ranked
WHERE rn <= 2;

-- 대안: RANK() 사용 (동점자 모두 포함)
SELECT *  
FROM (
  SELECT 직원번호, 이름, 부서코드, 급여,
         RANK() OVER(PARTITION BY 부서코드 ORDER BY 급여 DESC) as rnk
  FROM 직원
) ranked
WHERE rnk <= 2;
```

#### 📈 누적 집계 패턴
```sql
-- 월별 누적 매출
SELECT 년월, 매출액,
       SUM(매출액) OVER(ORDER BY 년월 
         ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS 누적매출
FROM 월별매출;

-- 이동 평균 (3개월)
SELECT 년월, 매출액,
       AVG(매출액) OVER(ORDER BY 년월
         ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS 이동평균3개월
FROM 월별매출;
```

#### 🔍 존재하지 않는 데이터 찾기 (Anti Join)
```sql
-- 주문하지 않은 고객 (EXISTS 사용 - 안전)
SELECT *
FROM 고객 c
WHERE NOT EXISTS (
  SELECT 1 FROM 주문 o WHERE o.고객번호 = c.고객번호
);

-- 주문하지 않은 고객 (LEFT JOIN 사용)
SELECT c.*
FROM 고객 c LEFT JOIN 주문 o ON c.고객번호 = o.고객번호
WHERE o.고객번호 IS NULL;

-- ❌ NOT IN 사용 시 주의 (NULL 문제)
SELECT * FROM 고객  
WHERE 고객번호 NOT IN (SELECT 고객번호 FROM 주문);  -- 주문에 NULL있으면 결과없음
```

#### 🔄 PIVOT 구현 (조건부 집계)
```sql
-- 부서별 직급 현황
SELECT 부서코드,
       SUM(CASE WHEN 직급='부장' THEN 1 ELSE 0 END) AS 부장,
       SUM(CASE WHEN 직급='과장' THEN 1 ELSE 0 END) AS 과장,  
       SUM(CASE WHEN 직급='대리' THEN 1 ELSE 0 END) AS 대리,
       SUM(CASE WHEN 직급='사원' THEN 1 ELSE 0 END) AS 사원
FROM 직원
GROUP BY 부서코드;

-- 월별 매출 추이  
SELECT 상품코드,
       SUM(CASE WHEN 월='01' THEN 매출액 ELSE 0 END) AS "1월",
       SUM(CASE WHEN 월='02' THEN 매출액 ELSE 0 END) AS "2월",
       SUM(CASE WHEN 월='03' THEN 매출액 ELSE 0 END) AS "3월"
FROM 매출
GROUP BY 상품코드;
```

#### 💡 예제문제 19: 고급 패턴
**문제**: 각 부서에서 급여가 가장 높은 직원을 조회하는 SQL은?
```sql
SELECT *
FROM 직원 a
WHERE 급여 = (
  SELECT MAX(급여) 
  FROM 직원 b 
  WHERE b.부서코드 = a.부서코드
);
```
이 쿼리의 특징은?
1) 일반 서브쿼리
2) 상관 서브쿼리 ✅  
3) 스칼라 서브쿼리
4) 인라인 뷰

**해설**: 외부 쿼리의 a.부서코드를 참조하는 상관 서브쿼리

---

### 20장. 문자열과 날짜 함수 활용

#### 📝 문자열 함수 실전 활용
```sql
-- 주민번호에서 성별 추출
SELECT 이름,
       CASE WHEN SUBSTR(주민번호, 7, 1) IN ('1','3') THEN '남성'
            WHEN SUBSTR(주민번호, 7, 1) IN ('2','4') THEN '여성'
            ELSE '불명' END AS 성별
FROM 회원;

-- 이메일 도메인 추출
SELECT 이메일, 
       SUBSTR(이메일, INSTR(이메일, '@') + 1) AS 도메인
FROM 회원;

-- 전화번호 형식 변환
SELECT CONCAT(CONCAT(SUBSTR(전화번호,1,3), '-'), 
              CONCAT(SUBSTR(전화번호,4,4), '-'),
              SUBSTR(전화번호,8,4)) AS 형식화된전화번호
FROM 회원;

-- 이름 마스킹 (개인정보 보호)
SELECT CONCAT(SUBSTR(이름,1,1), LPAD('*', LENGTH(이름)-1, '*')) AS 마스킹이름
FROM 회원;
```

#### 📅 날짜 함수 실전 활용
```sql
-- 나이 계산
SELECT 이름, 생년월일,
       TRUNC((SYSDATE - 생년월일) / 365.25) AS 나이
FROM 회원;

-- 근무년수 계산  
SELECT 이름, 입사일,
       TRUNC(MONTHS_BETWEEN(SYSDATE, 입사일) / 12) AS 근무년수
FROM 직원;

-- 분기별 집계
SELECT CASE WHEN TO_CHAR(주문일, 'MM') IN ('01','02','03') THEN '1분기'
            WHEN TO_CHAR(주문일, 'MM') IN ('04','05','06') THEN '2분기'  
            WHEN TO_CHAR(주문일, 'MM') IN ('07','08','09') THEN '3분기'
            ELSE '4분기' END AS 분기,
       SUM(주문금액) AS 분기별매출
FROM 주문
WHERE TO_CHAR(주문일, 'YYYY') = '2024'
GROUP BY CASE WHEN TO_CHAR(주문일, 'MM') IN ('01','02','03') THEN '1분기'
              WHEN TO_CHAR(주문일, 'MM') IN ('04','05','06') THEN '2분기'
              WHEN TO_CHAR(주문일, 'MM') IN ('07','08','09') THEN '3분기'  
              ELSE '4분기' END;

-- 요일별 매출 분석
SELECT TO_CHAR(주문일, 'DAY') AS 요일,
       COUNT(*) AS 주문건수,
       SUM(주문금액) AS 총매출
FROM 주문  
GROUP BY TO_CHAR(주문일, 'DAY')
ORDER BY TO_CHAR(주문일, 'D');  -- 일요일(1)부터 토요일(7)
```

#### 💡 예제문제 20: 함수 활용
**문제**: 다음 SQL의 결과는?
```sql
SELECT SUBSTR('HELLO', 2, 3) FROM DUAL;
```
1) HEL
2) ELL ✅
3) LLO  
4) EL

**해설**: SUBSTR(문자열, 시작위치, 길이) → 2번째부터 3글자 = 'ELL'

---

### 21장. 시험 최종 점검 리스트

#### ✅ 암기 필수 항목
1. **SELECT 실행 순서**: FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY
2. **정규화 단계**: 1NF(원자값) → 2NF(부분종속 제거) → 3NF(이행종속 제거) → BCNF
3. **윈도우 함수 순위**: ROW_NUMBER(1,2,3,4), RANK(1,2,2,4), DENSE_RANK(1,2,2,3)
4. **격리수준과 이상현상**: RU(더티O) < RC(논리피트O) < RR(팬텀O) < S(없음)
5. **인덱스 Left-most Rule**: (A,B,C) → A, A+B, A+B+C만 사용 가능

#### 🎯 시험장 체크포인트
1. **NULL 문제**: NOT IN, 산술연산, 비교연산 주의
2. **OUTER JOIN**: WHERE 조건으로 NULL 제거 주의  
3. **COUNT**: COUNT(*)는 NULL 포함, COUNT(컬럼)은 NULL 제외
4. **윈도우 함수**: PARTITION BY와 ORDER BY 순서 확인
5. **EXISTS vs IN**: NULL 안전성에서 EXISTS가 유리

#### 📊 마지막 실전 예제
```sql
-- 종합 문제: 부서별 급여 상위 2명, 급여 순위, 부서 평균과의 차이
SELECT 부서코드, 이름, 급여,
       RANK() OVER(PARTITION BY 부서코드 ORDER BY 급여 DESC) AS 부서내순위,
       급여 - AVG(급여) OVER(PARTITION BY 부서코드) AS 부서평균차이,
       CASE WHEN 급여 > AVG(급여) OVER(PARTITION BY 부서코드) 
            THEN '평균이상' ELSE '평균이하' END AS 급여등급
FROM 직원
WHERE 급여 IS NOT NULL
ORDER BY 부서코드, 급여 DESC;
```

---

## 🚀 시험 직전 벼락치기 30분 코스

### 🔥 핵심 암기 카드
```
1. SELECT 순서: F-W-G-H-S-O
2. 정규화: 1(원자) → 2(부분) → 3(이행) → BC(결정자=후보)  
3. 순위함수: ROW(1234) / RANK(1224) / DENSE(1223)
4. 격리수준: RU→RC→RR→S (이상현상 점점 감소)
5. NULL: NOT IN 조심, IS NULL 사용, COUNT(*) vs COUNT(컬럼)
6. OUTER JOIN: WHERE 조건 → ON 조건으로
7. 인덱스: LIKE '값%' 사용O, LIKE '%값' 사용X
8. EXISTS > IN (NULL 안전)
```

### ⚡ 마지막 확인 SQL
```sql
-- 1분 만에 확인할 핵심 패턴들
SELECT * FROM (SELECT *, ROW_NUMBER() OVER(ORDER BY col) rn FROM t) WHERE rn<=3;
SELECT * FROM a WHERE NOT EXISTS (SELECT 1 FROM b WHERE a.id=b.id);  
SELECT col, SUM(amt) OVER(ORDER BY date ROWS UNBOUNDED PRECEDING) FROM t;
SELECT COUNT(CASE WHEN grade='A' THEN 1 END) FROM emp;
```

---

## 🎊 최종 응원 메시지

**시험 직전 마음가짐:**
1. 😌 **침착하게**: 아는 문제부터 풀기
2. 🔍 **꼼꼼하게**: NULL, OUTER JOIN 함정 체크  
3. ⏰ **시간관리**: 1문제당 1-2분, 막히면 넘어가기
4. 💪 **자신감**: 충분히 준비했으니까 잘할 수 있어요!

**정말 합격하실 거예요! 지금까지 정리한 내용만 제대로 숙지하셨다면 충분합니다. 화이팅! 🔥🏆**
