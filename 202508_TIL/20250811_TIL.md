# 25년 8월 11일


---

# 데이터 모델링

## 1강: 데이터 모델의 이해

1과목에서는 무엇을, 어떻게 만들어야 하는지에 대한 '설계 철학'을 배웁니다. 바로 **데이터 모델링**의 세계입니다. 1과목은 4지선다형 객관식 문제 위주이므로, 개념을 정확히 이해하는 것이 무엇보다 중요합니다.

### 1. 모델링이란 무엇일까요? (추상화, 단순화, 명확화)

**모델링**이란 복잡한 현실 세계를 '단순하게 표현하는 것'입니다. 모델링은 3가지 과정을 통해 아이디어를 구체화합니다.

1.  **추상화 (Abstraction)**: 현실 세계의 수많은 요소들 중에서, 만들 서비스에 **꼭 필요한 핵심 요소만 뽑아내는 과정**입니다.
    > 인스타그램 모델에서는? "사람", "게시물", "좋아요", "댓글"이라는 핵심 개념을 뽑아내는 것이 바로 추상화입니다.
2.  **단순화 (Simplification)**: 추상화를 통해 뽑아낸 핵심 요소들을, **모두가 알아볼 수 있는 약속된 형식으로 간단하게 표현하는 과정**입니다.
    > 인스타그램 모델에서는? '사람'이 가진 수만 가지 특징 중에서, 서비스에 꼭 필요한 user_id, username, email 정보만 남기기로 결정하는 것이 단순화입니다.
3.  **명확화 (Clarification)**: 단순화된 모델을 보고 **누구나 오해 없이 똑같이 이해할 수 있도록, 애매한 부분을 없애는 과정**입니다.
    > 인스타그램 모델에서는? "사용자 아이디(username)는 중복되면 안 돼!", "게시물(POSTS)은 반드시 누가 작성했는지 알아야 해(user_id는 필수!)" 와 같이, 각 요소의 규칙과 관계를 명확하게 정의하는 것이 명확화입니다.

### 2. 데이터 모델링, 왜 그렇게 중요할까요?

데이터 모델링은 시스템 개발의 첫 단추이자, 건물의 '설계도'와 같습니다.

-   **파급효과 (Leverage)**: 데이터 모델링은 시스템 구축 과정에서 가장 먼저 이루어지기 때문에, 여기서 발생한 작은 실수는 나중에 수습하기 위해 엄청난 시간과 비용을 초래합니다.
-   **간결한 표현 (Conciseness)**: 데이터 모델(ERD)은 서비스의 데이터 구조 전체를 가장 명확하고 간결하게 보여주는 '설계도' 그 자체입니다.
-   **데이터 품질 (Data Quality)**: 좋은 데이터 모델은 데이터의 품질을 보장합니다. HASHTAGS와 POST_TAGS 테이블로 분리한 모델링 덕분에 데이터의 일관성과 품질이 높아집니다.

### 3. 데이터 모델링의 3대 함정 (SQLD 시험 포인트!)

좋은 데이터 모델은 다음 세 가지를 반드시 유의해야 합니다.

1.  **중복성 (Duplication)**: 하나의 정보는 한 곳에만 저장되어야 합니다.
2.  **비유연성 (Inflexibility)**: 데이터 모델은 미래의 변화에 유연하게 대처할 수 있어야 합니다. USERS (핵심 정보)와 USER_PROFILES (부가 정보)를 분리하면 시스템 변경이 훨씬 유연하고 안전해집니다.
3.  **비일관성 (Inconsistency)**: 데이터 간의 관계가 명확하지 않으면 데이터가 모순된 상태에 빠질 수 있습니다. FOREIGN KEY 같은 관계 정의는 이런 문제를 사전에 예방해줍니다.

### 4. 아이디어 스케치에서 실제 건축까지: 데이터 모델링 3단계

데이터 모델링은 체계적인 3단계를 거칩니다.

#### 1단계: 개념적 데이터 모델링 (Conceptual Data Modeling)

-   **무엇을**: 서비스의 핵심 아이디어를 **추상적으로 표현**하는 단계입니다.
-   **어떻게**: "누가, 무엇을 가지고, 어떻게 상호작용하는가?"에만 집중합니다. 기술적인 내용은 고려하지 않습니다.
-   **비유**: **'아이디어 스케치'** 단계.
-   **인스타그램 모델에서는?**: "우리 서비스에는 사용자가 있고, 게시물을 올릴 수 있어. 사용자는 다른 사용자를 팔로우할 수 있고, 게시물에 좋아요를 누르거나 댓글을 달 수 있지." 이 생각을 간단한 네모 박스와 선으로 연결해서 그려보는 단계입니다.

#### 2단계: 논리적 데이터 모델링 (Logical Data Modeling)

-   **무엇을**: 개념적 모델을 바탕으로, 데이터베이스의 **논리적인 구조를 상세하게 설계**하는 핵심 단계입니다.
-   **어떻게**: ERD(Entity-Relationship Diagram)를 사용하여 모든 엔터티, 속성, 관계, 식별자(PK, FK) 등을 명확하게 표현합니다. **정규화** 과정이 이 단계에서 수행됩니다.
-   **비유**: **'상세 설계도(Blueprint)'** 작성 단계.
-   **인스타그램 모델에서는?**: 인스타그램 ERD가 바로 논리적 데이터 모델의 결과물입니다.

#### 3단계: 물리적 데이터 모델링 (Physical Data Modeling)

-   **무엇을**: 논리적 모델을 바탕으로, **실제 데이터베이스에 테이블을 만드는** 최종 단계입니다.
-   **어떻게**: 사용할 데이터베이스 제품의 특성을 고려하여, 실제 테이블명, 컬럼명, 데이터 타입, 제약조건, 인덱스 등을 구체적으로 정의합니다.
-   **비유**: 설계도를 보고 실제 자재로 건물을 짓는 **'시공'** 단계.
-   **인스타그램 모델에서는?**: test.sql 스크립트 파일이 바로 물리적 데이터 모델의 결과물입니다. 모든 CREATE TABLE 구문이 여기에 해당합니다.

### 5. 데이터 독립성: 설계도를 잘 나눠야 하는 이유

데이터 모델링을 3단계로 나누는 가장 큰 이유는 **데이터 독립성**을 확보하기 위함입니다. 데이터 독립성이란, **어느 한 부분의 변경이 다른 부분에 영향을 주지 않도록 하는 것**을 의미합니다.

#### 데이터베이스 3단계 스키마 구조

| 스키마 | 단계 | 설명 | 인스타그램 비유 |
| :--- | :--- | :--- | :--- |
| **외부 스키마** | View 단계 | **개별 사용자나 응용 프로그램이 보는** 데이터베이스의 모습. (전체의 일부) | 내가 보는 '인스타그램 피드' 화면 (게시물, 작성자, 좋아요 수만 보임) |
| **개념 스키마** | 개념 단계 | **데이터베이스 전체의 논리적인 구조**. 모든 사용자의 관점을 통합한 설계도. | 우리가 본 **인스타그램 ERD** 전체 |
| **내부 스키마** | 내부 단계 | 데이터가 **물리적인 저장 장치(디스크)에 어떻게 저장되는지**에 대한 정의. | 데이터가 어떤 파일에, 어떤 순서로 저장되는지에 대한 내부적인 방식 |

이 3단계 구조 덕분에 두 가지 종류의 독립성을 얻을 수 있습니다.

1.  **논리적 데이터 독립성**: **개념 스키마(전체 설계도)가 변경되어도, 외부 스키마(사용자 화면)는 영향을 받지 않는 것**을 의미합니다.
2.  **물리적 데이터 독립성**: **내부 스키마(물리적 저장 방식)가 변경되어도, 개념 스키마(전체 설계도)와 외부 스키마는 영향을 받지 않는 것**을 의미합니다.

### 6. 데이터 모델의 3대 핵심 요소

데이터 모델링은 시스템의 **업무**를 분석해서 세 가지를 찾아내는 과정입니다.

1.  업무가 관여하는 **어떤 것 (Things)** -> **엔터티 (Entity)**
2.  그 '어떤 것'이 가지는 **성격 (Attributes)** -> **속성 (Attribute)**
3.  '어떤 것'들 간의 **관계 (Relationships)** -> **관계 (Relationship)**

## 2강: 엔터티

데이터 세계의 주연 배우, **엔터티(Entity)**는 데이터 모델링의 가장 기본이 되는 벽돌입니다.

### 1. 엔터티란 무엇일까요?

**엔터티**란, **업무에서 필요로 하고, 관리해야 할 정보의 대상**을 의미합니다. 데이터로 저장되고 관리되어야 할 의미 있는 **'정보의 주인공(명사)'**입니다.
> 인스타그램 모델에서는? USERS(사용자), POSTS(게시물), COMMENTS(댓글), HASHTAGS(해시태그) 등이 모두 각각의 엔터티입니다.

### 2. '진짜' 엔터티가 되기 위한 6가지 자격 요건 (SQLD 핵심 포인트!)

1.  **업무에서 필요로 하는 정보여야 한다.** (예: USERS는 인스타그램에 필수)
2.  **유일한 식별자에 의해 식별이 가능해야 한다.** (예: USERS의 user_id)
3.  **2개 이상의 인스턴스(데이터)를 가진 집합이어야 한다.** (예: USERS에는 40명의 사용자 데이터가 존재)
4.  **업무 프로세스에 의해 반드시 이용되어야 한다.** (예: USERS는 게시물 작성, 댓글 작성 등 여러 프로세스에 관여)
5.  **반드시 1개 이상의 속성(Attribute)을 가져야 한다.** (예: USERS는 username, email 등 여러 속성을 가짐)
6.  **다른 엔터티와 최소 1개 이상의 관계를 맺어야 한다.** (예: USERS는 POSTS, USER_PROFILES 등과 관계를 맺음)

### 3. 엔터티의 종류: 역할에 따른 분류

#### ① 유/무형에 따른 분류

-   **유형 엔터티 (Tangible Entity)**: 물리적으로 존재. (예: USERS, POSTS)
-   **개념 엔터티 (Conceptual Entity)**: 개념적으로 존재. (예: HASHTAGS)
-   **사건 엔터티 (Event Entity)**: 특정 행위로 발생. (예: LIKES, FOLLOWS)

#### ② 발생 시점에 따른 분류 (SQLD 핵심 포인트!)

-   **기본 엔터티 (Basic/Fundamental Entity)**: **독립적으로 생성**될 수 있는 엔터티. (예: `USERS`, `HASHTAGS`)
-   **중심 엔터티 (Main/Central Entity)**: 기본 엔터티로부터 파생되며, **업무의 중심**에 있는 엔터티. (예: `POSTS`, `COMMENTS`)
-   **행위 엔터티 (Associative/Action Entity)**: **두 개 이상의 엔터티 사이에서 발생하는 행위**를 표현하기 위해 만들어진 엔터티. 주로 N:M 관계를 해소. (예: `LIKES`, `FOLLOWS`, `POST_TAGS`)

### 4. 좋은 이름 짓기: 엔터티 명명 규칙

1.  현업 업무에서 사용하는 용어를 사용한다.
2.  가능하면 약어를 사용하지 않는다.
3.  단수 명사를 사용한다. (SQLD 이론 시험 기준)
4.  모든 엔터티에서 유일한 이름을 부여한다.
5.  엔터티 생성 의미에 맞는 이름을 부여한다.

## 3강: 속성

**속성(Attribute)**은 엔터티의 성격, 특징, 스펙을 상세하게 설명해주는 정보입니다.

### 1. 속성이란 무엇일까요?

**속성**이란, 엔터티가 가지고 있는 **세부 정보**이자, 의미적으로 **더 이상 쪼갤 수 없는 최소 단위의 정보**를 의미합니다.
> - `USERS` 엔터티는 `user_id`, `username`, `email` 과 같은 속성들을 가집니다.
> - `POSTS` 엔터티는 `post_id`, `content`, `view_count` 와 같은 속성들을 가지죠.

#### 엔터티, 인스턴스, 속성, 속성값의 관계

| 용어 | 설명 | 인스타그램 예시 |
| :--- | :--- | :--- |
| **엔터티** | 정보의 집합, 개념 | `USERS` (사용자들이라는 개념) |
| **인스턴스** | 엔터티의 실제 데이터 한 건 | '라이언'이라는 실제 사용자 데이터 (user_id=1) |
| **속성** | 엔터티가 가지는 세부 항목 | `username`, `email` |
| **속성값** | 특정 인스턴스가 가지는 속성의 실제 값 | '라이언'의 `username` 속성값은 'ryan' |

### 2. '좋은' 속성을 설계하는 원칙 (SQLD 핵심 포인트!)

1.  **해당 엔터티에 꼭 필요한 속성인가?**: 속성은 그 엔터티를 설명하는 정보여야 합니다.
2.  **하나의 속성은 '하나의 값'만 가져야 한다. (원자성, Atomicity)**: 여러 값을 저장해야 한다면 별도의 엔터티로 분리(정규화)해야 합니다.
3.  **하나의 속성은 '하나의 의미'만 가져야 한다.**: 여러 의미가 섞여 있다면 별개의 속성으로 분리해야 합니다.

### 3. 속성의 종류: 역할에 따른 분류

#### ① 특성에 따른 분류 (SQLD 핵심 포인트!)

-   **기본속성 (Basic Attribute)**: 업무 분석을 통해 도출되는 **원래부터 존재하는** 속성. (예: `username`, `content`)
-   **설계속성 (Designed Attribute)**: 데이터 모델링 과정에서 **설계자가 필요에 의해 인위적으로 만들어내는** 속성. (예: `user_id`, `post_id`)
-   **파생속성 (Derived Attribute)**: 다른 속성 값으로부터 **계산되거나 변형되어 생성**되는 속성. 가급적 저장하지 않고 필요 시 계산. (예: '총 게시물 수')

#### ② 엔터티 구성방식에 따른 분류

-   **PK속성 (Primary Key Attribute)**: 엔터티의 인스턴스를 유일하게 식별하는 **기본 키** 속성. (예: `USERS`의 `user_id`)
-   **FK속성 (Foreign Key Attribute)**: 다른 엔터티와의 관계를 위한 **외래 키** 속성. (예: `POSTS`의 `user_id`)
-   **일반속성**: PK도, FK도 아닌 나머지 모든 속성. (예: `USERS`의 `email`)

### 4. 속성의 값 범위: 도메인 (Domain)

**도메인**이란, 하나의 속성이 가질 수 있는 **값의 범위** 또는 **허용된 값의 목록**을 의미합니다.
> `POSTS` 엔터티의 `post_type` 속성의 도메인은 `{'photo', 'video'}` 입니다.

### 5. 좋은 이름 짓기: 속성 명명 규칙

1.  해당 업무에서 사용하는 이름을 부여한다.
2.  서술식 속성명은 가급적 사용하지 않는다. (명사형으로 간결하게)
3.  약어 사용은 가급적 제한한다.
4.  전체 데이터 모델에서 유일성을 확보하는 것이 좋다. (예: user_id, post_id)

## 4강: 관계

**관계(Relationship)**는 엔터티들을 서로 연결하여 데이터의 흐름과 스토리를 만들어주는 '인물 관계도'입니다.

### 1. 관계란 무엇일까요?

**관계**란, 두 개 이상의 엔터티가 **업무적으로 의미 있는 연관성**을 가지고 상호작용하는 것을 의미합니다.
> - 사용자(`USERS`)는 게시물(`POSTS`)을 **'작성한다'**.
> - 사용자(`USERS`)는 댓글(`COMMENTS`)을 **'남긴다'**.

### 2. 관계의 종류: 어떻게 맺어지는가?

-   **① 존재에 의한 관계 (Existence Relationship)**: 존재 자체만으로 관계가 성립. (예: `USERS`와 `USER_PROFILES`의 관계)
-   **② 행위에 의한 관계 (Action Relationship)**: 특정 '행위'가 발생해야 관계가 성립. (예: `USERS`가 `POSTS`를 작성하는 행위)

### 3. 관계의 이름 짓기: 관계명(Membership)

관계는 보통 양방향으로 해석될 수 있으며, 각 방향마다 이름을 붙일 수 있습니다.
> - **시작점 → 끝점**: 사용자(`USERS`)는 게시물(`POSTS`)을 **'작성한다'**.
> - **끝점 → 시작점**: 게시물(`POSTS`)은 사용자(`USERS`)에 의해 **'작성된다'**.

### 4. 관계의 수량 표현: 관계차수 (Cardinality)

**관계차수**는 한 엔터티의 인스턴스가 다른 엔터티의 인스턴스와 **'몇 대 몇'으로 대응되는지**를 나타냅니다.

-   **① 일대일 (1:1) 관계**: 하나의 인스턴스가 다른 쪽의 오직 하나의 인스턴스와 관계를 맺음. (예: `USERS`와 `USER_PROFILES`)
-   **② 일대다 (1:N) 관계**: 하나의 인스턴스가 다른 쪽의 여러 인스턴스와 관계를 맺음. (예: `USERS`와 `POSTS`)
-   **③ 다대다 (M:N) 관계**: 양쪽의 여러 인스턴스가 서로 관계를 맺음. 관계형 데이터베이스에서는 중간에 `LIKES`와 같은 **행위 엔터티(관계 테이블)**를 두어 두 개의 1:N 관계로 풀어내야 합니다.

### 5. 관계의 필수 여부: 관계선택사양 (Optionality)

**관계선택사양**은 특정 엔터티가 관계에 **반드시 참여해야 하는지(필수)**, 아니면 **참여하지 않을 수도 있는지(선택)**를 나타냅니다.

-   **① 필수 관계 (Mandatory)**: 다른 쪽 엔터티가 반드시 존재해야 함. ERD에서 실선(`|`)으로 표현. (예: `POSTS` 입장에서 `USERS`와의 관계)
-   **② 선택 관계 (Optional)**: 다른 쪽 엔터티가 존재하지 않을 수도 있음. ERD에서 점선 또는 동그라미(`O`)로 표현. (예: `USERS` 입장에서 `POSTS`와의 관계)

### 6. ERD 표기법 읽기 (까마귀발 표기법)

`USERS` `||` ───── `O<` `POSTS`

1.  **`POSTS` 쪽에서 `USERS`를 바라볼 때 (`||`)**
    > 하나의 **게시물(POSTS)**은 **반드시( | ) 단 하나의( | ) 사용자(USERS)**에게 속해야 한다.

2.  **`USERS` 쪽에서 `POSTS`를 바라볼 때 (`O<`)**
    > 한 명의 **사용자(USERS)**는 게시물이 **없을 수도 있고(O) 여러 개(<)** 가질 수도 있다.

#### 최종 종합 해석

> "한 명의 **사용자(USERS)**는 0개 또는 여러 개의 **게시물(POSTS)**을 작성할 수 있는 반면(1:N), 하나의 **게시물(POSTS)**은 반드시 단 한 명의 **사용자(USERS)**에게만 속해야 한다."

## 5강: 식별자

**식별자(Identifier)**는 엔터티 내의 주인공들에게 절대 중복되지 않는 '이름표'를 붙여주는 것입니다.

### 1. 식별자란 무엇일까요?

**식별자**란, 하나의 엔터티 내에 있는 **수많은 인스턴스(데이터)들을 서로 유일하게 구분할 수 있게 해주는 속성 또는 속성들의 집합**을 의미합니다. 데이터베이스의 식별자는 '학번'과 똑같은 역할을 합니다.

### 2. '좋은 이름표'의 4대 조건 (SQLD 최고 빈출!)

1.  **유일성 (Uniqueness)**: 식별자는 모든 인스턴스를 유일하게 구분해야 합니다.
2.  **최소성 (Minimality)**: 유일성을 만족하는 최소한의 속성으로 구성되어야 합니다.
3.  **불변성 (Immutability)**: 식별자의 값은 한번 부여되면 변해서는 안 됩니다.
4.  **존재성 (Existence)**: 식별자는 반드시 값을 가져야 하며, `NULL` 값을 허용하지 않습니다.

### 3. 식별자의 대표성: 주식별자 vs 보조식별자

-   **주식별자 (Primary Identifier)**: 엔터티를 대표하도록 선정된 **'메인 이름표'**. 테이블의 `PRIMARY KEY`가 됩니다. (예: `USERS`의 `user_id`)
-   **보조식별자 (Alternate Identifier)**: 주식별자는 아니지만 유일성을 만족하는 속성들. 테이블의 `UNIQUE` 제약조건으로 구현됩니다. (예: `USERS`의 `username`, `email`)

### 4. 식별자의 다양한 분류

| 분류 기준 | 종류 | 설명 | 인스타그램 모델 예시 |
| :--- | :--- | :--- | :--- |
| **스스로 생성 여부** | **내부식별자** | 엔터티 **내부에서 스스로** 만들어지는 식별자 | `USERS`의 `user_id` |
| | **외부식별자** | 다른 엔터티와의 **관계를 통해 받아오는** 식별자 (FK) | `POSTS`의 `user_id` |
| **속성의 수** | **단일식별자** | **하나의 속성**으로만 구성된 식별자 | `USERS`의 `user_id` |
| | **복합식별자** | **두 개 이상의 속성**으로 구성된 식별자 | `LIKES`의 (`user_id`, `post_id`) |
| **대체 가능 여부** | **본질식별자** | **업무적으로 원래부터** 의미가 있는 식별자 (Natural Key) | `USERS`의 `username` |
| | **인조식별자** | 유일성을 보장하기 위해 **시스템이 인위적으로 만든** 식별자 (Artificial Key) | `USERS`의 `user_id` |

> 왜 인조식별자(Artificial Key)를 주식별자로 사용할까요? `username` 같은 본질식별자는 사용자가 변경할 수 있어서 '불변성'을 위배할 위험이 있습니다. 반면, 시스템이 한번 부여한 `user_id` 같은 인조식별자는 절대 변하지 않으므로, 훨씬 더 안정적인 주식별자가 될 수 있습니다.

### 5. 관계의 종류를 결정하는 식별자 (ERD 해석의 핵심!)

부모 엔터티의 주식별자가 자식 엔터티에서 어떤 역할을 하느냐에 따라 관계의 종류가 나뉩니다.

#### ① 식별자 관계 (Identifying Relationship)

> "아빠 없이는 나도 없어!"
> **정의**: 부모 엔터티의 주식별자를 물려받아, **자식 엔터티의 주식별자의 일부로** 사용하는 강력한 관계입니다. 자식은 부모가 있어야만 존재할 수 있습니다. (ERD에서 주로 실선)
> **예시**: `LIKES` 테이블. 주식별자는 (`user_id`, `post_id`)이며, 이 둘은 각각 `USERS`와 `POSTS`로부터 물려받은 외부식별자입니다.

#### ② 비식별자 관계 (Non-identifying Relationship)

> "아빠는 아빠, 나는 나!"
> **정의**: 부모 엔터티의 주식별자를 물려받지만, **자식 엔터티의 주식별자가 아닌 일반 속성으로** 사용하는 일반적인 관계입니다. 부모와 자식이 서로 독립적으로 존재할 수 있습니다. (ERD에서 주로 점선)
> **예시**: `POSTS` 테이블. `POSTS`는 `USERS`의 `user_id`를 FK로 물려받지만, `POSTS` 자신의 주식별자는 별개의 속성인 `post_id`입니다.
