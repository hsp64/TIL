# 25년 8월 26일


---

# 부모→자식으로만 흐르는 단방향 데이터 흐름과 함수를 통한 상향식 통신, key가 있는 동적 리스트, 조건에 따른 컴포넌트 렌더링

##  자식컴포넌트에서 부모컴포넌트로 데이터 전달하기

### 학습 목표
- React의 단방향 데이터 흐름 원리 이해하기
- 상향식 데이터 전달 패턴 마스터하기
- 실제 프로젝트에서 컴포넌트 간 통신 구현하기

###  React의 데이터 흐름 원리

#### 왜 자식이 부모의 상태를 직접 변경할 수 없을까?

React는 **예측 가능한 상태 관리**를 위해 단방향 데이터 흐름을 강제합니다.

```jsx
// ❌ 이런 식으로는 할 수 없습니다
const Child = ({ parentState, setParentState }) => {
  const handleClick = () => {
    // 자식이 직접 부모 상태를 변경하려고 시도
    parentState = "새로운 값"; // 작동하지 않음!
  };
};
```

```jsx
// ✅ 올바른 방법: 부모로부터 함수를 받아서 호출
const Child = ({ onDataChange }) => {
  const handleClick = () => {
    onDataChange("새로운 값"); // 부모에게 변경 요청
  };
};
```

#### 단방향 데이터 흐름의 장점

1. **디버깅이 쉬움**: 데이터가 어디서 변경되는지 추적하기 용이
2. **예측 가능성**: 상태 변경의 흐름이 명확함
3. **재사용성**: 컴포넌트가 특정 상태에 의존하지 않음

### 상향식 데이터 전달 패턴 심화

#### 기본 패턴 분석

```jsx
// 1단계: 부모 컴포넌트
const Parent = () => {
  const [data, setData] = useState([]);
  
  // 자식으로부터 데이터를 받는 함수
  const handleDataFromChild = (newData) => {
    setData(prev => [...prev, newData]);
  };

  return (
    <div>
      <Child onSendData={handleDataFromChild} />
      <DisplayData data={data} />
    </div>
  );
};

// 2단계: 자식 컴포넌트
const Child = ({ onSendData }) => {
  const [inputValue, setInputValue] = useState('');

  const handleSubmit = () => {
    // 부모에게 데이터 전송
    onSendData(inputValue);
    setInputValue(''); // 입력값 초기화
  };

  return (
    <div>
      <input 
        value={inputValue}
        onChange={(e) => setInputValue(e.target.value)}
      />
      <button onClick={handleSubmit}>전송</button>
    </div>
  );
};
```

### 💡 실전 예제: 할일 관리 앱

더 복잡한 예제로 할일 관리 앱을 만들어보겠습니다.

```jsx
// TodoApp.jsx - 최상위 컴포넌트
import React, { useState } from 'react';

const TodoApp = () => {
  const [todos, setTodos] = useState([]);
  const [filter, setFilter] = useState('all');

  // 새 할일 추가
  const addTodo = (todoText) => {
    const newTodo = {
      id: Date.now(),
      text: todoText,
      completed: false,
      createdAt: new Date()
    };
    setTodos(prev => [...prev, newTodo]);
  };

  // 할일 완료 토글
  const toggleTodo = (id) => {
    setTodos(prev => 
      prev.map(todo => 
        todo.id === id 
          ? { ...todo, completed: !todo.completed }
          : todo
      )
    );
  };

  // 할일 삭제
  const deleteTodo = (id) => {
    setTodos(prev => prev.filter(todo => todo.id !== id));
  };

  return (
    <div className="todo-app">
      <h1>할일 관리</h1>
      <TodoForm onAddTodo={addTodo} />
      <TodoFilter currentFilter={filter} onFilterChange={setFilter} />
      <TodoList 
        todos={todos}
        filter={filter}
        onToggle={toggleTodo}
        onDelete={deleteTodo}
      />
    </div>
  );
};

// TodoForm.jsx - 할일 입력 폼
const TodoForm = ({ onAddTodo }) => {
  const [text, setText] = useState('');
  const [error, setError] = useState('');

  const handleSubmit = (e) => {
    e.preventDefault();
    
    // 유효성 검사
    if (!text.trim()) {
      setError('할일을 입력해주세요');
      return;
    }
    
    if (text.length > 50) {
      setError('할일은 50자 이하로 입력해주세요');
      return;
    }

    // 부모에게 새 할일 전달
    onAddTodo(text.trim());
    setText('');
    setError('');
  };

  return (
    <form onSubmit={handleSubmit} className="todo-form">
      <input
        type="text"
        value={text}
        onChange={(e) => setText(e.target.value)}
        placeholder="새 할일을 입력하세요"
        className={error ? 'error' : ''}
      />
      <button type="submit">추가</button>
      {error && <span className="error-message">{error}</span>}
    </form>
  );
};
```

###  다층 컴포넌트에서의 데이터 전달

실제 앱에서는 여러 층의 컴포넌트를 거쳐 데이터가 전달되어야 합니다.

```jsx
// App -> NewExpense -> ExpenseForm 구조 분석
const App = () => {
  const [expenses, setExpenses] = useState(DUMMY_EXPENSES);

  // 3단계: 최종적으로 새 expense를 받아서 상태 업데이트
  const addExpenseHandler = (expense) => {
    setExpenses(prevExpenses => [expense, ...prevExpenses]);
  };

  return (
    <div>
      <NewExpense onAddExpense={addExpenseHandler} />
      <Expenses items={expenses} />
    </div>
  );
};

const NewExpense = ({ onAddExpense }) => {
  const [isEditing, setIsEditing] = useState(false);

  // 2단계: ExpenseForm으로부터 데이터를 받아 가공 후 부모에게 전달
  const saveExpenseDataHandler = (enteredExpenseData) => {
    const expenseData = {
      ...enteredExpenseData,
      id: Math.random().toString(),
      createdAt: new Date()
    };
    onAddExpense(expenseData);
    setIsEditing(false);
  };

  // 편집 취소 핸들러
  const stopEditingHandler = () => {
    setIsEditing(false);
  };

  return (
    <div className="new-expense">
      {!isEditing && (
        <button onClick={() => setIsEditing(true)}>
          새 지출 추가
        </button>
      )}
      {isEditing && (
        <ExpenseForm
          onSaveExpenseData={saveExpenseDataHandler}
          onCancel={stopEditingHandler}
        />
      )}
    </div>
  );
};

const ExpenseForm = ({ onSaveExpenseData, onCancel }) => {
  // 1단계: 사용자 입력을 받아 부모에게 전달
  const [enteredTitle, setEnteredTitle] = useState('');
  const [enteredAmount, setEnteredAmount] = useState('');
  const [enteredDate, setEnteredDate] = useState('');

  const submitHandler = (event) => {
    event.preventDefault();

    // 유효성 검사
    if (!enteredTitle.trim() || !enteredAmount || !enteredDate) {
      alert('모든 필드를 입력해주세요');
      return;
    }

    const expenseData = {
      title: enteredTitle,
      amount: +enteredAmount, // 숫자로 변환
      date: new Date(enteredDate)
    };

    onSaveExpenseData(expenseData);

    // 폼 초기화
    setEnteredTitle('');
    setEnteredAmount('');
    setEnteredDate('');
  };

  return (
    <form onSubmit={submitHandler}>
      <div className="new-expense__controls">
        <div className="new-expense__control">
          <label>제목</label>
          <input
            type="text"
            value={enteredTitle}
            onChange={(event) => setEnteredTitle(event.target.value)}
          />
        </div>
        <div className="new-expense__control">
          <label>금액</label>
          <input
            type="number"
            min="0.01"
            step="0.01"
            value={enteredAmount}
            onChange={(event) => setEnteredAmount(event.target.value)}
          />
        </div>
        <div className="new-expense__control">
          <label>날짜</label>
          <input
            type="date"
            min="2019-01-01"
            max="2025-12-31"
            value={enteredDate}
            onChange={(event) => setEnteredDate(event.target.value)}
          />
        </div>
      </div>
      <div className="new-expense__actions">
        <button type="button" onClick={onCancel}>취소</button>
        <button type="submit">지출 추가</button>
      </div>
    </form>
  );
};
```

### 주의사항과 Best Practices

#### 1. Prop Drilling 문제
```jsx
// ❌ 너무 깊은 prop 전달
<Level1>
  <Level2>
    <Level3>
      <Level4 onDataChange={handleDataChange} />
    </Level3>
  </Level2>
</Level1>

// ✅ Context API 사용 고려
const DataContext = createContext();

const App = () => {
  const [data, setData] = useState({});
  
  return (
    <DataContext.Provider value={{ data, setData }}>
      <Components />
    </DataContext.Provider>
  );
};
```

#### 2. 함수 네이밍 컨벤션
```jsx
// ✅ 명확한 네이밍
const Parent = () => {
  const handleUserSubmit = (userData) => { /* ... */ };
  const handleItemAdd = (item) => { /* ... */ };
  const handleDataUpdate = (newData) => { /* ... */ };
  
  return (
    <div>
      <UserForm onSubmit={handleUserSubmit} />
      <ItemList onAdd={handleItemAdd} />
      <DataEditor onUpdate={handleDataUpdate} />
    </div>
  );
};
```

## React에서의 동적 리스트 렌더링 및 key prop

###  학습 목표
- JavaScript map() 메서드의 활용법 완전 이해
- React에서 key prop의 중요성과 올바른 사용법
- 리스트 성능 최적화 기법

### 📊 배열 렌더링의 진화 과정

#### 1단계: 정적 렌더링 (비추천)
```jsx
const ExpenseList = ({ expenses }) => {
  return (
    <div>
      <ExpenseItem expense={expenses[0]} />
      <ExpenseItem expense={expenses[1]} />
      <ExpenseItem expense={expenses[2]} />
      {/* 배열 크기가 변하면 문제 발생! */}
    </div>
  );
};
```

#### 2단계: 기본 동적 렌더링
```jsx
const ExpenseList = ({ expenses }) => {
  return (
    <div>
      {expenses.map(expense => (
        <ExpenseItem key={expense.id} expense={expense} />
      ))}
    </div>
  );
};
```

#### 3단계: 고급 동적 렌더링 (조건부 + 변환)
```jsx
const ExpenseList = ({ expenses, showOnlyHighValue, currency = 'KRW' }) => {
  return (
    <div>
      {expenses
        .filter(expense => showOnlyHighValue ? expense.amount > 100000 : true)
        .sort((a, b) => b.date - a.date) // 최신순 정렬
        .map(expense => (
          <ExpenseItem 
            key={expense.id} 
            expense={{
              ...expense,
              formattedAmount: `${expense.amount.toLocaleString()} ${currency}`
            }}
          />
        ))
      }
    </div>
  );
};
```

### key prop 심화 학습

#### key가 없을 때 발생하는 문제

```jsx
// ❌ key가 없는 경우
const TodoList = ({ todos }) => {
  return (
    <ul>
      {todos.map(todo => (
        <TodoItem todo={todo} /> // key 없음!
      ))}
    </ul>
  );
};

/*
문제점:
1. 리스트 순서가 바뀔 때 React가 어떤 요소가 어떤 요소인지 모름
2. 불필요한 DOM 조작 발생
3. 입력 필드가 있을 경우 값이 뒤섞일 수 있음
*/
```

#### key 선택의 올바른 방법

```jsx
// ✅ 고유한 ID 사용 (최선)
todos.map(todo => <TodoItem key={todo.id} todo={todo} />)

// ❌ 배열 인덱스 사용 (피해야 함)
todos.map((todo, index) => <TodoItem key={index} todo={todo} />)
/*
인덱스를 key로 사용하면 안 되는 이유:
- 리스트 순서가 바뀔 때 문제 발생
- 아이템 추가/삭제 시 성능 저하
*/

// ✅ 복합 키 사용 (고유 ID가 없을 경우)
todos.map(todo => (
  <TodoItem 
    key={`${todo.text}-${todo.createdAt}`} 
    todo={todo} 
  />
))
```

### 실전 예제: 인터랙티브 쇼핑 카트

```jsx
const ShoppingCart = () => {
  const [items, setItems] = useState([]);
  const [sortBy, setSortBy] = useState('name');
  const [filterCategory, setFilterCategory] = useState('all');

  // 아이템 수량 변경
  const updateQuantity = (itemId, newQuantity) => {
    if (newQuantity <= 0) {
      setItems(prev => prev.filter(item => item.id !== itemId));
    } else {
      setItems(prev => 
        prev.map(item => 
          item.id === itemId 
            ? { ...item, quantity: newQuantity }
            : item
        )
      );
    }
  };

  // 정렬된 및 필터된 아이템들
  const processedItems = items
    .filter(item => 
      filterCategory === 'all' || item.category === filterCategory
    )
    .sort((a, b) => {
      switch (sortBy) {
        case 'name':
          return a.name.localeCompare(b.name);
        case 'price':
          return b.price - a.price;
        case 'quantity':
          return b.quantity - a.quantity;
        default:
          return 0;
      }
    });

  return (
    <div className="shopping-cart">
      <div className="controls">
        <select value={sortBy} onChange={(e) => setSortBy(e.target.value)}>
          <option value="name">이름순</option>
          <option value="price">가격순</option>
          <option value="quantity">수량순</option>
        </select>
        
        <select value={filterCategory} onChange={(e) => setFilterCategory(e.target.value)}>
          <option value="all">전체</option>
          <option value="electronics">전자제품</option>
          <option value="clothing">의류</option>
          <option value="books">도서</option>
        </select>
      </div>

      <div className="item-list">
        {processedItems.length === 0 ? (
          <EmptyCart />
        ) : (
          processedItems.map(item => (
            <CartItem
              key={item.id}
              item={item}
              onQuantityChange={(newQuantity) => 
                updateQuantity(item.id, newQuantity)
              }
            />
          ))
        )}
      </div>

      <CartSummary items={processedItems} />
    </div>
  );
};

const CartItem = ({ item, onQuantityChange }) => {
  return (
    <div className="cart-item">
      <img src={item.image} alt={item.name} />
      <div className="item-info">
        <h3>{item.name}</h3>
        <p className="price">{item.price.toLocaleString()}원</p>
        <div className="quantity-controls">
          <button onClick={() => onQuantityChange(item.quantity - 1)}>
            -
          </button>
          <span>{item.quantity}</span>
          <button onClick={() => onQuantityChange(item.quantity + 1)}>
            +
          </button>
        </div>
      </div>
      <div className="total-price">
        {(item.price * item.quantity).toLocaleString()}원
      </div>
    </div>
  );
};

const EmptyCart = () => (
  <div className="empty-cart">
    <p>장바구니가 비어있습니다</p>
  </div>
);
```

###  성능 최적화 기법

#### 1. React.memo를 활용한 리스트 아이템 최적화
```jsx
const ExpensiveListItem = React.memo(({ item, onUpdate }) => {
  console.log(`${item.name} 렌더링됨`); // 렌더링 확인용
  
  return (
    <div className="list-item">
      <h3>{item.name}</h3>
      <p>{item.description}</p>
      <button onClick={() => onUpdate(item.id)}>
        업데이트
      </button>
    </div>
  );
});

// 비교 함수로 더 세밀한 제어
const ExpensiveListItem = React.memo(({ item, onUpdate }) => {
  // 컴포넌트 내용...
}, (prevProps, nextProps) => {
  // true를 반환하면 리렌더링 하지 않음
  return prevProps.item.id === nextProps.item.id &&
         prevProps.item.name === nextProps.item.name;
});
```

####  useCallback으로 함수 최적화
```jsx
const OptimizedList = ({ items }) => {
  const [selectedItems, setSelectedItems] = useState(new Set());

  // 함수를 메모이제이션하여 불필요한 리렌더링 방지
  const handleItemSelect = useCallback((itemId) => {
    setSelectedItems(prev => {
      const newSet = new Set(prev);
      if (newSet.has(itemId)) {
        newSet.delete(itemId);
      } else {
        newSet.add(itemId);
      }
      return newSet;
    });
  }, []);

  return (
    <div>
      {items.map(item => (
        <ListItem
          key={item.id}
          item={item}
          isSelected={selectedItems.has(item.id)}
          onSelect={handleItemSelect}
        />
      ))}
    </div>
  );
};
```

## 조건부 렌더링

###  학습 목표
- 다양한 조건부 렌더링 패턴 마스터하기
- 성능을 고려한 조건부 렌더링
- 실제 사용 사례와 모범 사례

###  조건부 렌더링의 다양한 패턴

#### 1. 삼항 연산자 (Ternary Operator)
```jsx
const UserGreeting = ({ user }) => {
  return (
    <div>
      {user ? (
        <h1>안녕하세요, {user.name}님!</h1>
      ) : (
        <h1>로그인해주세요</h1>
      )}
    </div>
  );
};
```

#### 2. 논리 AND 연산자 (&&)
```jsx
const NotificationBadge = ({ count }) => {
  return (
    <div className="icon">
      🔔
      {count > 0 && (
        <span className="badge">{count}</span>
      )}
    </div>
  );
};

// 주의: falsy 값 렌더링 문제
const BadExample = ({ count }) => {
  return (
    <div>
      {count && <span>알림: {count}개</span>}
      {/* count가 0일 때 '0'이 렌더링됨! */}
    </div>
  );
};

// 올바른 방법
const GoodExample = ({ count }) => {
  return (
    <div>
      {count > 0 && <span>알림: {count}개</span>}
    </div>
  );
};
```

#### 3. 논리 OR 연산자 (||) - 기본값 제공
```jsx
const UserProfile = ({ user }) => {
  return (
    <div>
      <img src={user.avatar || '/default-avatar.png'} alt="프로필" />
      <h2>{user.name || '익명 사용자'}</h2>
      <p>{user.bio || '소개글이 없습니다.'}</p>
    </div>
  );
};
```

#### 4. 즉시 실행 함수 (IIFE) - 복잡한 조건
```jsx
const ComplexConditionalComponent = ({ user, permission, feature }) => {
  return (
    <div>
      {(() => {
        if (!user) {
          return <LoginPrompt />;
        }
        
        if (!permission.canView) {
          return <AccessDenied />;
        }
        
        if (!feature.isEnabled) {
          return <FeatureDisabled />;
        }
        
        if (user.isPremium) {
          return <PremiumContent />;
        }
        
        return <StandardContent />;
      })()}
    </div>
  );
};
```

###  실전 예제: 다단계 온보딩 시스템

```jsx
const OnboardingFlow = () => {
  const [currentStep, setCurrentStep] = useState(1);
  const [userData, setUserData] = useState({
    profile: {},
    preferences: {},
    verification: {}
  });

  const totalSteps = 4;

  const nextStep = () => {
    if (currentStep < totalSteps) {
      setCurrentStep(prev => prev + 1);
    }
  };

  const prevStep = () => {
    if (currentStep > 1) {
      setCurrentStep(prev => prev - 1);
    }
  };

  const updateUserData = (stepData) => {
    setUserData(prev => ({
      ...prev,
      ...stepData
    }));
  };

  // 각 단계별 컴포넌트 렌더링
  const renderStep = () => {
    switch (currentStep) {
      case 1:
        return (
          <ProfileSetup
            data={userData.profile}
            onComplete={(profileData) => {
              updateUserData({ profile: profileData });
              nextStep();
            }}
          />
        );
      
      case 2:
        return (
          <PreferencesSetup
            data={userData.preferences}
            onComplete={(prefsData) => {
              updateUserData({ preferences: prefsData });
              nextStep();
            }}
          />
        );
      
      case 3:
        return (
          <VerificationStep
            data={userData.verification}
            onComplete={(verifyData) => {
              updateUserData({ verification: verifyData });
              nextStep();
            }}
          />
        );
      
      case 4:
        return (
          <OnboardingComplete
            userData={userData}
            onFinish={() => {
              // 온보딩 완료 처리
              console.log('온보딩 완료:', userData);
            }}
          />
        );
      
      default:
        return <div>오류가 발생했습니다.</div>;
    }
  };

  return (
    <div className="onboarding-container">
      {/* 진행률 표시 */}
      <ProgressBar current={currentStep} total={totalSteps} />
      
      {/* 단계 제목 */}
      <h2>
        {currentStep === 1 && "프로필 설정"}
        {currentStep === 2 && "선호 설정"}
        {currentStep === 3 && "계정 인증"}
        {currentStep === 4 && "완료"}
      </h2>
      
      {/* 현재 단계 컴포넌트 */}
      <div className="step-content">
        {renderStep()}
      </div>
      
      {/* 네비게이션 버튼 */}
      <div className="navigation">
        {currentStep > 1 && (
          <button onClick={prevStep} className="btn-secondary">
            이전
          </button>
        )}
        
        {/* 마지막 단계가 아닐 때만 다음 버튼 표시 */}
        {currentStep < totalSteps && (
          <button onClick={nextStep} className="btn-primary">
            다음
          </button>
        )}
      </div>
    </div>
  );
};

// 각 단계별 컴포넌트들
const ProfileSetup = ({ data, onComplete }) => {
  const [profile, setProfile] = useState(data || {
    name: '',
    email: '',
    phone: ''
  });

  const handleSubmit = (e) => {
    e.preventDefault();
    
    // 유효성 검사
    if (!profile.name || !profile.email) {
      alert('필수 항목을 입력해주세요');
      return;
    }
    
    onComplete(profile);
  };

  return (
    <form onSubmit={handleSubmit}>
      <div className="form-group">
        <label>이름 *</label>
        <input
          type="text"
          value={profile.name}
          onChange={(e) => setProfile(prev => ({
            ...prev,
            name: e.target.value
          }))}
          required
        />
      </div>
      
      <div className="form-group">
        <label>이메일 *</label>
        <input
          type="email"
          value={profile.email}
          onChange={(e) => setProfile(prev => ({
            ...prev,
            email: e.target.value
          }))}
          required
        />
      </div>
      
      <div className="form-group">
        <label>전화번호</label>
        <input
          type="tel"
          value={profile.phone}
          onChange={(e) => setProfile(prev => ({
            ...prev,
            phone: e.target.value
          }))}
        />
      </div>
      
      <button type="submit" className="btn-primary">
        다음 단계
      </button>
    </form>
  );
};
```

### 🎛고급 조건부 렌더링 패턴

#### 1. 권한 기반 렌더링
```jsx
const PermissionWrapper = ({ children, requiredPermission, user }) => {
  const hasPermission = user?.permissions?.includes(requiredPermission);
  
  if (!user) {
    return <LoginRequired />;
  }
  
  if (!hasPermission) {
    return <AccessDenied requiredPermission={requiredPermission} />;
  }
  
  return children;
};

// 사용 예시
const AdminPanel = () => {
  return (
    <PermissionWrapper requiredPermission="admin" user={currentUser}>
      <div>
        <h1>관리자 패널</h1>
        <UserManagement />
        <SystemSettings />
      </div>
    </PermissionWrapper>
  );
};
```

#### 2. 로딩 상태 관리
```jsx
const DataDisplay = ({ isLoading, error, data }) => {
  // 에러 상태 우선 처리
  if (error) {
    return (
      <ErrorBoundary>
        <div className="error-state">
          <h3>오류가 발생했습니다</h3>
          <p>{error.message}</p>
          <button onClick={() => window.location.reload()}>
            다시 시도
          </button>
        </div>
      </ErrorBoundary>
    );
  }
  
  // 로딩 상태
  if (isLoading) {
    return (
      <div className="loading-state">
        <Spinner />
        <p>데이터를 불러오는 중...</p>
      </div>
    );
  }
  
  // 데이터가 없는 상태
  if (!data || data.length === 0) {
    return (
      <div className="empty-state">
        <img src="/empty-state.svg" alt="데이터 없음" />
        <h3>표시할 데이터가 없습니다</h3>
        <p>새로운 항목을 추가해보세요</p>
      </div>
    );
  }
  
  // 정상 데이터 표시
  return (
    <div className="data-display">
      {data.map(item => (
        <DataItem key={item.id} item={item} />
      ))}
    </div>
  );
};
```

#### 3. 반응형 조건부 렌더링
```jsx
const ResponsiveNavigation = () => {
  const [isMobile, setIsMobile] = useState(window.innerWidth < 768);
  const [isMenuOpen, setIsMenuOpen] = useState(false);

  useEffect(() => {
    const handleResize = () => {
      setIsMobile(window.innerWidth < 768);
      if (window.innerWidth >= 768) {
        setIsMenuOpen(false); // 데스크톱에서는 메뉴 자동 닫기
      }
    };

    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  return (
    <nav className="navigation">
      {isMobile ? (
        // 모바일 네비게이션
        <div className="mobile-nav">
          <div className="nav-header">
            <Logo />
            <button 
              className="menu-toggle"
              onClick={() => setIsMenuOpen(!isMenuOpen)}
              aria-label="메뉴 토글"
            >
              {isMenuOpen ? '✕' : '☰'}
            </button>
          </div>
          
          {isMenuOpen && (
            <div className="mobile-menu">
              <NavLinks onLinkClick={() => setIsMenuOpen(false)} />
              <UserActions />
            </div>
          )}
        </div>
      ) : (
        // 데스크톱 네비게이션
        <div className="desktop-nav">
          <Logo />
          <NavLinks />
          <UserActions />
        </div>
      )}
    </nav>
  );
};
```

#### 4. 피처 플래그 기반 렌더링
```jsx
const FeatureFlag = ({ feature, fallback = null, children }) => {
  const { features } = useFeatureFlags();
  
  if (!features[feature]) {
    return fallback;
  }
  
  return children;
};

// 사용 예시
const App = () => {
  return (
    <div>
      <Header />
      
      <FeatureFlag 
        feature="newDashboard" 
        fallback={<LegacyDashboard />}
      >
        <NewDashboard />
      </FeatureFlag>
      
      <FeatureFlag feature="betaFeatures">
        <BetaPanel />
      </FeatureFlag>
      
      <Footer />
    </div>
  );
};
```

### 실전 프로젝트: 소셜 미디어 피드

```jsx
const SocialMediaFeed = () => {
  const [posts, setPosts] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);
  const [filter, setFilter] = useState('all'); // all, friends, following
  const [user, setUser] = useState(null);

  useEffect(() => {
    loadPosts();
    loadUser();
  }, [filter]);

  const loadPosts = async () => {
    try {
      setIsLoading(true);
      const response = await fetchPosts(filter);
      setPosts(response.data);
      setError(null);
    } catch (err) {
      setError(err);
    } finally {
      setIsLoading(false);
    }
  };

  const loadUser = async () => {
    try {
      const userData = await getCurrentUser();
      setUser(userData);
    } catch (err) {
      console.error('사용자 정보 로드 실패:', err);
    }
  };

  // 포스트 좋아요 토글
  const handleLike = async (postId) => {
    if (!user) {
      alert('로그인이 필요합니다');
      return;
    }

    try {
      await toggleLike(postId);
      setPosts(prev => prev.map(post => 
        post.id === postId 
          ? { 
              ...post, 
              isLiked: !post.isLiked,
              likesCount: post.isLiked 
                ? post.likesCount - 1 
                : post.likesCount + 1 
            }
          : post
      ));
    } catch (err) {
      console.error('좋아요 처리 실패:', err);
    }
  };

  return (
    <div className="social-feed">
      {/* 헤더 */}
      <div className="feed-header">
        <h1>피드</h1>
        
        {user ? (
          <div className="user-info">
            <img src={user.avatar} alt={user.name} className="avatar" />
            <span>안녕하세요, {user.name}님!</span>
          </div>
        ) : (
          <button className="login-btn">로그인</button>
        )}
      </div>

      {/* 필터 */}
      <div className="feed-filters">
        <button 
          className={filter === 'all' ? 'active' : ''}
          onClick={() => setFilter('all')}
        >
          전체
        </button>
        <button 
          className={filter === 'friends' ? 'active' : ''}
          onClick={() => setFilter('friends')}
          disabled={!user}
        >
          친구
        </button>
        <button 
          className={filter === 'following' ? 'active' : ''}
          onClick={() => setFilter('following')}
          disabled={!user}
        >
          팔로잉
        </button>
      </div>

      {/* 콘텐츠 영역 */}
      <div className="feed-content">
        {(() => {
          // 에러 상태
          if (error) {
            return (
              <div className="error-state">
                <h3>피드를 불러올 수 없습니다</h3>
                <p>{error.message}</p>
                <button onClick={loadPosts} className="retry-btn">
                  다시 시도
                </button>
              </div>
            );
          }

          // 로딩 상태
          if (isLoading) {
            return (
              <div className="loading-state">
                {/* 스켈레톤 UI */}
                {[...Array(3)].map((_, index) => (
                  <PostSkeleton key={index} />
                ))}
              </div>
            );
          }

          // 빈 상태
          if (posts.length === 0) {
            return (
              <div className="empty-state">
                {filter === 'all' ? (
                  <div>
                    <h3>아직 포스트가 없습니다</h3>
                    <p>첫 번째 포스트를 작성해보세요!</p>
                    {user && <button className="create-post-btn">포스트 작성</button>}
                  </div>
                ) : (
                  <div>
                    <h3>{filter === 'friends' ? '친구' : '팔로잉'}의 포스트가 없습니다</h3>
                    <p>더 많은 사람들과 연결해보세요!</p>
                    <button className="discover-btn">사람 찾기</button>
                  </div>
                )}
              </div>
            );
          }

          // 정상 포스트 목록
          return (
            <div className="posts-list">
              {posts.map(post => (
                <PostCard
                  key={post.id}
                  post={post}
                  currentUser={user}
                  onLike={() => handleLike(post.id)}
                />
              ))}
            </div>
          );
        })()}
      </div>
    </div>
  );
};

const PostCard = ({ post, currentUser, onLike }) => {
  const [showComments, setShowComments] = useState(false);
  const [isExpanded, setIsExpanded] = useState(false);

  const maxContentLength = 200;
  const shouldTruncate = post.content.length > maxContentLength;

  return (
    <article className="post-card">
      {/* 포스트 헤더 */}
      <div className="post-header">
        <div className="author-info">
          <img src={post.author.avatar} alt={post.author.name} />
          <div>
            <h4>{post.author.name}</h4>
            {post.author.isVerified && <span className="verified">✓</span>}
            <time>{formatTimeAgo(post.createdAt)}</time>
          </div>
        </div>
        
        {currentUser && currentUser.id === post.author.id && (
          <button className="post-menu">⋮</button>
        )}
      </div>

      {/* 포스트 내용 */}
      <div className="post-content">
        {shouldTruncate && !isExpanded ? (
          <div>
            <p>{post.content.slice(0, maxContentLength)}...</p>
            <button 
              className="expand-btn"
              onClick={() => setIsExpanded(true)}
            >
              더 보기
            </button>
          </div>
        ) : (
          <div>
            <p>{post.content}</p>
            {shouldTruncate && isExpanded && (
              <button 
                className="collapse-btn"
                onClick={() => setIsExpanded(false)}
              >
                접기
              </button>
            )}
          </div>
        )}
        
        {/* 이미지가 있는 경우 */}
        {post.images && post.images.length > 0 && (
          <div className="post-images">
            {post.images.length === 1 ? (
              <img src={post.images[0]} alt="포스트 이미지" />
            ) : (
              <div className="image-grid">
                {post.images.slice(0, 4).map((image, index) => (
                  <div key={index} className="image-item">
                    <img src={image} alt={`포스트 이미지 ${index + 1}`} />
                    {index === 3 && post.images.length > 4 && (
                      <div className="more-images">
                        +{post.images.length - 4}
                      </div>
                    )}
                  </div>
                ))}
              </div>
            )}
          </div>
        )}
      </div>

      {/* 포스트 액션 */}
      <div className="post-actions">
        <button 
          className={`like-btn ${post.isLiked ? 'liked' : ''}`}
          onClick={onLike}
          disabled={!currentUser}
        >
          {post.isLiked ? '❤️' : '🤍'} {post.likesCount}
        </button>
        
        <button 
          className="comment-btn"
          onClick={() => setShowComments(!showComments)}
        >
          💬 {post.commentsCount}
        </button>
        
        <button className="share-btn">
          🔗 공유
        </button>
      </div>

      {/* 댓글 섹션 */}
      {showComments && (
        <div className="comments-section">
          {currentUser ? (
            <CommentForm postId={post.id} />
          ) : (
            <div className="login-prompt">
              댓글을 작성하려면 <button>로그인</button>해주세요
            </div>
          )}
          
          {post.comments && post.comments.length > 0 ? (
            <div className="comments-list">
              {post.comments.map(comment => (
                <CommentItem key={comment.id} comment={comment} />
              ))}
            </div>
          ) : (
            <p className="no-comments">첫 번째 댓글을 작성해보세요!</p>
          )}
        </div>
      )}
    </article>
  );
};

const PostSkeleton = () => (
  <div className="post-skeleton">
    <div className="skeleton-header">
      <div className="skeleton-avatar"></div>
      <div className="skeleton-info">
        <div className="skeleton-line short"></div>
        <div className="skeleton-line shorter"></div>
      </div>
    </div>
    <div className="skeleton-content">
      <div className="skeleton-line"></div>
      <div className="skeleton-line"></div>
      <div className="skeleton-line medium"></div>
    </div>
    <div className="skeleton-actions">
      <div className="skeleton-button"></div>
      <div className="skeleton-button"></div>
      <div className="skeleton-button"></div>
    </div>
  </div>
);
```

### 성능 최적화 팁

#### 1. 조건부 렌더링에서 컴포넌트 마운팅 최적화
```jsx
// ❌ 매번 새 컴포넌트 인스턴스 생성
const App = ({ showModal }) => (
  <div>
    {showModal && <ExpensiveModal />}
  </div>
);

// ✅ 조건부 스타일링으로 최적화
const App = ({ showModal }) => (
  <div>
    <ExpensiveModal 
      style={{ display: showModal ? 'block' : 'none' }} 
    />
  </div>
);
```

#### 2. 메모이제이션을 활용한 조건부 렌더링
```jsx
const ConditionalComponent = ({ condition, data }) => {
  const expensiveComponent = useMemo(() => 
    condition ? <ExpensiveComponent data={data} /> : null,
    [condition, data]
  );
  
  return (
    <div>
      <h1>메인 콘텐츠</h1>
      {expensiveComponent}
    </div>
  );
};
```

### 학습 정리 

#### 핵심 개념 요약

1. **상향식 데이터 전달**
   - 자식이 부모의 상태를 직접 변경할 수 없음
   - 부모로부터 함수를 받아서 호출하는 패턴
   - 단방향 데이터 흐름 유지

2. **동적 리스트 렌더링**
   - `map()` 메서드를 활용한 배열 렌더링
   - `key` prop의 중요성과 올바른 사용법
   - 성능 최적화를 위한 React.memo, useCallback 활용

3. **조건부 렌더링**
   - 다양한 패턴: 삼항연산자, &&, ||, IIFE
   - 실전 활용: 로딩, 에러, 빈 상태 처리
   - 성능 고려사항

