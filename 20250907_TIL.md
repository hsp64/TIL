# 25년 9월 7일


---

# React 인증/인가  패턴 TIL


#### Authentication vs Authorization
- **Authentication (인증)**: "너 누구야?" - 사용자 신원 확인
- **Authorization (인가)**: "너 이거 할 수 있어?" - 권한 확인

---

## 2024-2025 트렌드 패턴

### JWT + Refresh Token 패턴

```typescript
// 토큰 관리 훅
const useAuth = () => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  const login = async (credentials) => {
    const { accessToken, refreshToken, user } = await authAPI.login(credentials);
    
    // httpOnly 쿠키에 refresh token 저장
    // 메모리에 access token 저장
    tokenManager.setTokens(accessToken, refreshToken);
    setUser(user);
  };

  // 자동 토큰 갱신
  useEffect(() => {
    const interceptor = axios.interceptors.response.use(
      (response) => response,
      async (error) => {
        if (error.response?.status === 401) {
          await refreshAccessToken();
          return axios.request(error.config);
        }
        return Promise.reject(error);
      }
    );

    return () => axios.interceptors.response.eject(interceptor);
  }, []);
};
```

**핵심 특징:**
- Access Token은 메모리에, Refresh Token은 httpOnly 쿠키에 분리 저장
- Axios 인터셉터를 활용한 자동 토큰 갱신
- XSS 공격 방지를 위한 보안 강화 패턴
- 토큰 만료 시 자동으로 재요청 처리

### Context + Reducer 패턴 (상태관리)

```typescript
// AuthContext
interface AuthState {
  user: User | null;
  loading: boolean;
  error: string | null;
}

const authReducer = (state: AuthState, action: AuthAction) => {
  switch (action.type) {
    case 'AUTH_START':
      return { ...state, loading: true, error: null };
    case 'AUTH_SUCCESS':
      return { ...state, loading: false, user: action.payload };
    case 'AUTH_FAILURE':
      return { ...state, loading: false, error: action.payload };
    case 'LOGOUT':
      return { user: null, loading: false, error: null };
    default:
      return state;
  }
};

// Provider 컴포넌트
export const AuthProvider = ({ children }) => {
  const [state, dispatch] = useReducer(authReducer, initialState);
  
  return (
    <AuthContext.Provider value={{ ...state, dispatch }}>
      {children}
    </AuthContext.Provider>
  );
};
```

**핵심 특징:**
- useReducer를 활용한 예측 가능한 상태 관리
- 인증 관련 모든 상태를 중앙 집중식으로 관리
- 액션 기반의 명확한 상태 변경 로직
- TypeScript를 활용한 타입 안전성 확보

### Protected Routes (라우트 보호)

```typescript
// 보호된 라우트 컴포넌트
const ProtectedRoute = ({ 
  children, 
  requiredRoles = [],
  fallback = <Navigate to="/login" />
}) => {
  const { user, loading } = useAuth();

  if (loading) return <Spinner />; // 로딩

  if (!user) return fallback; // 미인증

  // 역할 기반 접근 제어 (RBAC)
  if (requiredRoles.length > 0) {
    const hasPermission = requiredRoles.some(role => 
      user.roles.includes(role)
    );
    
    if (!hasPermission) {
      return <Navigate to="/unauthorized" />;
    }
  }

  return <>{children}</>;
};

// 라우터 설정
<Routes>
  <Route path="/login" element={<Login />} />
  <Route path="/dashboard" element={
    <ProtectedRoute>
      <Dashboard />
    </ProtectedRoute>
  } />
  <Route path="/admin" element={
    <ProtectedRoute requiredRoles={['admin']}>
      <AdminPanel />
    </ProtectedRoute>
  } />
</Routes>
```

**핵심 특징:**
- 컴포넌트 기반의 라우트 보호 시스템
- RBAC(Role-Based Access Control) 지원
- 로딩 상태와 에러 상태에 대한 적절한 처리
- 유연한 fallback 컴포넌트 설정 가능

---

## 최신 라이브러리 & 도구

### 추천 라이브러리

#### Auth0 SDK
```bash
npm install @auth0/auth0-react
```
```typescript
import { useAuth0 } from '@auth0/auth0-react';

const { loginWithRedirect, logout, user, isAuthenticated } = useAuth0();
```

**특징:** 완전 관리형 서비스, 소셜 로그인 지원, 엔터프라이즈 기능

#### Supabase Auth
```bash
npm install @supabase/auth-helpers-react
```
```typescript
import { useUser, useSupabaseClient } from '@supabase/auth-helpers-react';

const user = useUser();
const supabase = useSupabaseClient();
```

**특징:** 오픈소스 기반, 실시간 기능, PostgreSQL 기반 RLS

#### NextAuth.js (Next.js 전용)
```typescript
import { useSession } from 'next-auth/react';

const { data: session, status } = useSession();
```

**특징:** Next.js 최적화, 다양한 프로바이더 지원, 서버사이드 렌더링 지원

### 보안 모범 사례

#### 권장사항
```typescript
// httpOnly 쿠키 설정
const setSecureCookie = (name, value) => {
  document.cookie = `${name}=${value}; HttpOnly; Secure; SameSite=Strict`;
};

// CSRF 토큰 검증
const apiCall = async (url, options) => {
  const csrfToken = await getCSRFToken();
  return fetch(url, {
    ...options,
    headers: {
      ...options.headers,
      'X-CSRF-Token': csrfToken,
    },
  });
};
```

**보안 체크리스트:**
- httpOnly 쿠키에 refresh token 저장 (XSS 방지)
- HTTPS 사용 필수 (중간자 공격 방지)
- CSRF 토큰 활용 (CSRF 공격 방지)
- 토큰 만료 시간 적절히 설정 (15분~1시간)
- localStorage 민감한 토큰 저장 금지
- 서버 사이드 토큰 검증 필수

---

## UI/UX 패턴

### 로딩 상태 관리
```typescript
const AuthGuard = ({ children }) => {
  const { user, loading, error } = useAuth();

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <Spinner size="lg" />
      </div>
    );
  }

  if (error) {
    return <ErrorBoundary error={error} />;
  }

  return user ? children : <LoginPage />;
};
```

**UX 고려사항:**
- 인증 확인 중 적절한 로딩 UI 제공
- 에러 상황에 대한 명확한 피드백
- 인증 실패 시 사용자 친화적인 안내
- 자동 리다이렉트와 수동 리다이렉트의 적절한 구분

### 조건부 렌더링
```typescript
const Navigation = () => {
  const { user, logout } = useAuth();

  return (
    <nav>
      {user ? (
        <>
          <span>안녕하세요, {user.name}님!</span>
          <button onClick={logout}>로그아웃</button>
        </>
      ) : (
        <Link to="/login">로그인</Link>
      )}
    </nav>
  );
};
```

**렌더링 패턴:**
- 인증 상태에 따른 동적 UI 변경
- 사용자 정보를 활용한 개인화된 UI
- 로그아웃 기능의 직관적인 배치
- 접근 권한에 따른 메뉴 항목 필터링

---

## 테스팅 전략

### 테스트 패턴
```typescript
// Mock 인증 컨텍스트
const renderWithAuth = (component, { user = null } = {}) => {
  const mockAuthContext = {
    user,
    loading: false,
    login: jest.fn(),
    logout: jest.fn(),
  };

  return render(
    <AuthContext.Provider value={mockAuthContext}>
      {component}
    </AuthContext.Provider>
  );
};

// 테스트 예시
test('인증된 사용자에게 대시보드를 보여준다', () => {
  const mockUser = { id: 1, name: 'John' };
  renderWithAuth(<Dashboard />, { user: mockUser });
  
  expect(screen.getByText('대시보드')).toBeInTheDocument();
});
```

**테스트 전략:**
- 인증 컨텍스트를 모킹한 유닛 테스트
- 인증/비인증 상태별 렌더링 테스트
- 권한 기반 접근 제어 테스트
- 토큰 갱신 로직에 대한 통합 테스트

---

## 성능 최적화

### 최적화 팁
```typescript
const Dashboard = lazy(() => import('./Dashboard'));

<Suspense fallback={<AuthSkeleton />}>
  <ProtectedRoute>
    <Dashboard />
  </ProtectedRoute>
</Suspense>
```

**최적화 전략:**
- 코드 스플리팅을 통한 인증 관련 컴포넌트 lazy loading
- useMemo를 활용한 권한 체크 결과 캐싱
- Suspense를 이용한 인증 상태 확인 중 fallback UI
- 불필요한 리렌더링 방지를 위한 메모이제이션 적용
