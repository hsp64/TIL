## 2025년 5월 14일
 
---

# Collaborator 와 README.md
 - Collaborator는 특정 GitHub repository에 기여할 수 있도록 초대된 사용자이다. 프로젝트 소유자와 함께 협업할 수 있는 권한을 부여받는다.

   1. Collaborator의 주요 권한
      - 코드 푸시(push) : 로컬에서 변경한 코드를 원격 repository에 직접 푸시할 수 있음
      - 이슈 관리 (Issue Management) : 이슈 생성, 댓글 작성, 이슈 닫기 등이 가능.
      - 풀 리퀘스트 관리 (Pull Request Handling) : 다른 기여자의  PR을 열람, 코멘트, 병합(Merge), 거절(Clpose) 가능.
      - 문서화 기능 관리 (Docs & Pages) : Wiki 수정, GitHub Pages 설정 등 문서 관련 작업 가능.

  2. Collaborator는 관리자 권한은 없다.
     - 다른 Collaborator 초대 X
     - Repository 삭제/이름 변경 X
     - Settings 접근 권한 X

# GitHub의 README.md 파일
 - README.md GitHub 저장소의 첫 화면에 자동으로 표시되는 문서로 프로젝트를 소개하고 사용하는 방법을 안내하는 가장 중요한 문서입니다.

   1. 주요 기능
      1) 프로젝트 개요
         - 프로젝트의 목적, 기능, 주요 특징 등을 간단히 설명
         - 다른 사람이 프로젝트를 빠르게 이해하도록 도움
      2) 설치 방법 안내
         - 필요한 의존성, 설치 순서, 설정 방법 등을 제공
         - 누구나 프로젝트를 쉽게 실행해볼 수 있도록 구성
      3) 사용법 설명
         - 명령어, 예제 코드, 실행 결과 등을 통해 사용 방법 안내
         - 초보자도 따라 하기 쉽게 작성
      4) 기여 가이드
         - PR, Branch 규칙 등 기여 시 지켜야 할 사항 소개
         - 외부 기여자가 협업하기 쉽게 가이드 제공
      5) 라이선스 명시
         - 오픈소스 여부와 사용 가능 범위를 명확히 설명
         - 저작권 보호 및 법적 사용 조건 안내

# Markdown이란?
  - 간단한 문법으로 텍스트에 서식을 입힐 수 있는 경량 마크업 언어이고 HTML로 자동변환되며 지금 쓰고있는 TIL도 .md 파일이다.
    1. 제목 (Headers) : # 기호로 제목의 수준을 표현
                        HTML의 <h1> ~ <h6>에 대응됨
    2. 텍스트 강조 : 스타일           마크다운 문법                       예시 결과      
                    이탤릭체         `*text*` 또는 `_text_`             *text*     
                    볼드체           `**text**` 또는 `__text__`         **text**   
                    이탤릭 + 볼드    `**_text_**` 또는 `__*text*__`     ***text*** 

 
    3. 목록 
       - 순서 없는 목록: -, *, +
       - 순서 있는 목록: 1., 2. 등
         - 항목 A
         - 항목 B
         1. 첫 번째
         2. 두 번째

    4. 링크 & 이미지
       - 링크 : [텍스트](URL)
       - 이미지 : ![설명](이미지URL)
        [GitHub](https://github.com)
        ![Logo](https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png)

    5. 인용문
       - > 기호를 사용
         > 이것은 인용문입니다.
         
    6. 코드 작성
       - 인라인 코드: 백틱(`) 사용 → `코드`
       - 코드 블록: 백틱 3개로 감싸기
      <pre> <code> ```javascript console.log("Hello Markdown!"); ``` </code> </pre>   
      
    7. 수평선 (구분선)
       - 아래 중 아무거나 사용:
         ---
         ***
         ___
         
    8. 표 만들기
       - 구분선 |와 - 사용
        | 이름  | 나이 |
        |------ |------|
        | 홍길동 | 30 |
        | 김영희 | 25 |

    9. 참고 자료
        - [Markdown 공식 문서](https://daringfireball.net/projects/markdown/syntax)
        - [Markdown 실습 사이트](https://markdown-it.github.io/)
   
# Git 중앙집중형 워크플로우(Centralized Workflow)
  - SVN(Subversion) 같은 중앙집중형 VCS에 익숙한 팀이 Git을 사용할 때 가장 쉽게 적용 가능한 방식입니다.
  - 하나의 중앙 원격 저장소(origin) 를 중심으로 모든 개발자가 직접 푸시합니다.
  - 일반적으로 main 또는 master 브랜치 하나만 사용하며, 별도의 브랜치 전략 없이 협업합니다.
    1. 기본 흐름
       1) 원격 저장소를 clone 하여 로컬 저장소를 만듭니다.
       2) 로컬에서 코드 수정 → add → commit 으로 변경 사항을 저장합니다.
       3) 원격 저장소(origin)에 직접 push하여 다른 사람들과 공유합니다.
    2. 특징
       1) 구조가 단순해 Git 초보자나 소규모 팀에 적합
       2) 협업 충돌 가능성이 높아 대규모 팀이나 병렬 개발에는 비효율적일 수 있음
       3) 브랜치를 별도로 나누지 않기 때문에 관리가 쉬운 대신 기능별 관리나 테스트 분리가 어려움

# 중앙집중형 워크플로우의 문제점
  - 중앙집중형 워크플로우는 구조가 단순한 대신, 다음과 같은 단점이 있습니다
    1. 충돌 위험 증가
       - 모든 개발자가 하나의 브랜치(main/master) 에 직접 푸시하기 때문에 동시에 여러 명이 작업하면 충돌(Conflict) 이 자주 발생할 수 있음
    2. 코드 품질 관리 어려움
       - Pull Request(PR) 기반 코드 리뷰 없이 푸시되므로 버그나 테스트 누락된 코드가 바로 반영될 가능성이 있음       
    3. 테스트/배포 분리가 어려움
       - 개발, 테스트, 배포 단계를 나누기 어려워 배포 중 실수나 불안정한 코드 반영 위험이 있음 
    4. 기능 개발의 병렬 작업 비효율
       -기능별 브랜치가 없기 때문에 여러 기능을 동시에 개발하거나 분리 관리하는 데 비효율적임      
    5. 되돌리기 불편
       -실수로 문제가 있는 코드를 푸시한 경우 복구 작업이 복잡하고 기록 추적이 어려워질 수 있음

# Feature Branch Workflow
  - Feature Branch Workflow는 Git의 branch 기능을 활용한 워크플로우 방식으로 각 기능개발이나 버그 해결을 위해 작업을 별도의 브랜치에서 진행하고
    완료된 후에는 master 브랜치로 병합하는 방식입니다.
    1. 기본 흐름
       1) 기능(feature) 개발이나 버그 해결을 위해 새로운 브랜치를 생성합니다.
       2) 생성된 브랜치에서 작업을 진행하고 커밋합니다.
       3) 작업이 완료되면, master 브랜치로 병합합니다.
    2. 특징
       1) master 브랜치는 항상 안정적인 상태를 유지하며 각 개발자는 자신의 브랜치에서 자유롭게 작업을 할 수 있습니다.
       2) 코드 리뷰와 테스트를 각 브랜치에서 별도로 진행할 수 있어 품질 관리가 용이합니다.

# 중앙집중형 워크플로우 vs Feature Branch Workflow
  - 
    1. 중앙집중형 워크플로우
       1) 모든 개발자가 master 브랜치에서 직접 작업을 진행
       2) 코드 충돌이 발생할 확률이 높고 master 브랜치의 안정성을 유지하기 어려움
   
    2. Feature Branch Workflow
       1) 각 개발자는 별도의 브랜치에서 작업
       2) 코드 충돌을 최소화하고 각 브랜치에서 개발 및 테스트 후 master로 병합되므로 master 브랜치의 안정성을 유지할 수 있음
       3) 코드 품질과 안정성 유지에 유리함

# Master 브랜치의 무결성
  - master 브랜치는 프로젝트에서 가장 중요한 **"기본 브랜치"**로 여겨집니다. 무결성을 유지하는 것이 매우 중요합니다.

    1. Master 브랜치의 무결성 특징
       1) 안정성 : master 브랜치는 배포 가능한 안정된 버전을 유지.
       2) 신뢰성 : 모든 기능 개발 및 버그 수정은 별도의 브랜치에서 작업 후 충분히 테스트되고 검토된 후에 master로 병합.
       3) 일관성 : master 브랜치는 프로젝트의 진실의 소스로 간주되어야 하며, 최신 코드가 반영되어야 합니다.
    2. 무결성 유지 방법
       1) 직접 커밋을 피하고 작업을 별도의 브랜치에서 진행 후 코드 리뷰 및 테스트 과정을 거쳐 master로 병합하는 방식이 일반적입니다.

# Pull Request & Fork
  - Pull Request (PR)
  - **Pull Request (PR)**는 개발자가 자신이 작업한 브랜치를 원격 저장소의 타겟 브랜치(일반적으로 master 또는 main)와 병합하는 것을 제안하는 기능입니다.
  - PR은 코드 리뷰와 피드백을 통해 프로젝트의 코드 품질을 높이는 데 중요한 역할을 합니다.
    1. PR 단계
       1) 개발자는 새로운 브랜치를 만들고 이 브랜치에서 작업을 수행합니다.
       2) 작업이 완료되면 개발자는 작업한 브랜치를 원격 저장소에 푸시합니다.
       3) 원격 저장소(GitHub 등)에서 개발자는 새로 푸시한 브랜치를 기반으로 Pull Request를 생성합니다. 이때 병합을 요청하는 대상 브랜치와 PR 제목 및 설명 관련 이슈 등을 포함하여 생성합니다.
       4) 다른 개발자들이 해당 PR을 리뷰하고 피드백을 제공하고 필요하다면 추가적인 수정 요청을 할 수 있습니다.
       5) 피드백을 반영한 후 리뷰어의 승인이 있으면 PR을 타겟 브랜치에 병합할 수 있습니다.
    
    2. PR의 중요성
       1) 코드 품질 유지 : PR을 통해 코드 리뷰와 피드백을 거쳐 코드 품질을 개선할 수 있습니다.
       2) 프로젝트 안정성 유지 : PR을 통해 변경 사항을 팀원들이 인지하고 이해하며 안정성을 유지할 수 있습니다.

# GitHub의 main branch 보호하기
  1. 보호 브랜치(Protected Branch)
    1) GitHub에서는 중요한 브랜치를 보호하기 위한 보호 브랜치(Protected Branch) 기능을 제공합니다.
    2) main 또는 master와 같은 기본 브랜치는 프로젝트의 핵심적인 부분을 담고 있기 때문에 잘못된 수정이나 삭제를 방지하기 위해 보호 설정을 하는 것이 좋습니다.

  2. 보호 브랜치 설정을 통한 제한 사항
     1) 포스 푸시(Force Push) 차단 : 보호 브랜치에 대한 포스 푸시를 차단하여 기존 커밋 히스토리를 덮어쓰는 것을 방지합니다.
     2) 삭제 방지 : 보호 브랜치의 삭제를 방지합니다.
     3) Pull Request 리뷰 강제 : 변경 사항을 브랜치에 직접 푸시하기 전에 Pull Request를 통해 코드 리뷰를 받는 것을 강제합니다.
     4) 상태 체크 통과 강제 : 테스트나 빌드 등의 상태 체크를 통과하지 않은 코드는 병합이 불가능하도록 설정합니다.
  
  3. 보호 브랜치 설정 단계
     1) 레포지토리의 Settings 탭으로 이동합니다.
     2) 좌측 사이드바에서 rulesets를 클릭합니다.
     3) Branch protection rules 섹션에서 Add rule을 클릭합니다.
     4) 보호하고자 하는 브랜치 이름(main 또는 master 등)을 입력하거나 패턴을 사용하여 여러 브랜치를 선택합니다.
     5) 필요한 보호 옵션을 선택하고 Create 또는 Save changes를 클릭합니다.

  4. 보호 브랜치의 중요성
     1) 보호 브랜치는 프로젝트의 무결성을 유지하고 실수를 방지하는 데 도움이 됩니다.
     2) 이를 통해 안정적인 개발 환경을 유지할 수 있습니다.

# GitHub의 Fork
  - GitHub에서 Fork는 다른 사람의 원격 레포지토리를 자신의 GitHub 계정으로 복제하는 것을 말합니다.
    1. Fork의 개념
       1) Fork를 사용하면 원래 레포지토리의 권한 없이도 복제본을 자유롭게 수정하고 활용할 수 있습니다.
       2) 만들어진 복제본은 원본 레포지토리와 독립적으로 동작하며 이를 통해 다음과 같은 작업을 할 수 있습니다.
       3) 프로젝트를 자신의 계정으로 가져와서 새로운 기능을 추가하거나 버그를 수정할 수 있습니다.
       4) 자신이 수정한 내용을 원본 레포지토리에 반영해달라고 Pull Request를 보낼 수 있습니다.
    2. Fork의 사용
       - GitHub에서 'Fork'는 다른 사람의 원격 레포지토리를 자신의 계정으로 복제하는 기능입니다.
         이 기능을 통해 개발자는 원본 프로젝트의 소유권 없이 해당 프로젝트를 자유롭게 수정하거나 개선할 수 있습니다.
    3. Fork의 사용 과정
       1) 원하는 프로젝트를 Fork하여 자신의 GitHub 계정에 복제본을 생성합니다.
       2) 복제본에서 새로운 기능을 추가하거나 버그를 수정한 후 원본 레포지토리로 변경 사항을 반영하고자 Pull Request를 보냅니다.
    4. Fork의 역할
       1) 협업 촉진 : Fork는 여러 개발자가 각자의 계정에서 독립적으로 작업하면서도 원본 프로젝트에 기여할 수 있게 합니다.
       2) 오픈 소스 기여 : Fork는 오픈 소스 프로젝트에서 다른 개발자들이 자유롭게 기여하고 개선할 수 있는 중요한 기능입니다.

# Fork Workflow
  - 다른 사람의 프로젝트에 기여하는 방법 GitHub에서 다른 사람의 프로젝트에 기여하기 위한 fork workflow는 몇 가지 단계로 구성됩니다.
    이 워크플로우는 협업을 쉽게 하고 원본 프로젝트에 직접 영향을 주지 않도록 합니다. 
    1. 프로젝트 포크(Fork)
       - **포크(Fork)**는 다른 사람의 GitHub 저장소를 자신의 계정으로 복사하는 과정입니다.
         단계 : 1) GitHub에서 기여하고자 하는 프로젝트의 페이지로 이동합니다.
                2) 오른쪽 상단에 있는 Fork 버튼을 클릭합니다.
                3) 자신의 GitHub 계정을 선택합니다. 그러면 해당 프로젝트가 자신의 계정으로 복사됩니다.
    2. 로컬 저장소 클론(Clone)
       - 포크한 프로젝트를 로컬 컴퓨터로 클론하여 작업을 시작합니다.
         단계 : 1) 자신의 GitHub 계정에서 포크한 저장소로 이동합니다.
                2) Code 버튼을 클릭하고 URL을 복사합니다.
                3) 터미널을 열고 다음 명령어를 실행합니다.
                   git clone <포크한 저장소의 URL>
                4) 저장소 디렉토리로 이동합니다.
                   cd project-name
    3. 원본 저장소 추가
       - 원본 프로젝트의 업데이트를 추적할 수 있도록 원본 저장소를 upstream으로 추가합니다.
         단계 : 1) 원본 저장소의 URL을 복사합니다.
                  (보통 https://github.com/original-owner/project-name.git)
                2) 다음 명령어를 실행하여 원본 저장소를 upstream으로 추가합니다.
                   git remote add upstream <원본 저장소의 URL>
                3) 설정이 제대로 되었는지 확인하려면 다음 명령어를 실행합니다.
                   git remote -v
    4. 브랜치 생성 및 변경 사항 작업
       - 새로운 기능을 추가하거나 버그를 수정하기 위해 브랜치를 만듭니다.
         단계 : 1) 새로운 브랜치를 생성하고 체크아웃합니다.
                   git switch -c feature-branch-name
    5. 변경 사항 커밋 및 푸시
       - 로컬에서 작업을 완료한 후, 변경 사항을 커밋하고 자신의 GitHub 저장소로 푸시합니다.
         단계 : 1) 변경 사항을 스테이징합니다.
                   git add .
                2) 변경 사항을 커밋합니다.
                   git commit -m "Add new feature or fix bug"
                3) 브랜치를 자신의 GitHub 저장소로 푸시합니다.
                   git push origin feature-branch-name
    6. Pull Request 생성
       - 변경 사항을 원본 프로젝트에 반영하도록 요청합니다.
         단계 : 1) 자신의 GitHub 저장소로 이동합니다.
                2) 푸시한 브랜치를 선택합니다.
                3) Pull Request 버튼을 클릭합니다.
                4) 제목과 설명을 작성하고, 변경 사항을 설명합니다.
                5) Create Pull Request 버튼을 클릭하여 PR을 생성합니다.
    7. 코드 리뷰 및 피드백 반영
       - 원본 프로젝트의 유지관리자가 PR을 리뷰하고 피드백을 제공하면, 해당 피드백을 반영합니다.
        단계 : 1) 유지관리자의 피드백을 확인합니다.
               2) 필요한 경우 로컬에서 수정 작업을 합니다.
               3) 수정된 내용을 커밋하고 푸시합니다.
                   git add .
                   git commit -m "Address review feedback"
                   git push origin feature-branch-name
                   PR에 변경 사항이 자동으로 반영됩니다.

    8. PR 머지 및 정리
       - PR이 승인되고 머지되면, 로컬 및 원격 저장소를 정리합니다.
        단계 : 1) main 브랜치로 돌아갑니다:
                 git checkout main
              2) upstream 저장소에서 최신 변경 사항을 가져옵니다.
                 git pull upstream main
              3) 자신의 포크된 저장소에 최신 변경 사항을 푸시합니다.
                 git push origin main
              4) 작업이 완료된 브랜치를 삭제합니다.
                 git branch -d feature-branch-name
                 git push origin --delete feature-branch-name
                 이 과정을 통해 다른 사람의 GitHub 프로젝트에 안전하고 체계적으로 기여할 수 있습니다.
