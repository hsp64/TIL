# Git Rebase

  1. Git Merge vs. Git Rebase
     - Git에서는 브랜치를 통합할 때 merge와 rebase 두 가지 방식을 사용할 수 있습니다. 각각의 작동 방식과 장단점을 비교해보겠습니다.

  2. Git Merge
     - Merge는 두 브랜치의 변경 내용을 새로운 병합 커밋으로 통합하는 방식입니다.
       git switch main
       git merge feature-branch
       1) 특징
          - 공통 조상 커밋 이후의 변경사항을 병합하여 새 커밋 하나로 합침
          - 기존 커밋 히스토리는 변경 없이 유지
       2) 장점
          - 히스토리 보존 : 누가 언제 어떤 작업을 했는지 그대로 남아 있어 추적이 용이함
          - 안정적인 협업 : 공유된 브랜치나 협업 브랜치에서 안전하게 사용 가능
       3) 단점
          - 복잡한 히스토리 : 브랜치가 많아지면 병합 커밋이 많아져 로그가 지저분해질 수 있음

  3. Git Rebase
     - Rebase는 현재 브랜치의 커밋을 다른 브랜치의 최신 커밋 위에 재적용하는 방식입니다.
       git checkout feature-branch
       git rebase main
       1) 특징
          - 현재 브랜치의 커밋을 다시 작성해서 선형적인 히스토리를 만듦
          - 히스토리가 깔끔하게 정리되지만 커밋의 SHA가 변경됨
       2) 장점
          - 선형적인 히스토리 : 커밋 로그가 한 줄로 정리되어 가독성이 좋음
          - 리뷰/디버깅 효율 : 변경사항을 순서대로 파악하기 쉬움
          - 충돌 조기 해결 : 병합 전에 미리 충돌을 해결할 수 있어 나중에 더 수월함
       3) 단점
          - 히스토리 재작성 : 이미 공유된 브랜치에서 사용하면 충돌과 혼란 발생
          - 충돌이 많을 경우 번거로움 : 여러 커밋을 순차적으로 재적용하며 충돌을 각각 해결해야 함       
  
  4. 언제 Merge, 언제 Rebase?

     | 상황                                       | 추천 방식  | 이유                          |
     | ----------------------------------------- | --------- | ----------------------------- |
     | 개인 브랜치에서 최신 코드로 정리하고 싶을 때  |  Rebase | 선형 히스토리 유지, 깔끔한 로그 |
     | 공유된 브랜치(메인 브랜치 포함)와 병합할 때   |  Merge  | 히스토리 보존, 안전한 병합      |
     | 협업 브랜치에서 여러 명이 동시에 작업 중일 때 |  Merge  | 히스토리 공유를 깨뜨리지 않음   |

  6. Rebase 피해야 할 상황
     1) 다른 사람과 공유된 브랜치
        - 커밋이 바뀌면 팀원의 히스토리와 충돌 → push --force 필수 → 위험도 증가
     2) 협업 브랜치
        - 팀원이 많을수록 커밋 히스토리 충돌 가능성 커짐
  7. 결론
    - Merge : 안정적이고 협업에 유리, 히스토리 추적이 중요한 경우 사용
    - Rebase : 개인 작업 정리에 적합, 히스토리를 깔끔하게 정리하고 싶을 때 사용

  8. 실전 팁
     1) 작업 중 : feature-branch에서 main을 주기적으로 rebase하여 최신 상태 유지
     2) 작업 완료 후 : 최종적으로는 main에 merge하여 기록을 보존

  # Git Rebase 실무 주의사항 정리
    - Git rebase는 히스토리를 정리하고 깔끔하게 만드는 강력한 기능이지만, 실무에서는 잘못 사용할 경우 협업에 큰 문제를 일으킬 수 있습니다. 
      아래의 주의사항을 숙지하고 상황에 맞게 사용하는 것이 중요합니다.
  
   1. 공개된 브랜치에서는 사용 금지
      - 커밋 히스토리 변경 : rebase는 커밋 SHA를 바꾸기 때문에 이미 공유된 브랜치에서 실행하면 팀원들과 히스토리가 불일치합니다.
      - 협업에 혼란 초래 : 다른 팀원이 pull 할 때 충돌 및 예기치 않은 오류 발생 가능성 높음.
      - 원칙 : 개인 작업 브랜치에서만 사용하고 공유 브랜치는 merge 사용
   2. 필요할 때만 사용
      - 과도한 정리 금지 : 단순히 보기 좋다는 이유로 불필요한 rebase 남용은 오히려 히스토리 추적을 어렵게 할 수 있음
      - 적절한 시점: 기능 개발 완료 후, 최종 병합 전 히스토리 정리가 필요할 때만 사용
   3. 충돌 해결에 시간 대비 계획
      - 커밋 단위 충돌 처리 : rebase는 커밋마다 충돌을 순차적으로 해결해야 함
      - 테스트 필수 : 충돌 해결 후 반드시 테스트로 기능 정상 작동 여부 확인
   4. 강제 푸시는 신중히
      - git push --force 위험 : 다른 팀원의 커밋을 덮어쓸 수 있음
      - --force-with-lease 권장 : 원격 브랜치 상태를 확인하고 푸시 → 안전성 향상
      - 팁 : 강제 푸시 전에 반드시 팀원과 상의
   5. 복구 방법 숙지
      - 중단하기 : git rebase --abort → rebase 시작 전 상태로 복구
      - 재시도 준비 : 충돌 원인을 파악하고 수정한 뒤 git rebase --continue로 진행
   6. 백업은 안전망
      - 백업 브랜치 생성 : 중요한 작업 전에 복사 브랜치를 만들어두면 만약을 대비 가능
        git switch -c backup-before-rebase
      - git reset 활용 : 특정 커밋으로 되돌릴 수 있는 방법을 익혀두기
   7. 팀 규칙에 따르기
      - 공통 규칙 마련 : 예) "개인 브랜치에서는 rebase 허용 협업 브랜치는 merge만 사용"
      - 리뷰 후 병합: rebase 후에는 반드시 코드 리뷰를 통해 변경사항 검토
   8. 정리
      
| 상황                            | 조치                                                  |
| ------------------------------- | ----------------------------------------------------- |
| 개인 브랜치에서 최신화하고 싶을 때 | Rebase 사용 가능                                       |
| 팀원이 함께 작업 중인 브랜치      | Rebase 지양, Merge 사용                                |
| 공유 전 커밋 정리                | Rebase로 깔끔하게 정리 후 Merge                         |
| 실수 방지                        | 백업 브랜치 생성 + `--abort`, `--force-with-lease` 사용 |
 [결론 : Rebase는 개발 흐름을 명확하게 정리하는 데 매우 유용하지만 협업 환경에서는 사용 시점과 방법에 신중해야 합니다. 
    “개인 브랜치에서는 자유롭게 공유 브랜치에서는 보수적으로” 사용하는 것이 안전한 Git 사용의 핵심입니다.]

# Git Interactive Rebase 정리
1. Interactive Rebase란?
- 정의 : Git 커밋 히스토리를 수정, 재정렬, 합치기, 삭제할 수 있는 상호작용 모드의 rebase 기능입니다.
- 주 용도 : 깔끔한 커밋 히스토리 유지, 의미 없는 커밋 제거, 커밋 메시지 정리 등.

2. 기본 사용법
- git rebase -i <기준 커밋>
- # 예: 최근 5개 커밋 정리
- git rebase -i HEAD~5
- 명령어 실행 시 텍스트 편집기에서 커밋 목록이 표시되고 각 커밋에 명령을 적용할 수 있음.

3. 커밋 명령어 설명
- pick    커밋을 그대로 유지
- reword  커밋 메시지만 수정
- edit    커밋 내용 자체를 수정
- squash  이전 커밋과 병합 (메시지 병합 가능)
- fixup   이전 커밋과 병합 (메시지 무시)
- drop    커밋 삭제

4. 예제: 커밋 병합하기
- 목표 : 아래 두 커밋을 하나로 합치기
    pick 3f5e4c8 Add feature X
    squash 2d4f5c7 Fix bug Y
- 결과 : 두 커밋이 하나로 병합되고 병합된 커밋 메시지를 수정할 수 있음.

5. 커밋 메시지 병합
- squash 사용 시 두 커밋의 메시지를 합쳐 편집 가능
- fixup 사용 시 메시지를 자동 생략하고 합쳐짐 (무음 합치기)

6.  주의사항
- 공유 브랜치에서 사용 금지: 히스토리 변경으로 협업자에게 충돌 유발
- 실수 복구 방법: git reflog로 이전 상태 추적 및 복원 가능
- rebase 중단: 문제가 생기면 git rebase --abort로 중단 가능

7. 요약
   
| 항목       | 설명                                        |
| ---------- | ------------------------------------------- |
| 사용 목적   | 커밋 정리, 병합, 삭제, 메시지 수정            |
| 주요 명령어 | pick, reword, edit, squash, fixup, drop     |
| 안전 수칙   | 개인 브랜치에서만 사용, 공유 브랜치에서는 금지 |
| 복구 방법   | `git reflog`, `git rebase --abort`          |

8. 결론
Interactive Rebase는 커밋 히스토리를 정돈하는 데 매우 유용하지만 협업 브랜치에서는 주의가 필요합니다.
올바르게 사용하면 더 이해하기 쉬운 정돈된 프로젝트 히스토리를 만들 수 있습니다.

# Git Cherry-Pick 
1. Cherry-Pick이란?
- 정의 : 다른 브랜치의 특정 커밋만을 선택적으로 현재 브랜치에 적용하는 Git 기능입니다.
- 비유 : 디저트 뷔페에서 원하는 것만 쏙쏙 골라 담듯 필요한 커밋만 골라 적용할 수 있어요.

2. 언제 사용할까?
- 다른 브랜치에서 수정된 버그 패치만 따로 적용하고 싶을 때
- 여러 기능 중 특정 기능만 가져오고 싶을 때
- 팀원의 브랜치에서 유용한 코드만 재사용하고 싶을 때
- 브랜치를 병합하지 않고 부분 변경사항만 반영하고 싶을 때

3. 기본 사용법
- 단일 커밋
  git cherry-pick <커밋해시>
- 여러 커밋
  git cherry-pick <해시1> <해시2> ...
- 연속된 커밋 범위
  git cherry-pick <시작해시>^..<끝해시>

4. 충돌 처리
- Cherry-Pick 중 충돌이 발생하면 아래 순서로 해결합니다
1) 충돌 부분 수동 수정
2) 변경 파일 스테이징
  git add <파일명>
3) Cherry-Pick 계속 진행
  git cherry-pick --continue
4) (중단하려면)
  git cherry-pick --abort

5. 실무 활용 전략
- 긴급 버그 핫픽스
  개발 브랜치에서 수정 후 해당 커밋만 cherry-pick → 릴리즈 브랜치에 빠르게 반영
- 필요한 기능만 선택
  브랜치 전체가 아닌 선별된 커밋만 골라 현재 브랜치에 적용
- 팀원 코드 재사용
  팀원의 브랜치에서 특정 커밋만 선택 → 내 브랜치에 적용

6. 주의사항
- 새로운 커밋 해시가 생성되므로 중복 반영에 주의
- 커밋 간 의존성 있는 경우, 단독 cherry-pick은 예상치 못한 오류 발생 가능
- 공유 브랜치에서는 사용 주의: 팀원 간 히스토리 불일치 가능성
- 적절한 테스트 필수: 원하는 결과가 정확히 반영되었는지 확인

7. Cherry-Pick vs Merge vs Rebase

| 방식            | 특징                                | 사용 시점                      |
| --------------- | ----------------------------------- | ------------------------------ |
| **Cherry-Pick** | 특정 커밋만 선택 적용, 새 커밋 생성   | 부분 변경만 필요한 경우          |
| **Merge**       | 전체 브랜치 통합, 커밋 히스토리 유지   | 기능/브랜치 통합 시             |
| **Rebase**      | 히스토리 선형화, 커밋 순서 재정렬 가능 | 깔끔한 히스토리 관리가 필요할 때 |

8. 요약

| 항목       | 설명                                          |
| ---------- | --------------------------------------------- |
| 주 기능     | 특정 커밋만 골라 현재 브랜치에 적용             |
| 대표 명령어 | `git cherry-pick <해시>`                      |
| 장점       | 병합 없이 부분 변경 적용 가능                   |
| 단점       | 커밋 중복, 충돌 가능성, 히스토리 복잡해질 수 있음 |
| 실무 팁    | 핫픽스, 기능 선택 적용, 팀원 코드 재활용 시 유용  |

# Git Tag 개념 정리
1. Git Tag란?
- Git 태그는 특정 커밋을 고정된 이름으로 표시하는 기능입니다.
- 보통 소프트웨어의 **릴리스 버전(v1.0, v2.1 등)**을 나타내는 데 사용됩니다.
- 브랜치와 달리 변하지 않으며 특정 시점을 영구적으로 참조할 수 있습니다.

2. 태그 종류
- Lightweight Tag (경량 태그)
- 특징 : 커밋 해시에 대한 단순 포인터 (메타데이터 없음)
- 저장 방식 : Git 객체로 따로 저장되지 않음
- 용도 : 개인적인 체크포인트 테스트용 버전 등 간단한 기록에 적합
- 생성 명령어 :
  git tag <태그이름>
  Annotated Tag (주석 태그)
- 특징 : 작성자, 날짜, 메시지, GPG 서명 등 메타데이터 포함
- 저장 방식 : Git 객체로 별도 저장
- 용도 : 공식 릴리스, 중요한 마일스톤 등 공식적인 기록에 적합
- 생성 명령어 :
  git tag -a <태그이름> -m "릴리스 메시지"

3. 태그의 활용 목적

| 목적               | 설명                                                             |
| ------------------ | ------------------------------------------------                 |
|  **버전 관리**     | 릴리스 버전(v1.0 등)을 명확히 표시하여 해당 시점을 쉽게 참조 가능    |
|  **릴리스 관리**    | 릴리스 커밋을 태그로 고정 → 해당 커밋이 정식 릴리스임을 명확히 구분  |
|  **작업 이력 기록** | 개발 중 중요한 커밋을 가볍게 표시하여 추후 추적 가능                |
|  **보안/신뢰성**    | Annotated Tag는 GPG 서명 가능 → 릴리스에 대한 **신뢰 보장**에 적합 |

4. 기타 태그 관련 명령어

| 작업                | 명령어 예시                                                      |
| ------------------- | ---------------------------------------------------------------- |
| 태그 목록 보기       | `git tag`                                                        |
| 특정 커밋에 태그 추가 | `git tag <태그이름> <커밋해시>`                                   |
| 원격에 태그 푸시      | `git push origin <태그이름>`                                     |
| 태그 삭제            | `git tag -d <태그이름>` / `git push origin :refs/tags/<태그이름>` |
| Annotated 확인       | `git show <태그이름>`                                            |

5. 요약

| 항목                | Lightweight Tag   | Annotated Tag                       |
| ------------------- | ----------------- | ----------------------------------- |
| 메타데이터 포함 여부 | 없음 X             |  있음 O (작성자, 메시지, 서명 등)     |
| 용도                | 간단한 체크포인트   | 정식 릴리스, 마일스톤 기록            |
| 저장 방식           | 커밋 포인터만 저장  | Git 객체로 별도 저장                  |
| 명령어 예시         | `git tag v1.0`     | `git tag -a v1.0 -m "릴리스 메시지"` |

# Semantic Versioning (시맨틱 버저닝)

1. Semantic Versioning (SemVer)
- 기본 형식: MAJOR.MINOR.PATCH

| 구분      | 설명                                                   |
| --------- | ------------------------------------------------------ |
| **MAJOR** | 기존 API와 **호환되지 않는 변경**이 있을 때 증가         |
| **MINOR** | 기존 API와 **호환되는 새로운 기능** 추가 시 증가         |
| **PATCH** | 기존 API와 호환되며 **버그 수정**이나 사소한 개선 시 증가  |

2. 예시
- 1.0.0: 최초 안정 릴리스
- 1.1.0: 새로운 기능 추가 (호환됨)
- 1.1.1: 버그 수정
- 2.0.0: 호환되지 않는 주요 변경

3. 추가 라벨

| 구분                | 형식 예시                     | 설명                |
| ------------------- | ----------------------------- | ------------------- |
| **프리릴리스**      | `1.0.0-alpha`, `1.0.0-beta.1` | 미리보기, 테스트 버전 |
| **빌드 메타데이터** | `1.0.0+20240515`              | 내부 식별용 메타정보  |

4. SemVer의 장점
- 버전만 보고도 변경 유형을 예측 가능
- 업그레이드 시 호환성 판단이 쉬움
- 개발자 간 명확한 의사소통 도구로 유용

5. Git Tag 관련 명령어 요약

| 기능                         | 명령어                                                 |
| ---------------------------- | ------------------------------------------------------ |
| **Lightweight Tag 생성**     | `git tag <태그이름>`                                    |
| **Annotated Tag 생성**       | `git tag -a <태그이름> -m "메시지"`                     |
| **특정 커밋에 태그 추가**    | `git tag <태그이름> <커밋해시>` *(또는 `-a` 옵션과 함께)* |
| **태그 목록 확인**           | `git tag`                                              |
| **패턴으로 태그 필터링**     | `git tag -l "<패턴>"`                                   |
| **태그 정보 확인**           | `git show <태그이름>`                                   |
| **로컬 태그 삭제**           | `git tag -d <태그이름>`                                 |
| **원격에 태그 푸시**         | `git push origin <태그이름>`                            |
| **모든 태그 원격 푸시**      | `git push origin --tags`                               |
| **태그로 체크아웃**          | `git checkout <태그이름>` *(detached HEAD 상태)*        |
| **태그 기준 새 브랜치 생성** | `git checkout -b <브랜치이름> <태그이름>`                |

# Reflog로 사라진 작업 복구하기

1. git reflog : 로컬 Git 작업의 이력 추적 도구
- git reflog는 HEAD와 브랜치 참조의 변경 이력을 로컬에 기록하는 Git의 강력한 복구 도구입니다.
- 커밋, 리셋, 체리픽, 머지 등 Git의 모든 로컬 참조 변경을 추적할 수 있습니다.

2. 핵심 개념 요약
- 주요 기능

| 사용 목적               | 설명                                                |
| ----------------------- | --------------------------------------------------- |
|  커밋 복구               | 실수로 삭제된 커밋이나 잘못된 리셋 복구 가능           |
|  HEAD 및 브랜치 이동 추적 | 이전 HEAD 또는 브랜치 위치 조회 가능                  |
|  최근 작업 내역 확인      | `git log`에 안 나오는 리셋/리베이스 이력까지 조회 가능 |


3. Reflog 형식
- HEAD@{n} : HEAD가 과거 n번째 이동했을 당시 참조
- 브랜치명@{n} : 특정 브랜치가 과거 n번째 이동했을 당시 참조
- HEAD@{time} : 특정 시간대(예: yesterday, 3.days.ago)의 참조

4. 시간 기반 참조 (timed references)

| 표현                      | 의미                        |
| ------------------------- | --------------------------- |
| `HEAD@{yesterday}`        | 어제 HEAD가 가리키던 커밋     |
| `HEAD@{2.weeks.ago}`      | 2주 전 HEAD 참조             |
| `main@{2023-08-01 14:00}` | 특정 날짜와 시간의 브랜치 참조 |
 - git reflog와 시간 기반 참조는 복구 작업에 매우 유용합니다.

5. 실전 사용 예시
1) 실수로 커밋 삭제 후 복원
  git reflog                       # 삭제된 커밋의 해시 확인
  git reset --hard HEAD@{1}       # 한 단계 전 HEAD로 복구
2) 이전 브랜치 위치 확인
  git checkout feature@{3}        # feature 브랜치의 3번째 이전 커밋으로 이동
3) 특정 시간대로 되돌리기
git reset --hard HEAD@{2.days.ago}

6. 유의 사항

| 특성                | 설명                                                       |
| ------------------- | ---------------------------------------------------------- |
|  **로컬 전용**      | `reflog`는 로컬 저장소에서만 유지되며, 원격에는 존재하지 않음  |
|  **보존 기간 한정** | 기본적으로 약 90일 보존 (GC 시 제거 가능)                    |
|  **정리 가능성**    | `git gc` 실행 시 오래된 `reflog` 기록이 삭제될 수 있음       |
 - 중요한 커밋은 브랜치나 태그로 관리해야 영구 보존됩니다.

7. 마무리 정리
- git reflog는 Git의 안전망입니다.
- 실수로 인한 데이터 손실 시 가장 먼저 확인할 명령어입니다.
- 하지만 로컬 한정 + 유효기간 있음을 꼭 기억하세요.
- 중요한 작업은 반드시 브랜치 생성 or 태그로 따로 관리하세요.

# Git 사용자 지정 Alias (별칭)

1. Git Alias란?
- Git Alias는 자주 사용하는 Git 명령어에 짧고 기억하기 쉬운 이름을 붙이는 기능입니다.
- 사용 이유
- 긴 명령어를 짧게 단축 가능 (git commit -m → git cm)
- 복잡한 명령어 조합을 단일 명령어로 축약 가능
- 팀 내 명령어 사용 일관성 유지

2. 기본 사용법
- Alias 설정
  git config --global alias.<별칭> "<실제 Git 명령어>"
  --global: 모든 Git 프로젝트에서 사용 (생략 시 현재 프로젝트에만 적용)
- <별칭> : 사용할 alias 이름
- <실제 Git 명령어> : 원래 Git 명령어 (서브커맨드만 입력, git 생략)

3. 예시
  git config --global alias.co checkout         # git co => git checkout
  git config --global alias.br branch           # git br => git branch
  git config --global alias.cm "commit -m"      # git cm "메시지" => git commit -m "메시지"
  git config --global alias.st status           # git st => git status
  git config --global alias.last "log -1 HEAD"  # git last => 가장 최근 커밋 로그 출력
4. 설정 확인
  git config --global --get-regexp alias
  현재 등록된 alias 목록을 확인합니다.

5. Alias 삭제
  git config --global --unset alias.<별칭>
  git config --global --unset alias.co
6. .gitconfig 파일 직접 수정
- ~/.gitconfig 파일을 열어서 [alias] 블록에 직접 추가/편집할 수도 있습니다.
  [alias]
  co = checkout
  br = branch
  st = status
  cm = commit -m
  lg = log --oneline --graph --decorate --all

7. 추천 Alias 모음

| Alias  | 실제 명령어                              | 설명                |
| ------ | ---------------------------------------- | ------------------- |
| `st`   | `status`                                 | 현재 상태 확인       |
| `co`   | `checkout`                               | 브랜치 이동          |
| `br`   | `branch`                                 | 브랜치 목록          |
| `cm`   | `commit -m`                              | 메시지 커밋          |
| `last` | `log -1 HEAD`                            | 가장 최근 커밋 보기   |
| `lg`   | `log --oneline --graph --decorate --all` | 깔끔한 커밋 트리 확인 |

8. 요약
- Git alias는 생산성을 높이는 도구로써, 자주 쓰는 명령어를 짧게 줄여줍니다.
- 복잡한 명령을 조합하여 별칭화하면 팀에서도 일관된 워크플로우를 구축할 수 있습니다.
- 글로벌 설정 외에도 .gitconfig 수동 편집으로 alias를 자유롭게 조절할 수 있습니다.

9. 추가 팁
1) Alias 공유
- 팀 내에서 통일된 Git alias를 사용하고자 한다면 `~/.gitconfig` 파일을 팀원들과 공유할 수 있습니다.

2) Alias와 스크립트
- 복잡한 작업을 자동화하고 싶다면, Git alias를 스크립트처럼 사용할 수 있습니다. 예를 들어 배포 과정을 간단히 하는 alias를 설정할 수 있습니다.

# 추가 보완 사항 및 실전 팁

1. git filter-branch 대신 git filter-repo 사용 권장 (중요)
- git filter-branch는 구식이며 속도가 느리고 오류 위험이 있습니다.
- Git 공식 문서에서도 이제 filter-repo 사용을 권장하고 있습니다.

1) 설치 방법 (Python 필요) :
- 설치 (pip 사용)
  pip install git-filter-repo

2)사용 예시 :
  git filter-repo --path path/to/your/file --invert-paths

- --invert-paths: 지정한 파일을 제외하고 나머지를 유지
- 히스토리 전체에서 해당 파일을 완전히 삭제
  [이 작업은 위험할 수 있으므로 백업 후 진행하는 것이 좋습니다]

2. GitHub에 푸시된 민감한 정보 빠르게 삭제하려면?
- GitHub의 Secret Scanning 기능을 활용하거나 실수로 푸시한 후 민감 정보가 노출된 경우 다음을 참고하세요.
- GitHub에 직접 삭제 요청하기
- GitHub Support 연락처 https://support.github.com/contact
- 민감한 데이터(API 키, 비밀번호, 인증서 등)는 즉시 삭제 요청

3. 팀원과 협업 시 체크리스트

| 체크 항목                   | 설명                                                                 |
| --------------------------- | -------------------------------------------------------------------- |
|  팀원에게 공지               | 히스토리가 변경되었으므로 로컬에서 `git fetch` 후 `reset` 또는 새로 클론 |
|  기존 clone 유지 시 문제 발생 | `push` 충돌, rebase 불가 등 오류 발생 가능                             |
|  권장 방식                   | 변경된 저장소를 `새로 clone`                                           |

4. 자주 묻는 질문 (FAQ)
- Q1. 민감한 정보가 있는 파일을 삭제했는데 여전히 GitHub에서 보입니다!
- A. Git은 히스토리를 저장하기 때문에 단순히 삭제만 해선 안 됩니다. 반드시 filter-branch나 filter-repo로 히스토리 자체를 수정해야 합니다.

- Q2. git push --force는 위험하지 않나요?
- A. 네, 히스토리를 덮어쓰는 명령이므로 모든 팀원과 협의 후 사용해야 하며 협업 프로젝트에선 최대한 신중히 써야 합니다.

5. 요약

| 단계                   | 설명                                                 |
| ---------------------- | ---------------------------------------------------- |
| 1️ 실수 파일 제거 및 커밋 | `git rm --cached`, `git commit`                      |
| 2️ 히스토리 수정         | `git filter-branch` 또는 **추천: `git filter-repo`**  |
| 3️ Git 정리              | `git gc`, `reflog expire` 등                         |
| 4️ GitHub 강제 푸시      | `git push --force`                                   |
| 5️ GitHub 캐시 삭제 요청 | [GitHub Support](https://support.github.com/contact) |
| 6️ 팀원 공지             | clone or rebase 필요성 안내                           |

# 이슈기반 버전관리 (Version Control Based on Issues)
- 이슈기반 버전관리는 버그 수정, 기능 추가, 개선 등의 작업을 이슈 단위로 정의하고 이를 **버전관리 시스템(Git)**과 연계하여 소프트웨어 개발을 체계적으로 수행하는 방식입니다. 개발자는 이슈를 중심으로 브랜치를 만들고 커밋 및 PR(Pull Request)을 통해 작업 이력을 명확하게 관리할 수 있습니다.

1. 주요 장점
- 작업 추적 용이: 이슈로 각 작업이 명확히 구분되어, 누가 어떤 일을 하는지 쉽게 파악할 수 있습니다.
- 협업 효율성 향상: 이슈에 댓글, 파일 첨부 등을 통해 팀원 간 소통이 원활해집니다.
- 코드 변경 이력 연결: 커밋과 PR을 이슈에 연결하여 변경 사항의 배경을 쉽게 추적할 수 있습니다.
- 프로젝트 진행 시각화: 이슈 상태(Open, In Progress, Closed 등)로 프로젝트 전반 상황을 한눈에 파악할 수 있습니다.

2. GitHub 기능을 활용한 이슈기반 버전관리

| 기능                      | 설명                                                                           |
| ------------------------- | ------------------------------------------------------------------------------ |
| **GitHub Issues**         | 이슈 생성, 레이블, 담당자 지정, 템플릿 제공 등 이슈 관리 기능 지원                  |
| **Projects (보드)**       | Kanban 보드를 통해 이슈와 PR을 시각적으로 관리 (`To Do`, `In Progress`, `Done` 등) |
| **Pull Requests**         | PR에서 `Fixes #이슈번호`로 이슈 자동 종료 가능, 코드 리뷰 및 병합 기능 제공          |
| **Actions**               | 이슈 생성, PR 오픈 등 이벤트에 따라 테스트/배포 자동화 워크플로우 실행 가능           |
| **브랜치 네이밍 규칙**    | `feature/123-login`, `bugfix/456-crash` 등 이슈 번호 기반 브랜칭으로 추적 용이      |

3. 외부 도구와의 연동
- Slack : 이슈 생성, PR 알림 등을 Slack 채널로 실시간 전송하여 커뮤니케이션 강화
- Jira : 이슈 상태를 GitHub 커밋, PR과 연동하여 자동 업데이트 → 워크플로우 통합 관리 가능

4. 실무 팁
- 브랜치 네이밍 예시 :
  - feature/101-add-login
  - bugfix/203-fix-null-error
- 커밋 메시지 예시:
- Fix : 로그인 실패 시 알림 메시지 추가 (Fixes #101)
- PR 작성 시 자동 이슈 닫기 :
- PR 본문에 Fixes #이슈번호 입력 → PR 병합 시 이슈 자동 닫힘

5. 결론
이슈기반 버전관리는 소프트웨어 개발의 가시성, 협업 효율성, 이력 추적성을 높여주는 강력한 관리 전략입니다. GitHub의 다양한 기능 및 외부 도구 연동을 활용하면 더 체계적이고 생산적인 개발 환경을 구축할 수 있습니다.

# 이슈 템플릿의 개요

1. 이슈 템플릿 (Issue Template)
- 이슈 템플릿은 GitHub에서 이슈를 생성할 때 일정한 형식으로 필요한 정보를 빠짐없이 입력하도록 돕는 사전 양식입니다.
- 버그 리포트, 기능 요청, 일반 작업 등 이슈 유형별로 템플릿을 구분해 사용할 수 있으며 .github/ISSUE_TEMPLATE/ 디렉토리에 마크다운(.md) 형식으로 저장합니다.

2. 이슈 템플릿의 주요 장점
1) 📋 일관된 이슈 작성
- 형식 통일: 모든 이슈가 같은 구조를 따르므로, 읽고 이해하기 쉬운 이슈 관리가 가능합니다.
- 정보 누락 방지: 필수 항목을 템플릿에 포함시켜, 필요한 정보가 빠지지 않도록 유도합니다.

2) 협업 효율 향상
- 명확한 커뮤니케이션 : 이슈가 명확하게 작성되면, 팀원 간 오해 없이 빠르게 소통할 수 있습니다.
- 빠른 문제 해결 : 예) 버그 리포트 시 재현 절차, 기대 결과 등 핵심 정보가 포함되어 있어 개발자가 바로 대응 가능.
3) 프로젝트 관리 최적화
- 자동화 연동 가능 : GitHub Actions 등과 연계하여, 이슈 생성 시 라벨 자동 부착, 보드 추가 등의 자동 작업이 가능.
- 유형별 정보 수집 : 기능 추가, 버그, 질문 등 다양한 유형에 맞는 맞춤 템플릿 제공으로 체계적인 이슈 분류가 가능.
4) 신규 팀원 온보딩 지원
- 작성 가이드 역할 : 템플릿이 작성 예시와 함께 안내 역할을 해 초보자도 쉽게 이슈를 생성할 수 있습니다.
- 일관된 문화 정착 : 팀 내 이슈 관리 방식이 자연스럽게 공유되고 정착됩니다.

3. 이슈 템플릿 예시
- GitHub 이슈 템플릿은 프로젝트 관리의 일관성과 효율성을 높이기 위해 다양한 유형별로 활용됩니다.

1) 버그 리포트 템플릿 (bug_report.md)
2) 기능 요청 템플릿 (feature_request.md)
3) 개발 작업 템플릿 (task.md)
4) 기타 템플릿 (custom_template.md)

4. 템플릿 사용 방법

1) 디렉토리 설정 : 리포지토리 루트에 `.github/ISSUE_TEMPLATE/` 디렉토리를 생성합니다.
2) 템플릿 파일 추가 : 위의 템플릿 예시들을 각각 `bug_report.md`, `feature_request.md`, `task.md`, `custom_template.md` 등으로 저장합니다.
3) 이슈 생성 시 템플릿 선택 : 템플릿을 추가한 후 이슈를 생성할 때 사용자는 적절한 템플릿을 선택할 수 있습니다.

이 템플릿들을 사용하면, 팀이 이슈를 체계적으로 관리하고, 일관된 양식으로 이슈를 기록하는 데 도움을 줄 수 있습니다. 이를 통해 이슈 처리 속도와 협업의 효율성을 높일 수 있습니다.

5. 템플릿 설명
 -이러한 견본 예시는 실제로 GitHub에서 이슈를 생성할 때 사용될 수 있는 예제입니다. 각 템플릿에 따라 작성된 이슈는 다음과 같은 구조를 가지며 팀원들이 작업을 명확히 이해하고 체계적으로 문제를 해결할 수 있도록 돕습니다.

- 버그 리포트 : 발생한 문제를 명확하게 설명하고, 재현 방법과 예상 결과를 포함하여 문제 해결에 필요한 모든 정보를 제공합니다.
- 기능 요청 : 현재 문제점과 원하는 기능을 명확히 기술하여 기능 구현의 방향성을 제시합니다.
- 개발 작업 : 구체적인 작업 지침과 수락 기준을 제공하여 개발자가 명확하게 작업을 수행할 수 있도록 합니다.

# GitHub Pull Request (PR) 템플릿 사용 가이드

1. PR 템플릿이란?
- PR 템플릿은 팀원들이 일관된 형식으로 Pull Request를 작성하도록 돕는 GitHub의 기능입니다. PR 템플릿을 사용하면 PR 작성 시 포함해야 할 중요 정보를 빠뜨리지 않고 명확하게 제공할 수 있으며 리뷰어가 PR을 쉽게 이해하고 검토할 수 있도록 합니다.

2. PR 템플릿 설정 방법

# 2.1. `.github` 디렉토리 생성

1. GitHub 리포지토리의 루트 디렉토리에 `.github` 디렉토리를 생성합니다.
    
    ```bash
    mkdir -p .github
    
    ```
    

### 2.2. 템플릿 파일 생성

1. `.github/` 디렉토리 안에 `pull_request_template.md` 파일을 생성합니다.
    
    ```bash
    touch .github/pull_request_template.md
    
    ```
    
2. 생성한 파일에 템플릿 내용을 작성합니다. 예시 템플릿을 아래에 제공합니다.

## 3. PR 템플릿 작성 예시

아래는 PR 작성 시 사용할 수 있는 템플릿 예시입니다.

```markdown
## 개요
- 이 PR에서 무엇을 변경했는지 간단하게 설명해주세요.

## 변경 사항
- 변경된 주요 기능, 추가된 코드, 수정된 부분 등을 구체적으로 설명해주세요.
  - 예: 로그인 로직 수정
  - 예: 회원가입 API 추가
  - 예: UI 개선

## 테스트 방법
- 이 변경사항이 어떻게 테스트되었는지 설명해주세요.
  - 예: 테스트 케이스 추가
  - 예: 로컬 환경에서의 테스트 결과
  - 예: CI/CD에서의 테스트 결과

## 관련 이슈
- 이 PR과 관련된 이슈 번호를 작성해주세요. (e.g., `#123`)
  - Resolves #

## 추가 설명
- 코드 리뷰어가 이해하는 데 도움이 될 만한 추가 설명이나 스크린샷, 참고 자료를 제공해주세요.

```

4. PR 템플릿 사용 예시
- PR 템플릿이 설정된 후 사용자가 Pull Request를 생성할 때 이 템플릿이 자동으로 PR 본문에 로드됩니다. 사용자는 해당 템플릿에 맞게 PR 내용을 채우고 제출하면 됩니다.

**예시:**

```markdown
## 개요
- 로그인 페이지에서 발생한 버그를 수정했습니다.

## 변경 사항
- 로그인 실패 시 오류 메시지가 표시되지 않던 문제를 수정했습니다.
- 로그인 성공 후 리다이렉트가 제대로 작동하도록 수정했습니다.

## 테스트 방법
- 로컬 환경에서 다양한 입력 값으로 로그인 시도.
- 잘못된 로그인 정보 입력 시 올바른 오류 메시지 표시 확인.
- 유효한 로그인 정보 입력 후 홈 화면으로 리다이렉트 확인.

## 관련 이슈
- Resolves #101
- Resolves #102

## 추가 설명
- 이번 수정은 기존 로그인 로직에 약간의 리팩토링을 포함하고 있습니다. 리뷰어께서 특히 로그인 로직 부분의 변경 사항을 중점적으로 확인해주시면 감사하겠습니다.

```

5. PR 템플릿 활용의 장점

- 일관된 정보 제공 : 모든 PR이 동일한 형식을 따르므로 리뷰어가 중요한 정보를 쉽게 찾고 이해할 수 있습니다.
- 명확한 커뮤니케이션 : PR에 포함해야 할 주요 정보를 명확하게 작성하도록 유도하여 팀 내 커뮤니케이션을 개선합니다.
- 효율적인 코드 리뷰 : 코드 리뷰어가 PR 내용을 더 쉽게 파악하고 필요한 경우 피드백을 제공할 수 있습니다.
