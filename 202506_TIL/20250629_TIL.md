# 2025년 6월 29일


---

# 배열

- 변수는 1개의 데이터만 저장할 수 있습니다. 그렇기 때문에 저장해야 할 데이터의 수가 많아지면 그만큼 많은 변수가 필요하고 코드도 매우 길어진다.
- 많은 양의 데이터를 적은 코드로 손쉽게 처리할 수 있는 배열에 대해 알아보자.

- 학생 30명의 성적을 저장하고 평균값을 구한다고 가정해보자. 먼저 학생 30명의 성적을 저장하기 위해 변수 30개를 선언해야 한다.
```java
int score1 = 83;
int score2 = 90;
int score3 = 87;
...
int score30 = 75;
```
- 그리고 평균값을 구하기 위해 변수들을 모두 더해야 한다.
```java
int sum = score1;
sum += score2;
sum += score3;
...
sum += score30;
int avg = sum /30;
```
- 위와 같은 방법은 매우 비효율적이고 지루한 코딩이 된다. 만약 전교 학생들의 성적을 처리할 경우 수백개의 변수 선언으로 인해 코드는 끔직해진다.
- 많은 양의 데이터를 다루는 프로그램에서는 좀 더 효율적인 방법이 필요한데 이때 배열을 사용할 수 있다.


## 배열이란?

- 배열은 같은 타입의 데이터를 연속된 공간에 나열하고 각 데이터에 인덱스를 부여해놓은 자료구조이다. 예를 들어 <시작하기 전에> 에서 언급했던 학생들의 성적은 다음과 같이 score 배열로 생성할 수 있다.

- socre 배열의 각 인덱스는 각 항목의 데이터를 읽거나 저장하는 데 사용되며 다음과 같이 배열 이름옆에 대괄호[]에 기입된다. 인덱스는 0부터시작한다.
- score[인덱스]

- 예를들어 score[0]은 83, score[1]은 90, score[2]는 87 값을 가진다. 이렇게 성적을 배열로 만들면 성적으 ㅣ평균값은 배열의 인덱스를 사용해서 for문으로 쉽게 구할 수 있다.
```java
int sum = 0;
for(int i = 0; i <30; i++) {
  sum += score[i];
}
int avg = sum / 30;
```
- for문이 30번 반복 실행하면서 i가 0 ~ 29 까지 변하고 있다. 따라서 sum 변수는 score[0]~ score[29]까지 더해지고 마지막으로 얻은 sum을 30으로 나누어 평균 avg를 얻는다. 학생 수가 30명이 아니라 수백 명이 되어도 for문의 조건식 i<30만 변경하면 되므로 많은 양의 데이터를 적은 코드로 손쉽게 처리할 수 있다.

- 배열은 다음과 같은 특징을 가진다.
1. 배열은 같은 타입의 데이터만 저장할 수 있다.
   - int 배열은 int 값만, String 배열은 문장려만 저장한다. 또한 선언과 동시에 저장할 수 있는 타입이 결정된다. 만약 다른타입의 값을 저장하려고 하면 타입 불일치Type missmatch 컴파일 에러가 발생한다.
2. 한 번 생성된 배열은 길이를 늘리거나 줄일 수 없다.
   - 3개의 값을 저잦ㅇ하는 배열을 생성했다고 가정해보자. 프로그램 실행 도중에 5개의 값을 저장하는 배열로 수정할 수 없고 반대로 2개의 값만 저장하는 배열로 수정할 수도 없다. 만약 5개의 값을 저장해야 하는 경우가 발생한다면 길이 5의 새로운 배열을 생성하고 기존 배열 항목을 새 배열로 복사해야 한다.

 ## 배열 선언

- 배열을 사용하기 위해서는 우선 배열 변수를 선언해야 한다. 배열 변수 선언은 다음과 같이 두 가지 형식으로 작성할 수 있다.
  - 형식 1: 타입[] 변수;
  - 형식 2: 타입 변수[];
- 대괄호[]는 배열 변수를 선언하는 기호로 사용되는데 타입 뒤에 붙을 수도 있고 변수 뒤에 붙을 수도 있다. 타입은 배열에 저장될 데이터의 타입을 말한다.
```java
// 타입별로 배열을 선언하는 예이다.
int[] intArray;
double[] doubleArray;
String[] strArray;

int intArray[];
double doubleArray[];
String strArray[];
```
- 배열 변수는 참조 변수에 속한다. 배열도 객체이므로 힙 영역에 생성되고 배열 변수는 힙 영역의 배열 객체를 참조하게 된다. 만일 참조할 배열 객체가 없다면 배열 변수는 null 값으로 초기화될 수 있다.
```java
타입[] 변수 = null;
```
- 만약 배열 변수가 null 값을 가진 상태에서 변수[인덱스]로 값을 읽거나 저장하게 되면 NullPointerException이 발생한다. 배열을 생성하고 배열 변수가 참조하는 상태에서 값을 저장하거나 읽어야한다.


## 배열 생성
- 배열 객체를 생성하려면 값 목록을 이용하거나 new 연산자를 이용하는 방법이 있다.

### 값 목록으로 배열 생성

- 값의 목록이 있다면 다음과 같이 간단하게 배열 객체를 생성할 수 있다.
```java
타입[] 변수 = { 값0, 값1, 값2, 값3, ...};
```
- 중괄호 {}는 주어진 값등릉ㄹ 항목으로 가지는 배열 객체를 힙에 생성하고 배열 객체의 번지를 리턴한다. 배열 변수는 리턴된 번지를 저장함으로써 참조가 일워진다. 예를 들어 "홍길동", "김자바", "뽀로로" 문자열을 갖는 배열은 다음과 같이 생성할 수 있다.
```java
String[] names = {"홍길동", "김자바", "뽀로로"};
```
- 이렇게 생성됨 배열에서 "홍길동"은 names[0], "김자바"는 names[1], "뽀로로"는 names[2]로 읽을 수 있다. names[0]의 "홍길동을" "홍삼원"으로 바꾸고 싶다면 다음과 같이 대입 연산자를 사용하면 된다.
```java
names[1] = "홍삼원";
```

- 값의 목록으로 배열 객체를 생성할 때는 배열 변수를 이미 선언한 후에는 다른 실행문에서 중괄호를 사용한 배열 생성이 허용되지 않는다는 점을 주의해야 한다.
```java
타입[] 변수;
변수 = { 값0, 값1, 값2, 값3, ... }; <- 컴파일 에러
```
- 배열 변수를 미리 선언한 후 값 목록들이 나중에 결정되는 상황이라면 당므과 같이  new 연산자를 사용해 값 목록을 지정해주면 된다. new 연산자 바로 뒤에느 ㄴ배열 변수 선언에서 사용한 "타입[]"를 붙여주고 중괄호 {}에는 값들을 나열해준다.
```java
변수 = new 타입[] { 값0, 값1, 값2, 값3, ... };
```
- 예를 들어 배열 names를 다음과 같이 생성할 수 있다.
```java
String[] names = null;
names = new String[] { "뽀로로", "하츄핑", "김자바" };
```
- 메소드의 매개값이 배열일 경우에도 마찬가지이다. 아래와 같이 매개 변수로 int[]배열이 선언된 add[] 메소드가 있을 경우, 값 목록으로 배열을 생성함과 동시에 add() 메소드의 매개값으로 사용하고자 할 때느 반드시 new 연산자를 사용해야 한다.
```java
int add(int[] scores) { ... }

int result = add( {95, 85, 90} ); // 컴파일 에러
int result = add( new int[] {95, 85, 90} );
```

### new연산자로 배열 생성

- 값의 목록을 가지고 있지 않지만, 향후 값들을 저장할 배열을 미리 만들고 싶다면 new 연산자로 다음과 같이 배열 객체를 생성할 수 있다.
```java
타입[] 변수 = new 타입[길이];
```

- 길이는 배열이 저장할 수 있는 값의 개수를 말한다. 이미 배열 변수가 선언된 경우에도 new 연산자로 배열을 생성할 수 있다.
```java
타입[] 변수 = null;
변수 = new 타입[길이];
```

- 다음은 길이가 5인 int[] 배열을 생성한다.
```java
int[] intArray = new int[5];
```

- new연산자로 배열ㅇ르 처음 생성할 경우 배열은 자동적으로 기본값으로 초기화된다. 학생 30명의 점수를 저장할 배열을 다음과 같이 생성한다고 가정해보자.
- scores 배열은 int 배열이므로 다음과 같이 scores[0] ~ scores[29] 까지 모두 null 값으로 초기화된다.
```java
String[] names = new String[30];
```

- 타입별 배열의 초기값
  - 기본 타입(정수): byte[],char[],short[],int[],long[] = 0, '\u0000', 0, 0, 0L
  - 기본 타입(실수): float[],double[] = 0.0F, 0.0
  - 기본 타입(논리): boolean = false
  - 참조 타입: 클래스[], 인터페이스[] = null
 
## 배열 요소 접근 / 수정 / 순회

### 배열 요소 접근
- 배열은 인덱스를 통해 개별 요소에 접근한다.
- 인덱스는 0부터 시작한다.
```java
int[] scores = {90, 80, 70};
int firstScore = scores[0]; // 90
```

### 배열 요소 수정
- 대입 연산자를 통해 값을 수정할 수 있다.
```java
scores[1] = 85; // scores 배열의 두 번째 요소를 85로 수정
```

### 배열 순회
- 보통 `for` 또는 `enhanced for` 문을 사용하여 배열을 반복 처리한다.
```java
for (int i = 0; i < scores.length; i++) {
    System.out.println(scores[i]);
}

for (int score : scores) {
    System.out.println(score);
}
```

---

## 다차원 배열

### 2차원 배열 선언과 생성
- 2차원 배열은 배열의 배열이다.
```java
int[][] matrix = new int[2][3]; // 2행 3열
```

### 초기화
```java
int[][] matrix = {
    {1, 2, 3},
    {4, 5, 6}
};
```

### 요소 접근
```java
int value = matrix[0][1]; // 2
```

### 순회
```java
for (int i = 0; i < matrix.length; i++) {
    for (int j = 0; j < matrix[i].length; j++) {
        System.out.print(matrix[i][j] + " ");
    }
    System.out.println();
}
```

---

## 배열 복사

### for문을 통한 복사
```java
int[] oldArray = {1, 2, 3};
int[] newArray = new int[5];

for (int i = 0; i < oldArray.length; i++) {
    newArray[i] = oldArray[i];
}
```

### System.arraycopy()
```java
System.arraycopy(oldArray, 0, newArray, 0, oldArray.length);
```

---

## Arrays 클래스

### java.util.Arrays 클래스는 배열 관련 다양한 유틸리티 메소드를 제공한다.

#### 배열 출력
```java
import java.util.Arrays;

System.out.println(Arrays.toString(scores));
```

#### 배열 정렬
```java
Arrays.sort(scores);
```

#### 배열 비교
```java
int[] a = {1, 2, 3};
int[] b = {1, 2, 3};
boolean same = Arrays.equals(a, b); // true
```

#### 배열 복사
```java
int[] copied = Arrays.copyOf(scores, scores.length);
```

#### 범위 복사
```java
int[] partial = Arrays.copyOfRange(scores, 0, 2);
```
