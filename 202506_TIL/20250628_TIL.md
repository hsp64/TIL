# 2025년 6월 28일


---

# Java 참조 타입과 참조 변수 

- 자바의 타입은 크게 기본 타입과 참조 타입으로 분류된다. 기본 타입은 정수, 실수, 문자, 논리 리터럴을 저장하는 타입을 말한다.
- 참조 타입이란 객체의 번지를 참조하는 타입으로 배열, 열거, 클래스, 인터페이스를 말한다.

## 기본 타입과 참조 타입

- 기본 타입으로 선언된 변수와 참조 타입으로 선언된 변수의 차이점은 저장되는 값이다.
- 기본 타입은 byte, char, short, int, long, float, double, boolean 변수는 실제 값을 변수 안에 저장하지만, 참조 타입인 배열, 열거, 클래스, 인터페이스 변수는 메모리의 번지를 변수 안에 저장한다.
- 번지를 통해 객체를 참조한다는 뜻에서 참조 타입이라고 부른다.

```java

기본타입 변수        참조 타입 변수
  실제 값              100번지       ->     100번지객체
```

- 예를 들어 int 타입과 double 타입으로 선언된 변수 age와 price가 있고 String 클래스로 선언된 name과 hobbby가 있다고 가정해보겠습니다.

```java

// 기본 타입 변수
int age = 25;
double price = 100.5;

// 참조 타입 변수
String name = "신용권";
String hobby = "독서";

```

- int 타입 변수인 age와 double 타입 변수인 price는 직접 값을 저장하고 있지만 String 클래스 변수인 name과 hobby는 힙 영역의 String 객체 번지 값을 가지고 있다. 
- 이처럼 번지를 통해 객체를 참조하기 때문에 String 클래스 변수를 차몾 타입 변수라고 한다.


## 메모리 사용 영역

- JVM이 사용하는 메모리 영역에 대해서 알아보자.
- JVM은 운영체제에서 할당받은 메모리 영역을 다음과 같이 세부 영역으로 구분해서 사용한다.

### 메소드 영역

- 메소드 영역은 JVM이 시작할 때 생성되고 모든 스레드가 공유하는 영역이다. 메소드 영역에느 ㄴ코드에서 사용되는 클래스들을 클래스 로더에 일거 클래스별로 정적 필드와 상수, 메소드 코드 등을 분류해서 저장한다.

### 힙 영역

- 힙 영역은 객체와 배열이 생성되는 영역이다. 여기에 생성된 객체와 배열은 JVM 스택 영역의 변수나 다른 객체의 필드에서 참조한다.
- 만일 참조하는 변수나 필드가 없다면 의미 없는 객체가 되기 때문에 JVM이 이것을 쓰레기 취급하고 쓰레기 수집기(GarbageCollector)를 실행시켜 자동으로 제거한다.
- 개발자는 객체를 제거하기 위해 별도의 코드를 작성할 필요가 없다.

### JVM 스택 영역

- JVM 스택은 메소드를 호출할 때마다 프레임을 추가하고 메소드가 종료되면 해당 프레임을 제거하는 동작을 수행한다.

- 프레임 내부에서 로컬 변수 스택이 있는데 기본 타입 변수와 참조 타입 변수가 추가되거나 제거된다.
- 스택 영역에 변수가 생성되는 시점은 초기화가 될 때 최초로 변수에 값이 저장될 때이다. 변수는 선언된 블록 안에서만 스택에 존재하고 블록을 벗어나면 스택에서 제거된다.
```java
char v1 = 'A';

if (v1 == 'A') {
  int v2 = 100;
  double v3 = 3.14;
}

bollean v4 = true;
```
  - 선언된 변수는 실행 순서에 따라서 다음과 같이 스택에 생성되고 소멸된다.
  - v2와 v3은 if블록 내부가 실행되고 있을 때만 스택 영역에 존재하고 if블록을 빠져나가면 소멸된다.

1. 실행 - 스택영역: v1 / A
2. 실행 - 스택영역: v3 / 3.14   v2 / 100   v1 / A
3. 실행 - 스택영역: v4 / ture  v1 / A

- 기본 타입 변수는 스택 영역에 직접 값을 가지고 있지만 참조 타입 변수는 스택 영역에 힙 영역의 객체 주소를 가진다.
- 다음과 같이 배열 변수인 scores는 스택 영역에 생성되지만 실제 10, 20, 30을 갖는 배열은 힙 영역에 생성된다.
- 배열 변수 scores에는 배열의 힙 영역의 주소가 저장된다 참고로 자바에서는 배열을 객체로 취급한다.
```java
int[] scores = {10, 20, 30};
```
  - 스택영역: score / 5번지 -> 힙 영역: (5번지) 10 / 20 / 30

## 참조 변수의 ==, != 연산

- 기본 타입 변수의 ==, != 연산은 변수의 값이 같은지, 아닌지를 조사하지만 참조 타입 변수들 간의 ==, != 연산은 동일한 객체를 참조하는지, 다른객체를 참조하는지 알아볼 때 사용된다.
- 참조 타입 변수의 값은 힙 영역의 객체 주소이므로 ==, != 연산은 결국 번지 값을 비교하는 것이 된다. 동일한 번지 값을 갖고 있다는 것은 동일한 객체를 참조한다는 의미이다.
- 따라서 동일한 객체를 참조하고 있을 경우 == 연산의 결과는 true 이고 != 연산의 결과는 false이다

## null과 NullPointerException

- 참조 타입 변수는 힙 영역의 객체를 참조하지 않는다는 뜻으로 null(널) 값을 가질 수 있다. null 값도 초기값으로 사용할 수 있기 때문에 null로 초기화된 참조 변순느 스택 영역에 생성된다.
- 참조 타입 변수가 null 값을 가지는지 확인하려면 다음과 같이 ==, != 연산을 수행하면 된다.

- 스택 영역: reVar1; reVar2 = null; 

```java
refVar1 == null // false
refVar1 != null // true

// refVar2는 null 값을 가지므로 연산의 결과는 다음과 같다.
reVar2 == null // true
reVar2 != null // false
```

- 자바는 프로그램 실행 도중에 발생하는 오류를 예외라고 부른다 예외는 사용자의 잘못된 입력으로 발생할 수 있고 프로그래머가 코드를 잘못 작성해서 발생할 수 있다.
- 참조 변수를 사용하면서 가장 많이 발생하는 예외 중 하나로 NullPointerException이 있다. 이 예외는 참조 타입 변수를 잘못 사용하면 발생한다.
- 참조 변수가 null을 가지고 있을 경우에는 참조 객체가 없으므로 변수를 통해 객체를 사용할 수 없다. 만약 null 상태에서 있지도 않은 객체의 데이터(필드)나 메소드를 사용하는 코드를 실행하면 NullPointerExection이 발생한다.
```java
int[] intArarray = null;
intArray[0] = 10; // NullPointerException
```
- 위 코드에서 intArray는 배여 ㄹ변수이므로 참조 변수이다. 그래서 null로 초기화가 가능합니다. 이 상태에서 intArray[0]에 10을 저장하려고 하면 NullPointerException이 발생한다. intArray변수가 참조하는 배열 객체가 없기 때문이다.

```java
String str = null;
System.out.println("총 문자수: " + str.length()); < NullPointerException
```
- String은 클래스이므로 참조 타입이다. 따라서 str 변수도 null로 초기화할 수 있습니다. 이 상태에서 String 객체의 length()라는 메소드를 호출하면 NullPointerException이 발생한다.
- 이유는 str 변수가 참조하는 String 객체가 없기 때문이다. 해결 방법은 참조 변수를 추적해서 객체를 참조하도록 수정하는 것이다.
- NullPointerException은 아마 앞으로 가장 많이 볼 수 있는 예외 중 하나일 것이다.

## String 타입

- 자바는 문자열을 String 변수에 저장하기 때문에 다음과 같이 STring 변수를 우선 선언해야 한다.
```java
String 변수;
```
 - String 변수에 문자열을 저장하려면 큰따옴표로 감싼 문자열 리터럴을 대입한다.
```
String 변수 = "문자열";
```
  - 다음은 2개의 Stirng 변수를 선언하고 문장령르 저장하는ㄱ ㅓㅅ이다.
```java
String name;
name = "홍길동";
String hobby = "자바";
```
- 사실 문자열을 String 변수에 저장한다는 말은 엄밀히 말해 틀린 표현이다. 문자열이 직접 변수에 저장되는 것이 아니라, 문자열은 String 객체로 생성되고 변수는 String 객체를 참조하기 때문이다.
- 일반적으로 String 변수에 저장한다고 표현한다. name 변수와 hobby 변수는 스택 영역에 생성되고 문자열 리터럴인 "신용권" 과 "자바"는 힙 영역에 객체로 생성된다. 그리고 name 변수와 hobby 변수에는 String 객체의 번지 값이 저장된다.

- 자바는 문자열 리터럴이 동일하다면 Stirng 객체를 공유하도록 되어 잇다. 다음과 같이 name1 과 name2 변수가 동일한 문자열 리터럴인 "신용권"을 참조할 경우 1 과 2 는 동일한 String 객체를 참조하게 된다.
```java
String name1 =  "홍길동";
String name2 = "홍길동";
```

- 일반적으로 변수에 문자열을 저장할 경우에는 문자열 리터럴을 사용하지만 new 연산자를 사용해서 직접 String  객체를 생성시킬 수도 있다.
- new 연산자는 힙 영역에 새로운 ㄱ개체를 만들 때 사용한느 연산자로 객체 생성 연산자라고 한다.
```java
String name1 = new String name1("신용권");
String name2 = new String name2("신용권");
```
  - 이 경우 name1 과 name2는 서로 다른 String 객체를 참조하고 잇다.

- 문자열 리터럴로 생성하느냐 new 연산자로 생성하느냐에 따라 비교 연산자의 결과는 달라질 수 있다.
- 동일한 문자열 리터럴로 String 객체를 생성했을 경우 == 연산의 결과는 true 가 나오지만, new 연ㅅ나자로 string 객체를 생성했을 경우 == 연산의 결과는 false가 나온다.
- == 연산자는 변수에 저장된 객체의 번지가 동일한지를 검사하기 때문이다.
```java
String name1 = "홍길동";
String name2 = "홍길동";
String name3 = new Stirng("홍길동");
```
- name1과 name2는 동일한 문자열 리터럴로 생성된 객체를 참조하기 때문에 name1 == name2의 결과는 true가 나온다. 그러나 name3은 new 연산자로 String 객체를 별도로 생성했기 때문에 name1 == name3은 false 가 나온다.

- 동일한 String 객체이건 다른 String 객체이건 상관없이 내부 문자열ㅇ르 배고하교 싶을 때에는 String 객체의 equals() 메소드를 사용해야 한다. equals() 메소드는 우너본 문자열과 매개값으로 주어진 비교 문자열이 동일하니 비교한 후 true 또는 false를 리턴한다.
```java
boolean result = str1.equals(str2); // str1은 원본 문자열 (str2)는 비교 문자열
```
- String 변수는 참조 타입이므로 초기값으로 null을 대입할 수 있는데, 이때 null은 String 변수가 참조하는 String 객체가 없다는 뜻이다.
```java
String hooby = null;
```

- 예를들어 hobby 변수가 String 객체를 참조하였으나 null을 대입함으로써 더 이상 String 객체를 참조하지 않도록 할 수도 있다.
```java
String hobby = "여행";
hobby = null;
```

- 그렇다면 참조를 잃은 String 객체는 어덯게 될까? JVM은 참조되지 않은 객체를 쓰레기 객체로 취급하고 쓰레기 수집가(Garbage Collector)를 구동시켜 메모리에서 자동 제거한다.

## 핵심 포인트

- 기본 타입 : byte, short, char, int, long, float, double, boolean 타입을 말하며 이들 타입의 변수에는 값 자체가 저장된다.
- 참조 타입 : 기본 타입을 제외한 배열, 열거, 클래스, 인터페이스 등을 말한다. 참조 타입의 변수에는 객체의 번지가 저장되고 번지로 객체를 참조한다는 의미에서 참조 타입이라고 한다.
- 메모리 사용 영역: JVM은 운영체제에세ㅓ 할당받은 메모리 영역을 메소드 영역, 힙 영역, 스택 영역으로 구분해서 사용한다. 메소드 영역에는 정적 필드, 상수, 메소드 코드, 생성자 코드가 위차하며, 힙 영역에는 객체가 생성된다. 그리고 스택 영역에는 변수가 생성된다.
- 번지 비교: 비교 연산자(==, !=)가 기본 타입에서 생성되면 값을 비교하지만, 참조 타입에서 사용되면 번지를 비교한다. ==이 true가 나오면 같은 객체를 참조한다는 뜻이고 false가 나오면 다른 객체를 참조한다는 뜻이다.
- null : 참조 타입 변수는 객체를 참조하지 않는느다는 뜻으로 null값을 가질수 잇다. null값도 초기값으로 사용할 수 있기 때문에 null로 초기화된 참조 변수는 스택 영역에 생성된다.
- NullPointerException: 참조 변수가 null을 가지고 있는 경우에는 참조 객체가 없으므로 차모 변수를 통해 객체를 사용할 수 없다. 만약 null인 참조 변수를 통해 있지도 않은 객체의 필드나 메소드를 사용하면 NullPonterException이 발생한다.



